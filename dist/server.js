var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType6;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType32;
    var RequestType42 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType42;
    var RequestType52 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType52;
    var RequestType62 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType62;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a3] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a4;
        return (_a4 = this._head) == null ? void 0 : _a4.value;
      }
      get last() {
        var _a4;
        return (_a4 = this._tail) == null ? void 0 : _a4.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count3) {
        this.errorEmitter.fire([this.asError(error), message, count3]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF2 = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF2:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger2, options) {
      const logger = _logger2 !== void 0 ? _logger2 : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options == null ? void 0 : options.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options == null ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime3) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime3);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime3) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime3);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime3) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime3);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime2 = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime2);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime2);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime2);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime2);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime2);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime2);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime2);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime2);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime2);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime2);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime2);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime2);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime2);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime2) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime2}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first3 = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first3)) {
              paramStart = 1;
              parameterStructures = first3;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first3 = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first3)) {
              paramStart = 1;
              parameterStructures = first3;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version2,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve3, reject) => {
            const resolveWithCleanup = (r) => {
              resolve3(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve3, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve3();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path13 = require("path");
    var os5 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process5) {
        super();
        this.process = process5;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process5) {
        super();
        this.process = process5;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path13.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path13.join(os5.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports3.DocumentUri = DocumentUri = {}));
      var URI2;
      (function(URI3) {
        function is(value) {
          return typeof value === "string";
        }
        URI3.is = is;
      })(URI2 || (exports3.URI = URI2 = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports3.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports3.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports3.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports3.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports3.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports3.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports3.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports3.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit2.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports3.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports3.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports3.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 || (exports3.DiagnosticSeverity = DiagnosticSeverity2 = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports3.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports3.CodeDescription = CodeDescription = {}));
      var Diagnostic3;
      (function(Diagnostic4) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic4.create = create;
        function is(value) {
          var _a3;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic4.is = is;
      })(Diagnostic3 || (exports3.Diagnostic = Diagnostic3 = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports3.Command = Command = {}));
      var TextEdit2;
      (function(TextEdit3) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit3.replace = replace;
        function insert4(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit3.insert = insert4;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit3.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit3.is = is;
      })(TextEdit2 || (exports3.TextEdit = TextEdit2 = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports3.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert4(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert4;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit2.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports3.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports3.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports3.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports3.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports3.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports3.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit2.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports3.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version2, text) {
          return { uri, languageId, version: version2, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports3.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports3.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports3.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports3.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports3.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports3.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert4, replace) {
          return { newText, insert: insert4, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports3.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports3.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports3.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports3.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports3.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports3.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports3.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports3.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports3.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports3.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports3.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports3.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports3.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports3.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports3.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind2;
      (function(CodeActionKind3) {
        CodeActionKind3.Empty = "";
        CodeActionKind3.QuickFix = "quickfix";
        CodeActionKind3.Refactor = "refactor";
        CodeActionKind3.RefactorExtract = "refactor.extract";
        CodeActionKind3.RefactorInline = "refactor.inline";
        CodeActionKind3.RefactorRewrite = "refactor.rewrite";
        CodeActionKind3.Source = "source";
        CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind3.SourceFixAll = "source.fixAll";
      })(CodeActionKind2 || (exports3.CodeActionKind = CodeActionKind2 = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports3.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic3.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports3.CodeActionContext = CodeActionContext = {}));
      var CodeAction2;
      (function(CodeAction3) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic3.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction3.is = is;
      })(CodeAction2 || (exports3.CodeAction = CodeAction2 = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports3.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports3.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports3.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports3.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports3.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports3.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports3.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports3.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports3.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports3.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports3.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports3.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit2.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports3.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports3.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports3.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports3.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports3.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports3.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports3.WorkspaceFolder = WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create(uri, languageId, version2, content) {
          return new FullTextDocument2(uri, languageId, version2, content);
        }
        TextDocument3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits2(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument3.applyEdits = applyEdits2;
        function mergeSort2(data, compare3) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare3);
          mergeSort2(right, compare3);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare3(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports3.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        function() {
          function FullTextDocument3(uri, languageId, version2, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version2;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version2) {
            this._content = event.text;
            this._version = version2;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min3, max4) {
          return toString.call(value) === "[object Number]" && min3 <= value && value <= max4;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind2;
    (function(DocumentDiagnosticReportKind3) {
      DocumentDiagnosticReportKind3.Full = "full";
      DocumentDiagnosticReportKind3.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind2 || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind2 = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version2, cells) {
        return { uri, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse3(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse3;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          var _a3;
          super.initialize(capabilities);
          if (((_a3 = capabilities == null ? void 0 : capabilities.window) == null ? void 0 : _a3.workDoneProgress) === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          var _a3, _b;
          super.fillServerCapabilities(capabilities);
          const changeNotifications = (_b = (_a3 = capabilities.workspace) == null ? void 0 : _a3.workspaceFolders) == null ? void 0 : _b.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments2 = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version: version2 } = td;
          if (version2 === null || version2 === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version2);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments2;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count3 = this._messages[message];
        if (!count3) {
          count3 = 0;
        }
        count3++;
        this._messages[message] = count3;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine4(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine4(one.console, two.console, combineConsoleFeatures),
        tracer: combine4(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine4(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine4(one.client, two.client, combineClientFeatures),
        window: combine4(one.window, two.window, combineWindowFeatures),
        workspace: combine4(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine4(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine4(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection2(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve3, reject) => {
            value.then((resolved) => resolve3(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection2;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url2 = require("url");
    var path13 = require("path");
    var fs8 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath2(uri) {
      let parsed = url2.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first3 = segments[0];
        let second = segments[1];
        if (first3.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path13.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath2;
    function isWindows4() {
      return process.platform === "win32";
    }
    function resolve3(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve4, reject) => {
        let env3 = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env3).forEach((key) => newEnv[key] = env3[key]);
        if (nodePath && fs8.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path13.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve4(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve3;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env3 = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env3[key] = process.env[key]);
      env3["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env: env3
      };
      if (isWindows4()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows4()) {
            return path13.join(prefix, "node_modules");
          } else {
            return path13.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows4()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path13.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs8.existsSync(__filename.toUpperCase()) || !fs8.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path13.normalize(child).indexOf(path13.normalize(parent)) === 0;
        } else {
          return path13.normalize(child).toLowerCase().indexOf(path13.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports2.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path13.isAbsolute(nodePath)) {
          nodePath = path13.join(workspaceRoot, nodePath);
        }
        return resolve3(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve3(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve3(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver-protocol@3.17.5/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures2;
    (function(ProposedFeatures3) {
      ProposedFeatures3.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures2 || (exports2.ProposedFeatures = ProposedFeatures2 = {}));
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var node_util_1 = require("util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports2.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection2;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert20(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message, ...rest] = args;
          logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
        }
      };
      console.count = function count3(label = "default") {
        const message = String(label);
        let counter = counters.get(message) ?? 0;
        counter += 1;
        counters.set(message, counter);
        logger.log(`${message}: ${message}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug2(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log2(...args) {
        logger.log(serialize(args));
      };
      console.error = function error(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message = "Trace";
        if (args.length !== 0) {
          message += `: ${serialize(args)}`;
        }
        logger.log(`${message}
${stack}`);
      };
      console.warn = function warn(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/.pnpm/vscode-languageserver@9.0.1/node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/.pnpm/@cspell+cspell-resolver@8.14.2/node_modules/@cspell/cspell-resolver/dist/requireResolve.js
var require_requireResolve = __commonJS({
  "node_modules/.pnpm/@cspell+cspell-resolver@8.14.2/node_modules/@cspell/cspell-resolver/dist/requireResolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.requireResolve = requireResolve2;
    function requireResolve2(filename, paths) {
      try {
        return require.resolve(filename, paths ? { paths } : void 0);
      } catch {
        return void 0;
      }
    }
  }
});

// node_modules/.pnpm/ini@4.1.1/node_modules/ini/lib/ini.js
var require_ini = __commonJS({
  "node_modules/.pnpm/ini@4.1.1/node_modules/ini/lib/ini.js"(exports2, module2) {
    var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
    var encode = (obj, opt = {}) => {
      if (typeof opt === "string") {
        opt = { section: opt };
      }
      opt.align = opt.align === true;
      opt.newline = opt.newline === true;
      opt.sort = opt.sort === true;
      opt.whitespace = opt.whitespace === true || opt.align === true;
      opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
      opt.bracketedArray = opt.bracketedArray !== false;
      const eol = opt.platform === "win32" ? "\r\n" : "\n";
      const separator = opt.whitespace ? " = " : "=";
      const children = [];
      const keys3 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
      let padToChars = 0;
      if (opt.align) {
        padToChars = safe(
          keys3.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)
        ).length;
      }
      let out = "";
      const arraySuffix = opt.bracketedArray ? "[]" : "";
      for (const k of keys3) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val) {
            out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
          }
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
        }
      }
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
      }
      for (const k of children) {
        const nk = splitSections(k, ".").join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const child = encode(obj[k], {
          ...opt,
          section
        });
        if (out.length && child.length) {
          out += eol;
        }
        out += child;
      }
      return out;
    };
    function splitSections(str, separator) {
      var lastMatchIndex = 0;
      var lastSeparatorIndex = 0;
      var nextIndex = 0;
      var sections = [];
      do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
          lastMatchIndex = nextIndex + separator.length;
          if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
            continue;
          }
          sections.push(str.slice(lastSeparatorIndex, nextIndex));
          lastSeparatorIndex = nextIndex + separator.length;
        }
      } while (nextIndex !== -1);
      sections.push(str.slice(lastSeparatorIndex));
      return sections;
    }
    var decode2 = (str, opt = {}) => {
      opt.bracketedArray = opt.bracketedArray !== false;
      const out = /* @__PURE__ */ Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      const duplicates = {};
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
          continue;
        }
        const match2 = line.match(re);
        if (!match2) {
          continue;
        }
        if (match2[1] !== void 0) {
          section = unsafe(match2[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match2[2]);
        let isArray3;
        if (opt.bracketedArray) {
          isArray3 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        } else {
          duplicates[keyRaw] = ((duplicates == null ? void 0 : duplicates[keyRaw]) || 0) + 1;
          isArray3 = duplicates[keyRaw] > 1;
        }
        const key = isArray3 ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__") {
          continue;
        }
        const valueRaw = match2[3] ? unsafe(match2[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray3) {
          if (!hasOwnProperty4.call(p, key)) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty4.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
          continue;
        }
        const parts = splitSections(k, ".");
        p = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__") {
            continue;
          }
          if (!hasOwnProperty4.call(p, part) || typeof p[part] !== "object") {
            p[part] = /* @__PURE__ */ Object.create(null);
          }
          p = p[part];
        }
        if (p === out && nl === l) {
          continue;
        }
        p[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove) {
        delete out[del];
      }
      return out;
    };
    var isQuoted = (val) => {
      return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
    };
    var safe = (val) => {
      if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
      }
      return val.split(";").join("\\;").split("#").join("\\#");
    };
    var unsafe = (val, doUnesc) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.slice(1, -1);
        }
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode2,
      decode: decode2,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var Module = require("module");
    var fs8 = require("fs");
    var resolveFrom2 = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs8.realpathSync(fromDirectory);
      } catch (error) {
        if (error.code === "ENOENT") {
          fromDirectory = path13.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error;
        }
      }
      const fromFile = path13.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, true);
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min3, max4, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports2.isInteger(min3) || !exports2.isInteger(max4)) return false;
      return (Number(max4) - Number(min3)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      const node = block.nodes[n];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      const stringify3 = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify3(child);
          }
        }
        return output;
      };
      return stringify3(ast);
    };
  }
});

// node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min3, max4, options) => {
      if (isNumber(min3) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max4 === void 0 || min3 === max4) {
        return String(min3);
      }
      if (isNumber(max4) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min3 + ":" + max4 + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min3, max4);
      let b = Math.max(min3, max4);
      if (Math.abs(a - b) === 1) {
        let result = min3 + "|" + max4;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min3) || hasPadding(max4);
      let state = { min: min3, max: max4, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min3, max4) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min3, nines);
      let stops = /* @__PURE__ */ new Set([max4]);
      while (min3 <= stop && stop <= max4) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min3, nines);
      }
      stop = countZeros(max4 + 1, zeros) - 1;
      while (min3 < stop && stop <= max4) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max4 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare3);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count3 = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count3++;
        }
      }
      if (count3) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count3], digits };
    }
    function splitToPatterns(min3, max4, tok, options) {
      let ranges = splitToRanges(min3, max4);
      let tokens = [];
      let start = min3;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max5 = ranges[i];
        let obj = rangeToPattern(String(start), String(max5), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max5 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max5, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max5 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
      return arr;
    }
    function compare3(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min3, len) {
      return Number(String(min3).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform2 = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-") value = value.slice(1);
      if (value === "0") return false;
      while (value[++index] === "0") ;
      return index > 0;
    };
    var stringify3 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a === 0) a = 0;
      if (b === 0) b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify3(start, end, options) === false;
      let format3 = options.transform || transform2(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format3(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format3 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min3 = Math.min(a, b);
      let max4 = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min3, max4, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format3(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      const walk3 = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix, node.value);
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk3(child, node);
          }
        }
        return output;
      };
      return walk3(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify3 = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk3 = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify3(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify3(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        const enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          const child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk3(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk3(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify3 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse3 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max4) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max4})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          const open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify3(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse3;
  }
});

// node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify3 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse3 = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse3(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify3(braces.parse(input, options), options);
      }
      return stringify3(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path13.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path13 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path13.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx2 = input.lastIndexOf(char, lastIdx);
      if (idx2 === -1) return input;
      if (input[idx2 - 1] === "\\") return exports2.escapeLast(input, char, idx2 - 1);
      return `${input.slice(0, idx2)}\\${input.slice(idx2)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan3 = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx2 = 0; idx2 < slashes.length; idx2++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx2];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx2 === 0 && start !== 0) {
              tokens[idx2].isPrefix = true;
              tokens[idx2].value = prefix;
            } else {
              tokens[idx2].value = value;
            }
            depth(tokens[idx2]);
            state.maxDepth += tokens[idx2].depth;
          }
          if (idx2 !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan3;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange2 = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count3 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count3++;
        }
        if (count3 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first3, rest, index) => {
          if (first3 === "\\") {
            backslashes = true;
            return m;
          }
          if (first3 === "?") {
            if (esc) {
              return esc + first3 + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first3 === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first3 === "*") {
            if (esc) {
              return esc + first3 + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx2 = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx2);
                const rest2 = prev.value.slice(idx2 + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange2(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2) return;
            const source2 = create(match2[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match2[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse3;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var scan3 = require_scan();
    var parse3 = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch.test(input, regex, options, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format3 = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format3 ? format3(input) : input;
      if (match2 === false) {
        output = format3 ? format3(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch.matchBase(input, regex, options, posix3);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch.matchBase = (input, glob, options, posix3 = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path13.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan3(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/.pnpm/micromatch@4.0.8/node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/.pnpm/micromatch@4.0.8/node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (v) => v === "" || v === "./";
    var hasBraces = (v) => {
      const index = v.indexOf("{");
      return index > -1 && v.indexOf("}", index) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult) options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys3 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys3) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix3 = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match2 = regex.exec(posix3 ? utils.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module2.exports = micromatch;
  }
});

// node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS({
  "node_modules/.pnpm/esprima@4.0.1/node_modules/esprima/dist/esprima.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["esprima"] = factory();
      else
        root["esprima"] = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.loaded = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var comment_handler_1 = __webpack_require__(1);
            var jsx_parser_1 = __webpack_require__(3);
            var parser_1 = __webpack_require__(8);
            var tokenizer_1 = __webpack_require__(15);
            function parse3(code, options, delegate) {
              var commentHandler = null;
              var proxyDelegate = function(node, metadata) {
                if (delegate) {
                  delegate(node, metadata);
                }
                if (commentHandler) {
                  commentHandler.visit(node, metadata);
                }
              };
              var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
              var collectComment = false;
              if (options) {
                collectComment = typeof options.comment === "boolean" && options.comment;
                var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
                if (collectComment || attachComment) {
                  commentHandler = new comment_handler_1.CommentHandler();
                  commentHandler.attach = attachComment;
                  options.comment = true;
                  parserDelegate = proxyDelegate;
                }
              }
              var isModule = false;
              if (options && typeof options.sourceType === "string") {
                isModule = options.sourceType === "module";
              }
              var parser2;
              if (options && typeof options.jsx === "boolean" && options.jsx) {
                parser2 = new jsx_parser_1.JSXParser(code, options, parserDelegate);
              } else {
                parser2 = new parser_1.Parser(code, options, parserDelegate);
              }
              var program = isModule ? parser2.parseModule() : parser2.parseScript();
              var ast = program;
              if (collectComment && commentHandler) {
                ast.comments = commentHandler.comments;
              }
              if (parser2.config.tokens) {
                ast.tokens = parser2.tokens;
              }
              if (parser2.config.tolerant) {
                ast.errors = parser2.errorHandler.errors;
              }
              return ast;
            }
            exports3.parse = parse3;
            function parseModule(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "module";
              return parse3(code, parsingOptions, delegate);
            }
            exports3.parseModule = parseModule;
            function parseScript(code, options, delegate) {
              var parsingOptions = options || {};
              parsingOptions.sourceType = "script";
              return parse3(code, parsingOptions, delegate);
            }
            exports3.parseScript = parseScript;
            function tokenize(code, options, delegate) {
              var tokenizer = new tokenizer_1.Tokenizer(code, options);
              var tokens;
              tokens = [];
              try {
                while (true) {
                  var token = tokenizer.getNextToken();
                  if (!token) {
                    break;
                  }
                  if (delegate) {
                    token = delegate(token);
                  }
                  tokens.push(token);
                }
              } catch (e) {
                tokenizer.errorHandler.tolerate(e);
              }
              if (tokenizer.errorHandler.tolerant) {
                tokens.errors = tokenizer.errors();
              }
              return tokens;
            }
            exports3.tokenize = tokenize;
            var syntax_1 = __webpack_require__(2);
            exports3.Syntax = syntax_1.Syntax;
            exports3.version = "4.0.1";
          },
          /* 1 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var CommentHandler = function() {
              function CommentHandler2() {
                this.attach = false;
                this.comments = [];
                this.stack = [];
                this.leading = [];
                this.trailing = [];
              }
              CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
                if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                  var innerComments = [];
                  for (var i = this.leading.length - 1; i >= 0; --i) {
                    var entry = this.leading[i];
                    if (metadata.end.offset >= entry.start) {
                      innerComments.unshift(entry.comment);
                      this.leading.splice(i, 1);
                      this.trailing.splice(i, 1);
                    }
                  }
                  if (innerComments.length) {
                    node.innerComments = innerComments;
                  }
                }
              };
              CommentHandler2.prototype.findTrailingComments = function(metadata) {
                var trailingComments = [];
                if (this.trailing.length > 0) {
                  for (var i = this.trailing.length - 1; i >= 0; --i) {
                    var entry_1 = this.trailing[i];
                    if (entry_1.start >= metadata.end.offset) {
                      trailingComments.unshift(entry_1.comment);
                    }
                  }
                  this.trailing.length = 0;
                  return trailingComments;
                }
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.node.trailingComments) {
                  var firstComment = entry.node.trailingComments[0];
                  if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                    trailingComments = entry.node.trailingComments;
                    delete entry.node.trailingComments;
                  }
                }
                return trailingComments;
              };
              CommentHandler2.prototype.findLeadingComments = function(metadata) {
                var leadingComments = [];
                var target;
                while (this.stack.length > 0) {
                  var entry = this.stack[this.stack.length - 1];
                  if (entry && entry.start >= metadata.start.offset) {
                    target = entry.node;
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
                if (target) {
                  var count3 = target.leadingComments ? target.leadingComments.length : 0;
                  for (var i = count3 - 1; i >= 0; --i) {
                    var comment = target.leadingComments[i];
                    if (comment.range[1] <= metadata.start.offset) {
                      leadingComments.unshift(comment);
                      target.leadingComments.splice(i, 1);
                    }
                  }
                  if (target.leadingComments && target.leadingComments.length === 0) {
                    delete target.leadingComments;
                  }
                  return leadingComments;
                }
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (entry.start <= metadata.start.offset) {
                    leadingComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                  }
                }
                return leadingComments;
              };
              CommentHandler2.prototype.visitNode = function(node, metadata) {
                if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                  return;
                }
                this.insertInnerComments(node, metadata);
                var trailingComments = this.findTrailingComments(metadata);
                var leadingComments = this.findLeadingComments(metadata);
                if (leadingComments.length > 0) {
                  node.leadingComments = leadingComments;
                }
                if (trailingComments.length > 0) {
                  node.trailingComments = trailingComments;
                }
                this.stack.push({
                  node,
                  start: metadata.start.offset
                });
              };
              CommentHandler2.prototype.visitComment = function(node, metadata) {
                var type = node.type[0] === "L" ? "Line" : "Block";
                var comment = {
                  type,
                  value: node.value
                };
                if (node.range) {
                  comment.range = node.range;
                }
                if (node.loc) {
                  comment.loc = node.loc;
                }
                this.comments.push(comment);
                if (this.attach) {
                  var entry = {
                    comment: {
                      type,
                      value: node.value,
                      range: [metadata.start.offset, metadata.end.offset]
                    },
                    start: metadata.start.offset
                  };
                  if (node.loc) {
                    entry.comment.loc = node.loc;
                  }
                  node.type = type;
                  this.leading.push(entry);
                  this.trailing.push(entry);
                }
              };
              CommentHandler2.prototype.visit = function(node, metadata) {
                if (node.type === "LineComment") {
                  this.visitComment(node, metadata);
                } else if (node.type === "BlockComment") {
                  this.visitComment(node, metadata);
                } else if (this.attach) {
                  this.visitNode(node, metadata);
                }
              };
              return CommentHandler2;
            }();
            exports3.CommentHandler = CommentHandler;
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.Syntax = {
              AssignmentExpression: "AssignmentExpression",
              AssignmentPattern: "AssignmentPattern",
              ArrayExpression: "ArrayExpression",
              ArrayPattern: "ArrayPattern",
              ArrowFunctionExpression: "ArrowFunctionExpression",
              AwaitExpression: "AwaitExpression",
              BlockStatement: "BlockStatement",
              BinaryExpression: "BinaryExpression",
              BreakStatement: "BreakStatement",
              CallExpression: "CallExpression",
              CatchClause: "CatchClause",
              ClassBody: "ClassBody",
              ClassDeclaration: "ClassDeclaration",
              ClassExpression: "ClassExpression",
              ConditionalExpression: "ConditionalExpression",
              ContinueStatement: "ContinueStatement",
              DoWhileStatement: "DoWhileStatement",
              DebuggerStatement: "DebuggerStatement",
              EmptyStatement: "EmptyStatement",
              ExportAllDeclaration: "ExportAllDeclaration",
              ExportDefaultDeclaration: "ExportDefaultDeclaration",
              ExportNamedDeclaration: "ExportNamedDeclaration",
              ExportSpecifier: "ExportSpecifier",
              ExpressionStatement: "ExpressionStatement",
              ForStatement: "ForStatement",
              ForOfStatement: "ForOfStatement",
              ForInStatement: "ForInStatement",
              FunctionDeclaration: "FunctionDeclaration",
              FunctionExpression: "FunctionExpression",
              Identifier: "Identifier",
              IfStatement: "IfStatement",
              ImportDeclaration: "ImportDeclaration",
              ImportDefaultSpecifier: "ImportDefaultSpecifier",
              ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
              ImportSpecifier: "ImportSpecifier",
              Literal: "Literal",
              LabeledStatement: "LabeledStatement",
              LogicalExpression: "LogicalExpression",
              MemberExpression: "MemberExpression",
              MetaProperty: "MetaProperty",
              MethodDefinition: "MethodDefinition",
              NewExpression: "NewExpression",
              ObjectExpression: "ObjectExpression",
              ObjectPattern: "ObjectPattern",
              Program: "Program",
              Property: "Property",
              RestElement: "RestElement",
              ReturnStatement: "ReturnStatement",
              SequenceExpression: "SequenceExpression",
              SpreadElement: "SpreadElement",
              Super: "Super",
              SwitchCase: "SwitchCase",
              SwitchStatement: "SwitchStatement",
              TaggedTemplateExpression: "TaggedTemplateExpression",
              TemplateElement: "TemplateElement",
              TemplateLiteral: "TemplateLiteral",
              ThisExpression: "ThisExpression",
              ThrowStatement: "ThrowStatement",
              TryStatement: "TryStatement",
              UnaryExpression: "UnaryExpression",
              UpdateExpression: "UpdateExpression",
              VariableDeclaration: "VariableDeclaration",
              VariableDeclarator: "VariableDeclarator",
              WhileStatement: "WhileStatement",
              WithStatement: "WithStatement",
              YieldExpression: "YieldExpression"
            };
          },
          /* 3 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var __extends = this && this.__extends || function() {
              var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
                d.__proto__ = b;
              } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports3, "__esModule", { value: true });
            var character_1 = __webpack_require__(4);
            var JSXNode = __webpack_require__(5);
            var jsx_syntax_1 = __webpack_require__(6);
            var Node = __webpack_require__(7);
            var parser_1 = __webpack_require__(8);
            var token_1 = __webpack_require__(13);
            var xhtml_entities_1 = __webpack_require__(14);
            token_1.TokenName[
              100
              /* Identifier */
            ] = "JSXIdentifier";
            token_1.TokenName[
              101
              /* Text */
            ] = "JSXText";
            function getQualifiedElementName(elementName) {
              var qualifiedName;
              switch (elementName.type) {
                case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                  var id = elementName;
                  qualifiedName = id.name;
                  break;
                case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                  var ns = elementName;
                  qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                  break;
                case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                  var expr = elementName;
                  qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                  break;
                /* istanbul ignore next */
                default:
                  break;
              }
              return qualifiedName;
            }
            var JSXParser = function(_super) {
              __extends(JSXParser2, _super);
              function JSXParser2(code, options, delegate) {
                return _super.call(this, code, options, delegate) || this;
              }
              JSXParser2.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
              };
              JSXParser2.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index;
                this.scanner.lineNumber = this.startMarker.line;
                this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              };
              JSXParser2.prototype.finishJSX = function() {
                this.nextToken();
              };
              JSXParser2.prototype.reenterJSX = function() {
                this.startJSX();
                this.expectJSX("}");
                if (this.config.tokens) {
                  this.tokens.pop();
                }
              };
              JSXParser2.prototype.createJSXNode = function() {
                this.collectComments();
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.createJSXChildNode = function() {
                return {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              };
              JSXParser2.prototype.scanXHTMLEntity = function(quote) {
                var result = "&";
                var valid = true;
                var terminated = false;
                var numeric = false;
                var hex = false;
                while (!this.scanner.eof() && valid && !terminated) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === quote) {
                    break;
                  }
                  terminated = ch === ";";
                  result += ch;
                  ++this.scanner.index;
                  if (!terminated) {
                    switch (result.length) {
                      case 2:
                        numeric = ch === "#";
                        break;
                      case 3:
                        if (numeric) {
                          hex = ch === "x";
                          valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                          numeric = numeric && !hex;
                        }
                        break;
                      default:
                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                        break;
                    }
                  }
                }
                if (valid && terminated && result.length > 2) {
                  var str = result.substr(1, result.length - 2);
                  if (numeric && str.length > 1) {
                    result = String.fromCharCode(parseInt(str.substr(1), 10));
                  } else if (hex && str.length > 2) {
                    result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                  } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                    result = xhtml_entities_1.XHTMLEntities[str];
                  }
                }
                return result;
              };
              JSXParser2.prototype.lexJSX = function() {
                var cp = this.scanner.source.charCodeAt(this.scanner.index);
                if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                  var value = this.scanner.source[this.scanner.index++];
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index - 1,
                    end: this.scanner.index
                  };
                }
                if (cp === 34 || cp === 39) {
                  var start = this.scanner.index;
                  var quote = this.scanner.source[this.scanner.index++];
                  var str = "";
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source[this.scanner.index++];
                    if (ch === quote) {
                      break;
                    } else if (ch === "&") {
                      str += this.scanXHTMLEntity(quote);
                    } else {
                      str += ch;
                    }
                  }
                  return {
                    type: 8,
                    value: str,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 46) {
                  var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                  var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                  var value = n1 === 46 && n2 === 46 ? "..." : ".";
                  var start = this.scanner.index;
                  this.scanner.index += value.length;
                  return {
                    type: 7,
                    value,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                if (cp === 96) {
                  return {
                    type: 10,
                    value: "",
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start: this.scanner.index,
                    end: this.scanner.index
                  };
                }
                if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                  var start = this.scanner.index;
                  ++this.scanner.index;
                  while (!this.scanner.eof()) {
                    var ch = this.scanner.source.charCodeAt(this.scanner.index);
                    if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                      ++this.scanner.index;
                    } else if (ch === 45) {
                      ++this.scanner.index;
                    } else {
                      break;
                    }
                  }
                  var id = this.scanner.source.slice(start, this.scanner.index);
                  return {
                    type: 100,
                    value: id,
                    lineNumber: this.scanner.lineNumber,
                    lineStart: this.scanner.lineStart,
                    start,
                    end: this.scanner.index
                  };
                }
                return this.scanner.lex();
              };
              JSXParser2.prototype.nextJSXToken = function() {
                this.collectComments();
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = this.lexJSX();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                if (this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var start = this.scanner.index;
                var text = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index];
                  if (ch === "{" || ch === "<") {
                    break;
                  }
                  ++this.scanner.index;
                  text += ch;
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.scanner.lineNumber;
                    if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                      ++this.scanner.index;
                    }
                    this.scanner.lineStart = this.scanner.index;
                  }
                }
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var token = {
                  type: 101,
                  value: text,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
                if (text.length > 0 && this.config.tokens) {
                  this.tokens.push(this.convertToken(token));
                }
                return token;
              };
              JSXParser2.prototype.peekJSXToken = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.lexJSX();
                this.scanner.restoreState(state);
                return next;
              };
              JSXParser2.prototype.expectJSX = function(value) {
                var token = this.nextJSXToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              JSXParser2.prototype.matchJSX = function(value) {
                var next = this.peekJSXToken();
                return next.type === 7 && next.value === value;
              };
              JSXParser2.prototype.parseJSXIdentifier = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 100) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
              };
              JSXParser2.prototype.parseJSXElementName = function() {
                var node = this.createJSXNode();
                var elementName = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = elementName;
                  this.expectJSX(":");
                  var name_1 = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                } else if (this.matchJSX(".")) {
                  while (this.matchJSX(".")) {
                    var object = elementName;
                    this.expectJSX(".");
                    var property = this.parseJSXIdentifier();
                    elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                  }
                }
                return elementName;
              };
              JSXParser2.prototype.parseJSXAttributeName = function() {
                var node = this.createJSXNode();
                var attributeName;
                var identifier = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var namespace = identifier;
                  this.expectJSX(":");
                  var name_2 = this.parseJSXIdentifier();
                  attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                } else {
                  attributeName = identifier;
                }
                return attributeName;
              };
              JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
                var node = this.createJSXNode();
                var token = this.nextJSXToken();
                if (token.type !== 8) {
                  this.throwUnexpectedToken(token);
                }
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              JSXParser2.prototype.parseJSXExpressionAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.finishJSX();
                if (this.match("}")) {
                  this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                }
                var expression = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              };
              JSXParser2.prototype.parseJSXNameValueAttribute = function() {
                var node = this.createJSXNode();
                var name = this.parseJSXAttributeName();
                var value = null;
                if (this.matchJSX("=")) {
                  this.expectJSX("=");
                  value = this.parseJSXAttributeValue();
                }
                return this.finalize(node, new JSXNode.JSXAttribute(name, value));
              };
              JSXParser2.prototype.parseJSXSpreadAttribute = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                this.expectJSX("...");
                this.finishJSX();
                var argument = this.parseAssignmentExpression();
                this.reenterJSX();
                return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
              };
              JSXParser2.prototype.parseJSXAttributes = function() {
                var attributes = [];
                while (!this.matchJSX("/") && !this.matchJSX(">")) {
                  var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  attributes.push(attribute);
                }
                return attributes;
              };
              JSXParser2.prototype.parseJSXOpeningElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                var name = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXBoundaryElement = function() {
                var node = this.createJSXNode();
                this.expectJSX("<");
                if (this.matchJSX("/")) {
                  this.expectJSX("/");
                  var name_3 = this.parseJSXElementName();
                  this.expectJSX(">");
                  return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                }
                var name = this.parseJSXElementName();
                var attributes = this.parseJSXAttributes();
                var selfClosing = this.matchJSX("/");
                if (selfClosing) {
                  this.expectJSX("/");
                }
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
              };
              JSXParser2.prototype.parseJSXEmptyExpression = function() {
                var node = this.createJSXChildNode();
                this.collectComments();
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                return this.finalize(node, new JSXNode.JSXEmptyExpression());
              };
              JSXParser2.prototype.parseJSXExpressionContainer = function() {
                var node = this.createJSXNode();
                this.expectJSX("{");
                var expression;
                if (this.matchJSX("}")) {
                  expression = this.parseJSXEmptyExpression();
                  this.expectJSX("}");
                } else {
                  this.finishJSX();
                  expression = this.parseAssignmentExpression();
                  this.reenterJSX();
                }
                return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
              };
              JSXParser2.prototype.parseJSXChildren = function() {
                var children = [];
                while (!this.scanner.eof()) {
                  var node = this.createJSXChildNode();
                  var token = this.nextJSXText();
                  if (token.start < token.end) {
                    var raw = this.getTokenRaw(token);
                    var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                    children.push(child);
                  }
                  if (this.scanner.source[this.scanner.index] === "{") {
                    var container = this.parseJSXExpressionContainer();
                    children.push(container);
                  } else {
                    break;
                  }
                }
                return children;
              };
              JSXParser2.prototype.parseComplexJSXElement = function(el) {
                var stack = [];
                while (!this.scanner.eof()) {
                  el.children = el.children.concat(this.parseJSXChildren());
                  var node = this.createJSXChildNode();
                  var element = this.parseJSXBoundaryElement();
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                    var opening = element;
                    if (opening.selfClosing) {
                      var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                      el.children.push(child);
                    } else {
                      stack.push(el);
                      el = { node, opening, closing: null, children: [] };
                    }
                  }
                  if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                    el.closing = element;
                    var open_1 = getQualifiedElementName(el.opening.name);
                    var close_1 = getQualifiedElementName(el.closing.name);
                    if (open_1 !== close_1) {
                      this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                    }
                    if (stack.length > 0) {
                      var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                      el = stack[stack.length - 1];
                      el.children.push(child);
                      stack.pop();
                    } else {
                      break;
                    }
                  }
                }
                return el;
              };
              JSXParser2.prototype.parseJSXElement = function() {
                var node = this.createJSXNode();
                var opening = this.parseJSXOpeningElement();
                var children = [];
                var closing = null;
                if (!opening.selfClosing) {
                  var el = this.parseComplexJSXElement({ node, opening, closing, children });
                  children = el.children;
                  closing = el.closing;
                }
                return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
              };
              JSXParser2.prototype.parseJSXRoot = function() {
                if (this.config.tokens) {
                  this.tokens.pop();
                }
                this.startJSX();
                var element = this.parseJSXElement();
                this.finishJSX();
                return element;
              };
              JSXParser2.prototype.isStartOfExpression = function() {
                return _super.prototype.isStartOfExpression.call(this) || this.match("<");
              };
              return JSXParser2;
            }(parser_1.Parser);
            exports3.JSXParser = JSXParser;
          },
          /* 4 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var Regex = {
              // Unicode v8.0.0 NonAsciiIdentifierStart:
              NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
              // Unicode v8.0.0 NonAsciiIdentifierPart:
              NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports3.Character = {
              /* tslint:disable:no-bitwise */
              fromCodePoint: function(cp) {
                return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
              },
              // https://tc39.github.io/ecma262/#sec-white-space
              isWhiteSpace: function(cp) {
                return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
              },
              // https://tc39.github.io/ecma262/#sec-line-terminators
              isLineTerminator: function(cp) {
                return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
              },
              // https://tc39.github.io/ecma262/#sec-names-and-keywords
              isIdentifierStart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
              },
              isIdentifierPart: function(cp) {
                return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
              },
              // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
              isDecimalDigit: function(cp) {
                return cp >= 48 && cp <= 57;
              },
              isHexDigit: function(cp) {
                return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
              },
              isOctalDigit: function(cp) {
                return cp >= 48 && cp <= 55;
              }
            };
          },
          /* 5 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var jsx_syntax_1 = __webpack_require__(6);
            var JSXClosingElement = /* @__PURE__ */ function() {
              function JSXClosingElement2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                this.name = name;
              }
              return JSXClosingElement2;
            }();
            exports3.JSXClosingElement = JSXClosingElement;
            var JSXElement = /* @__PURE__ */ function() {
              function JSXElement2(openingElement, children, closingElement) {
                this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                this.openingElement = openingElement;
                this.children = children;
                this.closingElement = closingElement;
              }
              return JSXElement2;
            }();
            exports3.JSXElement = JSXElement;
            var JSXEmptyExpression = /* @__PURE__ */ function() {
              function JSXEmptyExpression2() {
                this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
              }
              return JSXEmptyExpression2;
            }();
            exports3.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = /* @__PURE__ */ function() {
              function JSXExpressionContainer2(expression) {
                this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                this.expression = expression;
              }
              return JSXExpressionContainer2;
            }();
            exports3.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = /* @__PURE__ */ function() {
              function JSXIdentifier2(name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                this.name = name;
              }
              return JSXIdentifier2;
            }();
            exports3.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = /* @__PURE__ */ function() {
              function JSXMemberExpression2(object, property) {
                this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                this.object = object;
                this.property = property;
              }
              return JSXMemberExpression2;
            }();
            exports3.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = /* @__PURE__ */ function() {
              function JSXAttribute2(name, value) {
                this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                this.name = name;
                this.value = value;
              }
              return JSXAttribute2;
            }();
            exports3.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = /* @__PURE__ */ function() {
              function JSXNamespacedName2(namespace, name) {
                this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                this.namespace = namespace;
                this.name = name;
              }
              return JSXNamespacedName2;
            }();
            exports3.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = /* @__PURE__ */ function() {
              function JSXOpeningElement2(name, selfClosing, attributes) {
                this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                this.name = name;
                this.selfClosing = selfClosing;
                this.attributes = attributes;
              }
              return JSXOpeningElement2;
            }();
            exports3.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = /* @__PURE__ */ function() {
              function JSXSpreadAttribute2(argument) {
                this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                this.argument = argument;
              }
              return JSXSpreadAttribute2;
            }();
            exports3.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = /* @__PURE__ */ function() {
              function JSXText2(value, raw) {
                this.type = jsx_syntax_1.JSXSyntax.JSXText;
                this.value = value;
                this.raw = raw;
              }
              return JSXText2;
            }();
            exports3.JSXText = JSXText;
          },
          /* 6 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.JSXSyntax = {
              JSXAttribute: "JSXAttribute",
              JSXClosingElement: "JSXClosingElement",
              JSXElement: "JSXElement",
              JSXEmptyExpression: "JSXEmptyExpression",
              JSXExpressionContainer: "JSXExpressionContainer",
              JSXIdentifier: "JSXIdentifier",
              JSXMemberExpression: "JSXMemberExpression",
              JSXNamespacedName: "JSXNamespacedName",
              JSXOpeningElement: "JSXOpeningElement",
              JSXSpreadAttribute: "JSXSpreadAttribute",
              JSXText: "JSXText"
            };
          },
          /* 7 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var syntax_1 = __webpack_require__(2);
            var ArrayExpression = /* @__PURE__ */ function() {
              function ArrayExpression2(elements) {
                this.type = syntax_1.Syntax.ArrayExpression;
                this.elements = elements;
              }
              return ArrayExpression2;
            }();
            exports3.ArrayExpression = ArrayExpression;
            var ArrayPattern = /* @__PURE__ */ function() {
              function ArrayPattern2(elements) {
                this.type = syntax_1.Syntax.ArrayPattern;
                this.elements = elements;
              }
              return ArrayPattern2;
            }();
            exports3.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = /* @__PURE__ */ function() {
              function ArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = false;
              }
              return ArrowFunctionExpression2;
            }();
            exports3.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = /* @__PURE__ */ function() {
              function AssignmentExpression2(operator, left, right) {
                this.type = syntax_1.Syntax.AssignmentExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return AssignmentExpression2;
            }();
            exports3.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = /* @__PURE__ */ function() {
              function AssignmentPattern2(left, right) {
                this.type = syntax_1.Syntax.AssignmentPattern;
                this.left = left;
                this.right = right;
              }
              return AssignmentPattern2;
            }();
            exports3.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
              function AsyncArrowFunctionExpression2(params, body, expression) {
                this.type = syntax_1.Syntax.ArrowFunctionExpression;
                this.id = null;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = expression;
                this.async = true;
              }
              return AsyncArrowFunctionExpression2;
            }();
            exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
              function AsyncFunctionDeclaration2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionDeclaration2;
            }();
            exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = /* @__PURE__ */ function() {
              function AsyncFunctionExpression2(id, params, body) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = false;
                this.expression = false;
                this.async = true;
              }
              return AsyncFunctionExpression2;
            }();
            exports3.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = /* @__PURE__ */ function() {
              function AwaitExpression2(argument) {
                this.type = syntax_1.Syntax.AwaitExpression;
                this.argument = argument;
              }
              return AwaitExpression2;
            }();
            exports3.AwaitExpression = AwaitExpression;
            var BinaryExpression = /* @__PURE__ */ function() {
              function BinaryExpression2(operator, left, right) {
                var logical = operator === "||" || operator === "&&";
                this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                this.operator = operator;
                this.left = left;
                this.right = right;
              }
              return BinaryExpression2;
            }();
            exports3.BinaryExpression = BinaryExpression;
            var BlockStatement = /* @__PURE__ */ function() {
              function BlockStatement2(body) {
                this.type = syntax_1.Syntax.BlockStatement;
                this.body = body;
              }
              return BlockStatement2;
            }();
            exports3.BlockStatement = BlockStatement;
            var BreakStatement = /* @__PURE__ */ function() {
              function BreakStatement2(label) {
                this.type = syntax_1.Syntax.BreakStatement;
                this.label = label;
              }
              return BreakStatement2;
            }();
            exports3.BreakStatement = BreakStatement;
            var CallExpression = /* @__PURE__ */ function() {
              function CallExpression2(callee, args) {
                this.type = syntax_1.Syntax.CallExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return CallExpression2;
            }();
            exports3.CallExpression = CallExpression;
            var CatchClause = /* @__PURE__ */ function() {
              function CatchClause2(param, body) {
                this.type = syntax_1.Syntax.CatchClause;
                this.param = param;
                this.body = body;
              }
              return CatchClause2;
            }();
            exports3.CatchClause = CatchClause;
            var ClassBody = /* @__PURE__ */ function() {
              function ClassBody2(body) {
                this.type = syntax_1.Syntax.ClassBody;
                this.body = body;
              }
              return ClassBody2;
            }();
            exports3.ClassBody = ClassBody;
            var ClassDeclaration = /* @__PURE__ */ function() {
              function ClassDeclaration2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassDeclaration;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassDeclaration2;
            }();
            exports3.ClassDeclaration = ClassDeclaration;
            var ClassExpression = /* @__PURE__ */ function() {
              function ClassExpression2(id, superClass, body) {
                this.type = syntax_1.Syntax.ClassExpression;
                this.id = id;
                this.superClass = superClass;
                this.body = body;
              }
              return ClassExpression2;
            }();
            exports3.ClassExpression = ClassExpression;
            var ComputedMemberExpression = /* @__PURE__ */ function() {
              function ComputedMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = true;
                this.object = object;
                this.property = property;
              }
              return ComputedMemberExpression2;
            }();
            exports3.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = /* @__PURE__ */ function() {
              function ConditionalExpression2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.ConditionalExpression;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return ConditionalExpression2;
            }();
            exports3.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = /* @__PURE__ */ function() {
              function ContinueStatement2(label) {
                this.type = syntax_1.Syntax.ContinueStatement;
                this.label = label;
              }
              return ContinueStatement2;
            }();
            exports3.ContinueStatement = ContinueStatement;
            var DebuggerStatement = /* @__PURE__ */ function() {
              function DebuggerStatement2() {
                this.type = syntax_1.Syntax.DebuggerStatement;
              }
              return DebuggerStatement2;
            }();
            exports3.DebuggerStatement = DebuggerStatement;
            var Directive = /* @__PURE__ */ function() {
              function Directive2(expression, directive) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
                this.directive = directive;
              }
              return Directive2;
            }();
            exports3.Directive = Directive;
            var DoWhileStatement = /* @__PURE__ */ function() {
              function DoWhileStatement2(body, test) {
                this.type = syntax_1.Syntax.DoWhileStatement;
                this.body = body;
                this.test = test;
              }
              return DoWhileStatement2;
            }();
            exports3.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = /* @__PURE__ */ function() {
              function EmptyStatement2() {
                this.type = syntax_1.Syntax.EmptyStatement;
              }
              return EmptyStatement2;
            }();
            exports3.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = /* @__PURE__ */ function() {
              function ExportAllDeclaration2(source) {
                this.type = syntax_1.Syntax.ExportAllDeclaration;
                this.source = source;
              }
              return ExportAllDeclaration2;
            }();
            exports3.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = /* @__PURE__ */ function() {
              function ExportDefaultDeclaration2(declaration) {
                this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                this.declaration = declaration;
              }
              return ExportDefaultDeclaration2;
            }();
            exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = /* @__PURE__ */ function() {
              function ExportNamedDeclaration2(declaration, specifiers, source) {
                this.type = syntax_1.Syntax.ExportNamedDeclaration;
                this.declaration = declaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ExportNamedDeclaration2;
            }();
            exports3.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = /* @__PURE__ */ function() {
              function ExportSpecifier2(local, exported) {
                this.type = syntax_1.Syntax.ExportSpecifier;
                this.exported = exported;
                this.local = local;
              }
              return ExportSpecifier2;
            }();
            exports3.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = /* @__PURE__ */ function() {
              function ExpressionStatement2(expression) {
                this.type = syntax_1.Syntax.ExpressionStatement;
                this.expression = expression;
              }
              return ExpressionStatement2;
            }();
            exports3.ExpressionStatement = ExpressionStatement;
            var ForInStatement = /* @__PURE__ */ function() {
              function ForInStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForInStatement;
                this.left = left;
                this.right = right;
                this.body = body;
                this.each = false;
              }
              return ForInStatement2;
            }();
            exports3.ForInStatement = ForInStatement;
            var ForOfStatement = /* @__PURE__ */ function() {
              function ForOfStatement2(left, right, body) {
                this.type = syntax_1.Syntax.ForOfStatement;
                this.left = left;
                this.right = right;
                this.body = body;
              }
              return ForOfStatement2;
            }();
            exports3.ForOfStatement = ForOfStatement;
            var ForStatement = /* @__PURE__ */ function() {
              function ForStatement2(init, test, update, body) {
                this.type = syntax_1.Syntax.ForStatement;
                this.init = init;
                this.test = test;
                this.update = update;
                this.body = body;
              }
              return ForStatement2;
            }();
            exports3.ForStatement = ForStatement;
            var FunctionDeclaration = /* @__PURE__ */ function() {
              function FunctionDeclaration2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionDeclaration;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionDeclaration2;
            }();
            exports3.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = /* @__PURE__ */ function() {
              function FunctionExpression2(id, params, body, generator) {
                this.type = syntax_1.Syntax.FunctionExpression;
                this.id = id;
                this.params = params;
                this.body = body;
                this.generator = generator;
                this.expression = false;
                this.async = false;
              }
              return FunctionExpression2;
            }();
            exports3.FunctionExpression = FunctionExpression;
            var Identifier = /* @__PURE__ */ function() {
              function Identifier2(name) {
                this.type = syntax_1.Syntax.Identifier;
                this.name = name;
              }
              return Identifier2;
            }();
            exports3.Identifier = Identifier;
            var IfStatement = /* @__PURE__ */ function() {
              function IfStatement2(test, consequent, alternate) {
                this.type = syntax_1.Syntax.IfStatement;
                this.test = test;
                this.consequent = consequent;
                this.alternate = alternate;
              }
              return IfStatement2;
            }();
            exports3.IfStatement = IfStatement;
            var ImportDeclaration = /* @__PURE__ */ function() {
              function ImportDeclaration2(specifiers, source) {
                this.type = syntax_1.Syntax.ImportDeclaration;
                this.specifiers = specifiers;
                this.source = source;
              }
              return ImportDeclaration2;
            }();
            exports3.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = /* @__PURE__ */ function() {
              function ImportDefaultSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                this.local = local;
              }
              return ImportDefaultSpecifier2;
            }();
            exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
              function ImportNamespaceSpecifier2(local) {
                this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                this.local = local;
              }
              return ImportNamespaceSpecifier2;
            }();
            exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = /* @__PURE__ */ function() {
              function ImportSpecifier2(local, imported) {
                this.type = syntax_1.Syntax.ImportSpecifier;
                this.local = local;
                this.imported = imported;
              }
              return ImportSpecifier2;
            }();
            exports3.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = /* @__PURE__ */ function() {
              function LabeledStatement2(label, body) {
                this.type = syntax_1.Syntax.LabeledStatement;
                this.label = label;
                this.body = body;
              }
              return LabeledStatement2;
            }();
            exports3.LabeledStatement = LabeledStatement;
            var Literal = /* @__PURE__ */ function() {
              function Literal2(value, raw) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
              }
              return Literal2;
            }();
            exports3.Literal = Literal;
            var MetaProperty = /* @__PURE__ */ function() {
              function MetaProperty2(meta, property) {
                this.type = syntax_1.Syntax.MetaProperty;
                this.meta = meta;
                this.property = property;
              }
              return MetaProperty2;
            }();
            exports3.MetaProperty = MetaProperty;
            var MethodDefinition = /* @__PURE__ */ function() {
              function MethodDefinition2(key, computed, value, kind, isStatic) {
                this.type = syntax_1.Syntax.MethodDefinition;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.static = isStatic;
              }
              return MethodDefinition2;
            }();
            exports3.MethodDefinition = MethodDefinition;
            var Module = /* @__PURE__ */ function() {
              function Module2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "module";
              }
              return Module2;
            }();
            exports3.Module = Module;
            var NewExpression = /* @__PURE__ */ function() {
              function NewExpression2(callee, args) {
                this.type = syntax_1.Syntax.NewExpression;
                this.callee = callee;
                this.arguments = args;
              }
              return NewExpression2;
            }();
            exports3.NewExpression = NewExpression;
            var ObjectExpression = /* @__PURE__ */ function() {
              function ObjectExpression2(properties) {
                this.type = syntax_1.Syntax.ObjectExpression;
                this.properties = properties;
              }
              return ObjectExpression2;
            }();
            exports3.ObjectExpression = ObjectExpression;
            var ObjectPattern = /* @__PURE__ */ function() {
              function ObjectPattern2(properties) {
                this.type = syntax_1.Syntax.ObjectPattern;
                this.properties = properties;
              }
              return ObjectPattern2;
            }();
            exports3.ObjectPattern = ObjectPattern;
            var Property = /* @__PURE__ */ function() {
              function Property2(kind, key, computed, value, method, shorthand) {
                this.type = syntax_1.Syntax.Property;
                this.key = key;
                this.computed = computed;
                this.value = value;
                this.kind = kind;
                this.method = method;
                this.shorthand = shorthand;
              }
              return Property2;
            }();
            exports3.Property = Property;
            var RegexLiteral = /* @__PURE__ */ function() {
              function RegexLiteral2(value, raw, pattern, flags) {
                this.type = syntax_1.Syntax.Literal;
                this.value = value;
                this.raw = raw;
                this.regex = { pattern, flags };
              }
              return RegexLiteral2;
            }();
            exports3.RegexLiteral = RegexLiteral;
            var RestElement = /* @__PURE__ */ function() {
              function RestElement2(argument) {
                this.type = syntax_1.Syntax.RestElement;
                this.argument = argument;
              }
              return RestElement2;
            }();
            exports3.RestElement = RestElement;
            var ReturnStatement = /* @__PURE__ */ function() {
              function ReturnStatement2(argument) {
                this.type = syntax_1.Syntax.ReturnStatement;
                this.argument = argument;
              }
              return ReturnStatement2;
            }();
            exports3.ReturnStatement = ReturnStatement;
            var Script = /* @__PURE__ */ function() {
              function Script2(body) {
                this.type = syntax_1.Syntax.Program;
                this.body = body;
                this.sourceType = "script";
              }
              return Script2;
            }();
            exports3.Script = Script;
            var SequenceExpression = /* @__PURE__ */ function() {
              function SequenceExpression2(expressions) {
                this.type = syntax_1.Syntax.SequenceExpression;
                this.expressions = expressions;
              }
              return SequenceExpression2;
            }();
            exports3.SequenceExpression = SequenceExpression;
            var SpreadElement = /* @__PURE__ */ function() {
              function SpreadElement2(argument) {
                this.type = syntax_1.Syntax.SpreadElement;
                this.argument = argument;
              }
              return SpreadElement2;
            }();
            exports3.SpreadElement = SpreadElement;
            var StaticMemberExpression = /* @__PURE__ */ function() {
              function StaticMemberExpression2(object, property) {
                this.type = syntax_1.Syntax.MemberExpression;
                this.computed = false;
                this.object = object;
                this.property = property;
              }
              return StaticMemberExpression2;
            }();
            exports3.StaticMemberExpression = StaticMemberExpression;
            var Super = /* @__PURE__ */ function() {
              function Super2() {
                this.type = syntax_1.Syntax.Super;
              }
              return Super2;
            }();
            exports3.Super = Super;
            var SwitchCase = /* @__PURE__ */ function() {
              function SwitchCase2(test, consequent) {
                this.type = syntax_1.Syntax.SwitchCase;
                this.test = test;
                this.consequent = consequent;
              }
              return SwitchCase2;
            }();
            exports3.SwitchCase = SwitchCase;
            var SwitchStatement = /* @__PURE__ */ function() {
              function SwitchStatement2(discriminant, cases) {
                this.type = syntax_1.Syntax.SwitchStatement;
                this.discriminant = discriminant;
                this.cases = cases;
              }
              return SwitchStatement2;
            }();
            exports3.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = /* @__PURE__ */ function() {
              function TaggedTemplateExpression2(tag, quasi) {
                this.type = syntax_1.Syntax.TaggedTemplateExpression;
                this.tag = tag;
                this.quasi = quasi;
              }
              return TaggedTemplateExpression2;
            }();
            exports3.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = /* @__PURE__ */ function() {
              function TemplateElement2(value, tail) {
                this.type = syntax_1.Syntax.TemplateElement;
                this.value = value;
                this.tail = tail;
              }
              return TemplateElement2;
            }();
            exports3.TemplateElement = TemplateElement;
            var TemplateLiteral = /* @__PURE__ */ function() {
              function TemplateLiteral2(quasis, expressions) {
                this.type = syntax_1.Syntax.TemplateLiteral;
                this.quasis = quasis;
                this.expressions = expressions;
              }
              return TemplateLiteral2;
            }();
            exports3.TemplateLiteral = TemplateLiteral;
            var ThisExpression = /* @__PURE__ */ function() {
              function ThisExpression2() {
                this.type = syntax_1.Syntax.ThisExpression;
              }
              return ThisExpression2;
            }();
            exports3.ThisExpression = ThisExpression;
            var ThrowStatement = /* @__PURE__ */ function() {
              function ThrowStatement2(argument) {
                this.type = syntax_1.Syntax.ThrowStatement;
                this.argument = argument;
              }
              return ThrowStatement2;
            }();
            exports3.ThrowStatement = ThrowStatement;
            var TryStatement = /* @__PURE__ */ function() {
              function TryStatement2(block, handler, finalizer) {
                this.type = syntax_1.Syntax.TryStatement;
                this.block = block;
                this.handler = handler;
                this.finalizer = finalizer;
              }
              return TryStatement2;
            }();
            exports3.TryStatement = TryStatement;
            var UnaryExpression = /* @__PURE__ */ function() {
              function UnaryExpression2(operator, argument) {
                this.type = syntax_1.Syntax.UnaryExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = true;
              }
              return UnaryExpression2;
            }();
            exports3.UnaryExpression = UnaryExpression;
            var UpdateExpression = /* @__PURE__ */ function() {
              function UpdateExpression2(operator, argument, prefix) {
                this.type = syntax_1.Syntax.UpdateExpression;
                this.operator = operator;
                this.argument = argument;
                this.prefix = prefix;
              }
              return UpdateExpression2;
            }();
            exports3.UpdateExpression = UpdateExpression;
            var VariableDeclaration = /* @__PURE__ */ function() {
              function VariableDeclaration2(declarations, kind) {
                this.type = syntax_1.Syntax.VariableDeclaration;
                this.declarations = declarations;
                this.kind = kind;
              }
              return VariableDeclaration2;
            }();
            exports3.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = /* @__PURE__ */ function() {
              function VariableDeclarator2(id, init) {
                this.type = syntax_1.Syntax.VariableDeclarator;
                this.id = id;
                this.init = init;
              }
              return VariableDeclarator2;
            }();
            exports3.VariableDeclarator = VariableDeclarator;
            var WhileStatement = /* @__PURE__ */ function() {
              function WhileStatement2(test, body) {
                this.type = syntax_1.Syntax.WhileStatement;
                this.test = test;
                this.body = body;
              }
              return WhileStatement2;
            }();
            exports3.WhileStatement = WhileStatement;
            var WithStatement = /* @__PURE__ */ function() {
              function WithStatement2(object, body) {
                this.type = syntax_1.Syntax.WithStatement;
                this.object = object;
                this.body = body;
              }
              return WithStatement2;
            }();
            exports3.WithStatement = WithStatement;
            var YieldExpression = /* @__PURE__ */ function() {
              function YieldExpression2(argument, delegate) {
                this.type = syntax_1.Syntax.YieldExpression;
                this.argument = argument;
                this.delegate = delegate;
              }
              return YieldExpression2;
            }();
            exports3.YieldExpression = YieldExpression;
          },
          /* 8 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var error_handler_1 = __webpack_require__(10);
            var messages_1 = __webpack_require__(11);
            var Node = __webpack_require__(7);
            var scanner_1 = __webpack_require__(12);
            var syntax_1 = __webpack_require__(2);
            var token_1 = __webpack_require__(13);
            var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
            var Parser = function() {
              function Parser2(code, options, delegate) {
                if (options === void 0) {
                  options = {};
                }
                this.config = {
                  range: typeof options.range === "boolean" && options.range,
                  loc: typeof options.loc === "boolean" && options.loc,
                  source: null,
                  tokens: typeof options.tokens === "boolean" && options.tokens,
                  comment: typeof options.comment === "boolean" && options.comment,
                  tolerant: typeof options.tolerant === "boolean" && options.tolerant
                };
                if (this.config.loc && options.source && options.source !== null) {
                  this.config.source = String(options.source);
                }
                this.delegate = delegate;
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = this.config.tolerant;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = this.config.comment;
                this.operatorPrecedence = {
                  ")": 0,
                  ";": 0,
                  ",": 0,
                  "=": 0,
                  "]": 0,
                  "||": 1,
                  "&&": 2,
                  "|": 3,
                  "^": 4,
                  "&": 5,
                  "==": 6,
                  "!=": 6,
                  "===": 6,
                  "!==": 6,
                  "<": 7,
                  ">": 7,
                  "<=": 7,
                  ">=": 7,
                  "<<": 8,
                  ">>": 8,
                  ">>>": 8,
                  "+": 9,
                  "-": 9,
                  "*": 11,
                  "/": 11,
                  "%": 11
                };
                this.lookahead = {
                  type: 2,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: 0,
                  start: 0,
                  end: 0
                };
                this.hasLineTerminator = false;
                this.context = {
                  isModule: false,
                  await: false,
                  allowIn: true,
                  allowStrictDirective: true,
                  allowYield: true,
                  firstCoverInitializedNameError: null,
                  isAssignmentTarget: false,
                  isBindingElement: false,
                  inFunctionBody: false,
                  inIteration: false,
                  inSwitch: false,
                  labelSet: {},
                  strict: false
                };
                this.tokens = [];
                this.startMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.lastMarker = {
                  index: 0,
                  line: this.scanner.lineNumber,
                  column: 0
                };
                this.nextToken();
                this.lastMarker = {
                  index: this.scanner.index,
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                };
              }
              Parser2.prototype.throwError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
                  assert_1.assert(idx2 < args.length, "Message reference must be in range");
                  return args[idx2];
                });
                var index = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                throw this.errorHandler.createError(index, line, column, msg);
              };
              Parser2.prototype.tolerateError = function(messageFormat) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
                  assert_1.assert(idx2 < args.length, "Message reference must be in range");
                  return args[idx2];
                });
                var index = this.lastMarker.index;
                var line = this.scanner.lineNumber;
                var column = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(index, line, column, msg);
              };
              Parser2.prototype.unexpectedTokenError = function(token, message) {
                var msg = message || messages_1.Messages.UnexpectedToken;
                var value;
                if (token) {
                  if (!message) {
                    msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                    if (token.type === 4) {
                      if (this.scanner.isFutureReservedWord(token.value)) {
                        msg = messages_1.Messages.UnexpectedReserved;
                      } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                        msg = messages_1.Messages.StrictReservedWord;
                      }
                    }
                  }
                  value = token.value;
                } else {
                  value = "ILLEGAL";
                }
                msg = msg.replace("%0", value);
                if (token && typeof token.lineNumber === "number") {
                  var index = token.start;
                  var line = token.lineNumber;
                  var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                  var column = token.start - lastMarkerLineStart + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                } else {
                  var index = this.lastMarker.index;
                  var line = this.lastMarker.line;
                  var column = this.lastMarker.column + 1;
                  return this.errorHandler.createError(index, line, column, msg);
                }
              };
              Parser2.prototype.throwUnexpectedToken = function(token, message) {
                throw this.unexpectedTokenError(token, message);
              };
              Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
                this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
              };
              Parser2.prototype.collectComments = function() {
                if (!this.config.comment) {
                  this.scanner.scanComments();
                } else {
                  var comments = this.scanner.scanComments();
                  if (comments.length > 0 && this.delegate) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var node = void 0;
                      node = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
                      };
                      if (this.config.range) {
                        node.range = e.range;
                      }
                      if (this.config.loc) {
                        node.loc = e.loc;
                      }
                      var metadata = {
                        start: {
                          line: e.loc.start.line,
                          column: e.loc.start.column,
                          offset: e.range[0]
                        },
                        end: {
                          line: e.loc.end.line,
                          column: e.loc.end.column,
                          offset: e.range[1]
                        }
                      };
                      this.delegate(node, metadata);
                    }
                  }
                }
              };
              Parser2.prototype.getTokenRaw = function(token) {
                return this.scanner.source.slice(token.start, token.end);
              };
              Parser2.prototype.convertToken = function(token) {
                var t = {
                  type: token_1.TokenName[token.type],
                  value: this.getTokenRaw(token)
                };
                if (this.config.range) {
                  t.range = [token.start, token.end];
                }
                if (this.config.loc) {
                  t.loc = {
                    start: {
                      line: this.startMarker.line,
                      column: this.startMarker.column
                    },
                    end: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    }
                  };
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  t.regex = { pattern, flags };
                }
                return t;
              };
              Parser2.prototype.nextToken = function() {
                var token = this.lookahead;
                this.lastMarker.index = this.scanner.index;
                this.lastMarker.line = this.scanner.lineNumber;
                this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                this.collectComments();
                if (this.scanner.index !== this.startMarker.index) {
                  this.startMarker.index = this.scanner.index;
                  this.startMarker.line = this.scanner.lineNumber;
                  this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                }
                var next = this.scanner.lex();
                this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                if (next && this.context.strict && next.type === 3) {
                  if (this.scanner.isStrictModeReservedWord(next.value)) {
                    next.type = 4;
                  }
                }
                this.lookahead = next;
                if (this.config.tokens && next.type !== 2) {
                  this.tokens.push(this.convertToken(next));
                }
                return token;
              };
              Parser2.prototype.nextRegexToken = function() {
                this.collectComments();
                var token = this.scanner.scanRegExp();
                if (this.config.tokens) {
                  this.tokens.pop();
                  this.tokens.push(this.convertToken(token));
                }
                this.lookahead = token;
                this.nextToken();
                return token;
              };
              Parser2.prototype.createNode = function() {
                return {
                  index: this.startMarker.index,
                  line: this.startMarker.line,
                  column: this.startMarker.column
                };
              };
              Parser2.prototype.startNode = function(token, lastLineStart) {
                if (lastLineStart === void 0) {
                  lastLineStart = 0;
                }
                var column = token.start - token.lineStart;
                var line = token.lineNumber;
                if (column < 0) {
                  column += lastLineStart;
                  line--;
                }
                return {
                  index: token.start,
                  line,
                  column
                };
              };
              Parser2.prototype.finalize = function(marker, node) {
                if (this.config.range) {
                  node.range = [marker.index, this.lastMarker.index];
                }
                if (this.config.loc) {
                  node.loc = {
                    start: {
                      line: marker.line,
                      column: marker.column
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column
                    }
                  };
                  if (this.config.source) {
                    node.loc.source = this.config.source;
                  }
                }
                if (this.delegate) {
                  var metadata = {
                    start: {
                      line: marker.line,
                      column: marker.column,
                      offset: marker.index
                    },
                    end: {
                      line: this.lastMarker.line,
                      column: this.lastMarker.column,
                      offset: this.lastMarker.index
                    }
                  };
                  this.delegate(node, metadata);
                }
                return node;
              };
              Parser2.prototype.expect = function(value) {
                var token = this.nextToken();
                if (token.type !== 7 || token.value !== value) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var token = this.lookahead;
                  if (token.type === 7 && token.value === ",") {
                    this.nextToken();
                  } else if (token.type === 7 && token.value === ";") {
                    this.nextToken();
                    this.tolerateUnexpectedToken(token);
                  } else {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                  }
                } else {
                  this.expect(",");
                }
              };
              Parser2.prototype.expectKeyword = function(keyword) {
                var token = this.nextToken();
                if (token.type !== 4 || token.value !== keyword) {
                  this.throwUnexpectedToken(token);
                }
              };
              Parser2.prototype.match = function(value) {
                return this.lookahead.type === 7 && this.lookahead.value === value;
              };
              Parser2.prototype.matchKeyword = function(keyword) {
                return this.lookahead.type === 4 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchContextualKeyword = function(keyword) {
                return this.lookahead.type === 3 && this.lookahead.value === keyword;
              };
              Parser2.prototype.matchAssign = function() {
                if (this.lookahead.type !== 7) {
                  return false;
                }
                var op = this.lookahead.value;
                return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
              };
              Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                if (this.context.firstCoverInitializedNameError !== null) {
                  this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                }
                this.context.isBindingElement = previousIsBindingElement;
                this.context.isAssignmentTarget = previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
                var previousIsBindingElement = this.context.isBindingElement;
                var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true;
                this.context.isAssignmentTarget = true;
                this.context.firstCoverInitializedNameError = null;
                var result = parseFunction.call(this);
                this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                return result;
              };
              Parser2.prototype.consumeSemicolon = function() {
                if (this.match(";")) {
                  this.nextToken();
                } else if (!this.hasLineTerminator) {
                  if (this.lookahead.type !== 2 && !this.match("}")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.lastMarker.index = this.startMarker.index;
                  this.lastMarker.line = this.startMarker.line;
                  this.lastMarker.column = this.startMarker.column;
                }
              };
              Parser2.prototype.parsePrimaryExpression = function() {
                var node = this.createNode();
                var expr;
                var token, raw;
                switch (this.lookahead.type) {
                  case 3:
                    if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    if (this.context.strict && this.lookahead.octal) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    token = this.nextToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.Literal(null, raw));
                    break;
                  case 10:
                    expr = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = false;
                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        this.scanner.index = this.startMarker.index;
                        token = this.nextRegexToken();
                        raw = this.getTokenRaw(token);
                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                        break;
                      default:
                        expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                      expr = this.parseIdentifierName();
                    } else if (!this.context.strict && this.matchKeyword("let")) {
                      expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                    } else {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      if (this.matchKeyword("function")) {
                        expr = this.parseFunctionExpression();
                      } else if (this.matchKeyword("this")) {
                        this.nextToken();
                        expr = this.finalize(node, new Node.ThisExpression());
                      } else if (this.matchKeyword("class")) {
                        expr = this.parseClassExpression();
                      } else {
                        expr = this.throwUnexpectedToken(this.nextToken());
                      }
                    }
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                return expr;
              };
              Parser2.prototype.parseSpreadElement = function() {
                var node = this.createNode();
                this.expect("...");
                var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(node, new Node.SpreadElement(arg));
              };
              Parser2.prototype.parseArrayInitializer = function() {
                var node = this.createNode();
                var elements = [];
                this.expect("[");
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else if (this.match("...")) {
                    var element = this.parseSpreadElement();
                    if (!this.match("]")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.expect(",");
                    }
                    elements.push(element);
                  } else {
                    elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayExpression(elements));
              };
              Parser2.prototype.parsePropertyMethod = function(params) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = params.simple;
                var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                if (this.context.strict && params.firstRestricted) {
                  this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                }
                if (this.context.strict && params.stricted) {
                  this.tolerateUnexpectedToken(params.stricted, params.message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                return body;
              };
              Parser2.prototype.parsePropertyMethodFunction = function() {
                var isGenerator = false;
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
                var node = this.createNode();
                var previousAllowYield = this.context.allowYield;
                var previousAwait = this.context.await;
                this.context.allowYield = false;
                this.context.await = true;
                var params = this.parseFormalParameters();
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                this.context.await = previousAwait;
                return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
              };
              Parser2.prototype.parseObjectPropertyKey = function() {
                var node = this.createNode();
                var token = this.nextToken();
                var key;
                switch (token.type) {
                  case 8:
                  case 6:
                    if (this.context.strict && token.octal) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                    }
                    var raw = this.getTokenRaw(token);
                    key = this.finalize(node, new Node.Literal(token.value, raw));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    key = this.finalize(node, new Node.Identifier(token.value));
                    break;
                  case 7:
                    if (token.value === "[") {
                      key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      this.expect("]");
                    } else {
                      key = this.throwUnexpectedToken(token);
                    }
                    break;
                  default:
                    key = this.throwUnexpectedToken(token);
                }
                return key;
              };
              Parser2.prototype.isPropertyKey = function(key, value) {
                return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
              };
              Parser2.prototype.parseObjectProperty = function(hasProto) {
                var node = this.createNode();
                var token = this.lookahead;
                var kind;
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var shorthand = false;
                var isAsync = false;
                if (token.type === 3) {
                  var id = token.value;
                  this.nextToken();
                  computed = this.match("[");
                  isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                  key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                } else if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                } else {
                  if (!key) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  kind = "init";
                  if (this.match(":") && !isAsync) {
                    if (!computed && this.isPropertyKey(key, "__proto__")) {
                      if (hasProto.value) {
                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                      }
                      hasProto.value = true;
                    }
                    this.nextToken();
                    value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  } else if (this.match("(")) {
                    value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                    method = true;
                  } else if (token.type === 3) {
                    var id = this.finalize(node, new Node.Identifier(token.value));
                    if (this.match("=")) {
                      this.context.firstCoverInitializedNameError = this.lookahead;
                      this.nextToken();
                      shorthand = true;
                      var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      value = this.finalize(node, new Node.AssignmentPattern(id, init));
                    } else {
                      shorthand = true;
                      value = id;
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectInitializer = function() {
                var node = this.createNode();
                this.expect("{");
                var properties = [];
                var hasProto = { value: false };
                while (!this.match("}")) {
                  properties.push(this.parseObjectProperty(hasProto));
                  if (!this.match("}")) {
                    this.expectCommaSeparator();
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectExpression(properties));
              };
              Parser2.prototype.parseTemplateHead = function() {
                assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateElement = function() {
                if (this.lookahead.type !== 10) {
                  this.throwUnexpectedToken();
                }
                var node = this.createNode();
                var token = this.nextToken();
                var raw = token.value;
                var cooked = token.cooked;
                return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
              };
              Parser2.prototype.parseTemplateLiteral = function() {
                var node = this.createNode();
                var expressions = [];
                var quasis = [];
                var quasi = this.parseTemplateHead();
                quasis.push(quasi);
                while (!quasi.tail) {
                  expressions.push(this.parseExpression());
                  quasi = this.parseTemplateElement();
                  quasis.push(quasi);
                }
                return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
              };
              Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                  case syntax_1.Syntax.MemberExpression:
                  case syntax_1.Syntax.RestElement:
                  case syntax_1.Syntax.AssignmentPattern:
                    break;
                  case syntax_1.Syntax.SpreadElement:
                    expr.type = syntax_1.Syntax.RestElement;
                    this.reinterpretExpressionAsPattern(expr.argument);
                    break;
                  case syntax_1.Syntax.ArrayExpression:
                    expr.type = syntax_1.Syntax.ArrayPattern;
                    for (var i = 0; i < expr.elements.length; i++) {
                      if (expr.elements[i] !== null) {
                        this.reinterpretExpressionAsPattern(expr.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectExpression:
                    expr.type = syntax_1.Syntax.ObjectPattern;
                    for (var i = 0; i < expr.properties.length; i++) {
                      this.reinterpretExpressionAsPattern(expr.properties[i].value);
                    }
                    break;
                  case syntax_1.Syntax.AssignmentExpression:
                    expr.type = syntax_1.Syntax.AssignmentPattern;
                    delete expr.operator;
                    this.reinterpretExpressionAsPattern(expr.left);
                    break;
                  default:
                    break;
                }
              };
              Parser2.prototype.parseGroupExpression = function() {
                var expr;
                this.expect("(");
                if (this.match(")")) {
                  this.nextToken();
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [],
                    async: false
                  };
                } else {
                  var startToken = this.lookahead;
                  var params = [];
                  if (this.match("...")) {
                    expr = this.parseRestElement(params);
                    this.expect(")");
                    if (!this.match("=>")) {
                      this.expect("=>");
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [expr],
                      async: false
                    };
                  } else {
                    var arrow = false;
                    this.context.isBindingElement = true;
                    expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                      var expressions = [];
                      this.context.isAssignmentTarget = false;
                      expressions.push(expr);
                      while (this.lookahead.type !== 2) {
                        if (!this.match(",")) {
                          break;
                        }
                        this.nextToken();
                        if (this.match(")")) {
                          this.nextToken();
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else if (this.match("...")) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          expressions.push(this.parseRestElement(params));
                          this.expect(")");
                          if (!this.match("=>")) {
                            this.expect("=>");
                          }
                          this.context.isBindingElement = false;
                          for (var i = 0; i < expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expressions[i]);
                          }
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: expressions,
                            async: false
                          };
                        } else {
                          expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        }
                        if (arrow) {
                          break;
                        }
                      }
                      if (!arrow) {
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                      }
                    }
                    if (!arrow) {
                      this.expect(")");
                      if (this.match("=>")) {
                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                          arrow = true;
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [expr],
                            async: false
                          };
                        }
                        if (!arrow) {
                          if (!this.context.isBindingElement) {
                            this.throwUnexpectedToken(this.lookahead);
                          }
                          if (expr.type === syntax_1.Syntax.SequenceExpression) {
                            for (var i = 0; i < expr.expressions.length; i++) {
                              this.reinterpretExpressionAsPattern(expr.expressions[i]);
                            }
                          } else {
                            this.reinterpretExpressionAsPattern(expr);
                          }
                          var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                          expr = {
                            type: ArrowParameterPlaceHolder,
                            params: parameters,
                            async: false
                          };
                        }
                      }
                      this.context.isBindingElement = false;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.isIdentifierName = function(token) {
                return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
              };
              Parser2.prototype.parseIdentifierName = function() {
                var node = this.createNode();
                var token = this.nextToken();
                if (!this.isIdentifierName(token)) {
                  this.throwUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseNewExpression = function() {
                var node = this.createNode();
                var id = this.parseIdentifierName();
                assert_1.assert(id.name === "new", "New expression must start with `new`");
                var expr;
                if (this.match(".")) {
                  this.nextToken();
                  if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                    var property = this.parseIdentifierName();
                    expr = new Node.MetaProperty(id, property);
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                  var args = this.match("(") ? this.parseArguments() : [];
                  expr = new Node.NewExpression(callee, args);
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return this.finalize(node, expr);
              };
              Parser2.prototype.parseAsyncArgument = function() {
                var arg = this.parseAssignmentExpression();
                this.context.firstCoverInitializedNameError = null;
                return arg;
              };
              Parser2.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var args = [];
                if (!this.match(")")) {
                  while (true) {
                    var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    args.push(expr);
                    if (this.match(")")) {
                      break;
                    }
                    this.expectCommaSeparator();
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return args;
              };
              Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var startToken = this.lookahead;
                var maybeAsync = this.matchContextualKeyword("async");
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var expr;
                if (this.matchKeyword("super") && this.context.inFunctionBody) {
                  expr = this.createNode();
                  this.nextToken();
                  expr = this.finalize(expr, new Node.Super());
                  if (!this.match("(") && !this.match(".") && !this.match("[")) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                } else {
                  expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                }
                while (true) {
                  if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                  } else if (this.match("(")) {
                    var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = false;
                    var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                    expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                    if (asyncArrow && this.match("=>")) {
                      for (var i = 0; i < args.length; ++i) {
                        this.reinterpretExpressionAsPattern(args[i]);
                      }
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: args,
                        async: true
                      };
                    }
                  } else if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                this.context.allowIn = previousAllowIn;
                return expr;
              };
              Parser2.prototype.parseSuper = function() {
                var node = this.createNode();
                this.expectKeyword("super");
                if (!this.match("[") && !this.match(".")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                return this.finalize(node, new Node.Super());
              };
              Parser2.prototype.parseLeftHandSideExpression = function() {
                assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                var node = this.startNode(this.lookahead);
                var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                while (true) {
                  if (this.match("[")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect("[");
                    var property = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]");
                    expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                  } else if (this.match(".")) {
                    this.context.isBindingElement = false;
                    this.context.isAssignmentTarget = true;
                    this.expect(".");
                    var property = this.parseIdentifierName();
                    expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                  } else if (this.lookahead.type === 10 && this.lookahead.head) {
                    var quasi = this.parseTemplateLiteral();
                    expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                  } else {
                    break;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseUpdateExpression = function() {
                var expr;
                var startToken = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var node = this.startNode(startToken);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  var prefix = true;
                  expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else {
                  expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                  if (!this.hasLineTerminator && this.lookahead.type === 7) {
                    if (this.match("++") || this.match("--")) {
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                      }
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      var operator = this.nextToken().value;
                      var prefix = false;
                      expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseAwaitExpression = function() {
                var node = this.createNode();
                this.nextToken();
                var argument = this.parseUnaryExpression();
                return this.finalize(node, new Node.AwaitExpression(argument));
              };
              Parser2.prototype.parseUnaryExpression = function() {
                var expr;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var node = this.startNode(this.lookahead);
                  var token = this.nextToken();
                  expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                  expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                  if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                    this.tolerateError(messages_1.Messages.StrictDelete);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                } else if (this.context.await && this.matchContextualKeyword("await")) {
                  expr = this.parseAwaitExpression();
                } else {
                  expr = this.parseUpdateExpression();
                }
                return expr;
              };
              Parser2.prototype.parseExponentiationExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                }
                return expr;
              };
              Parser2.prototype.binaryPrecedence = function(token) {
                var op = token.value;
                var precedence;
                if (token.type === 7) {
                  precedence = this.operatorPrecedence[op] || 0;
                } else if (token.type === 4) {
                  precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                } else {
                  precedence = 0;
                }
                return precedence;
              };
              Parser2.prototype.parseBinaryExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                var token = this.lookahead;
                var prec = this.binaryPrecedence(token);
                if (prec > 0) {
                  this.nextToken();
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var markers = [startToken, this.lookahead];
                  var left = expr;
                  var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  var stack = [left, token.value, right];
                  var precedences = [prec];
                  while (true) {
                    prec = this.binaryPrecedence(this.lookahead);
                    if (prec <= 0) {
                      break;
                    }
                    while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                      right = stack.pop();
                      var operator = stack.pop();
                      precedences.pop();
                      left = stack.pop();
                      markers.pop();
                      var node = this.startNode(markers[markers.length - 1]);
                      stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                    }
                    stack.push(this.nextToken().value);
                    precedences.push(prec);
                    markers.push(this.lookahead);
                    stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var i = stack.length - 1;
                  expr = stack[i];
                  var lastMarker = markers.pop();
                  while (i > 1) {
                    var marker = markers.pop();
                    var lastLineStart = lastMarker && lastMarker.lineStart;
                    var node = this.startNode(marker, lastLineStart);
                    var operator = stack[i - 1];
                    expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                    i -= 2;
                    lastMarker = marker;
                  }
                }
                return expr;
              };
              Parser2.prototype.parseConditionalExpression = function() {
                var startToken = this.lookahead;
                var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = true;
                  var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  this.expect(":");
                  var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                }
                return expr;
              };
              Parser2.prototype.checkPatternParam = function(options, param) {
                switch (param.type) {
                  case syntax_1.Syntax.Identifier:
                    this.validateParam(options, param, param.name);
                    break;
                  case syntax_1.Syntax.RestElement:
                    this.checkPatternParam(options, param.argument);
                    break;
                  case syntax_1.Syntax.AssignmentPattern:
                    this.checkPatternParam(options, param.left);
                    break;
                  case syntax_1.Syntax.ArrayPattern:
                    for (var i = 0; i < param.elements.length; i++) {
                      if (param.elements[i] !== null) {
                        this.checkPatternParam(options, param.elements[i]);
                      }
                    }
                    break;
                  case syntax_1.Syntax.ObjectPattern:
                    for (var i = 0; i < param.properties.length; i++) {
                      this.checkPatternParam(options, param.properties[i].value);
                    }
                    break;
                  default:
                    break;
                }
                options.simple = options.simple && param instanceof Node.Identifier;
              };
              Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
                var params = [expr];
                var options;
                var asyncArrow = false;
                switch (expr.type) {
                  case syntax_1.Syntax.Identifier:
                    break;
                  case ArrowParameterPlaceHolder:
                    params = expr.params;
                    asyncArrow = expr.async;
                    break;
                  default:
                    return null;
                }
                options = {
                  simple: true,
                  paramSet: {}
                };
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  if (param.type === syntax_1.Syntax.AssignmentPattern) {
                    if (param.right.type === syntax_1.Syntax.YieldExpression) {
                      if (param.right.argument) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      param.right.type = syntax_1.Syntax.Identifier;
                      param.right.name = "yield";
                      delete param.right.argument;
                      delete param.right.delegate;
                    }
                  } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  this.checkPatternParam(options, param);
                  params[i] = param;
                }
                if (this.context.strict || !this.context.allowYield) {
                  for (var i = 0; i < params.length; ++i) {
                    var param = params[i];
                    if (param.type === syntax_1.Syntax.YieldExpression) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                }
                if (options.message === messages_1.Messages.StrictParamDupe) {
                  var token = this.context.strict ? options.stricted : options.firstRestricted;
                  this.throwUnexpectedToken(token, options.message);
                }
                return {
                  simple: options.simple,
                  params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.parseAssignmentExpression = function() {
                var expr;
                if (!this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseYieldExpression();
                } else {
                  var startToken = this.lookahead;
                  var token = startToken;
                  expr = this.parseConditionalExpression();
                  if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                    if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                      var arg = this.parsePrimaryExpression();
                      this.reinterpretExpressionAsPattern(arg);
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [arg],
                        async: true
                      };
                    }
                  }
                  if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var isAsync = expr.async;
                    var list = this.reinterpretAsCoverFormalsList(expr);
                    if (list) {
                      if (this.hasLineTerminator) {
                        this.tolerateUnexpectedToken(this.lookahead);
                      }
                      this.context.firstCoverInitializedNameError = null;
                      var previousStrict = this.context.strict;
                      var previousAllowStrictDirective = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = list.simple;
                      var previousAllowYield = this.context.allowYield;
                      var previousAwait = this.context.await;
                      this.context.allowYield = true;
                      this.context.await = isAsync;
                      var node = this.startNode(startToken);
                      this.expect("=>");
                      var body = void 0;
                      if (this.match("{")) {
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        body = this.parseFunctionSourceElements();
                        this.context.allowIn = previousAllowIn;
                      } else {
                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      }
                      var expression = body.type !== syntax_1.Syntax.BlockStatement;
                      if (this.context.strict && list.firstRestricted) {
                        this.throwUnexpectedToken(list.firstRestricted, list.message);
                      }
                      if (this.context.strict && list.stricted) {
                        this.tolerateUnexpectedToken(list.stricted, list.message);
                      }
                      expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                      this.context.strict = previousStrict;
                      this.context.allowStrictDirective = previousAllowStrictDirective;
                      this.context.allowYield = previousAllowYield;
                      this.context.await = previousAwait;
                    }
                  } else {
                    if (this.matchAssign()) {
                      if (!this.context.isAssignmentTarget) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                      }
                      if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                        var id = expr;
                        if (this.scanner.isRestrictedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                        }
                        if (this.scanner.isStrictModeReservedWord(id.name)) {
                          this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        }
                      }
                      if (!this.match("=")) {
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      token = this.nextToken();
                      var operator = token.value;
                      var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                      this.context.firstCoverInitializedNameError = null;
                    }
                  }
                }
                return expr;
              };
              Parser2.prototype.parseExpression = function() {
                var startToken = this.lookahead;
                var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  }
                  expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                }
                return expr;
              };
              Parser2.prototype.parseStatementListItem = function() {
                var statement;
                this.context.isAssignmentTarget = true;
                this.context.isBindingElement = true;
                if (this.lookahead.type === 4) {
                  switch (this.lookahead.value) {
                    case "export":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                      }
                      statement = this.parseExportDeclaration();
                      break;
                    case "import":
                      if (!this.context.isModule) {
                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                      }
                      statement = this.parseImportDeclaration();
                      break;
                    case "const":
                      statement = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      statement = this.parseClassDeclaration();
                      break;
                    case "let":
                      statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                      break;
                    default:
                      statement = this.parseStatement();
                      break;
                  }
                } else {
                  statement = this.parseStatement();
                }
                return statement;
              };
              Parser2.prototype.parseBlock = function() {
                var node = this.createNode();
                this.expect("{");
                var block = [];
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  block.push(this.parseStatementListItem());
                }
                this.expect("}");
                return this.finalize(node, new Node.BlockStatement(block));
              };
              Parser2.prototype.parseLexicalBinding = function(kind, options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, kind);
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (kind === "const") {
                  if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                    if (this.match("=")) {
                      this.nextToken();
                      init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else {
                      this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                    }
                  }
                } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                  this.expect("=");
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseBindingList = function(kind, options) {
                var list = [this.parseLexicalBinding(kind, options)];
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseLexicalBinding(kind, options));
                }
                return list;
              };
              Parser2.prototype.isLexicalDeclaration = function() {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
              };
              Parser2.prototype.parseLexicalDeclaration = function(options) {
                var node = this.createNode();
                var kind = this.nextToken().value;
                assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                var declarations = this.parseBindingList(kind, options);
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
              };
              Parser2.prototype.parseBindingRestElement = function(params, kind) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params, kind);
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseArrayPattern = function(params, kind) {
                var node = this.createNode();
                this.expect("[");
                var elements = [];
                while (!this.match("]")) {
                  if (this.match(",")) {
                    this.nextToken();
                    elements.push(null);
                  } else {
                    if (this.match("...")) {
                      elements.push(this.parseBindingRestElement(params, kind));
                      break;
                    } else {
                      elements.push(this.parsePatternWithDefault(params, kind));
                    }
                    if (!this.match("]")) {
                      this.expect(",");
                    }
                  }
                }
                this.expect("]");
                return this.finalize(node, new Node.ArrayPattern(elements));
              };
              Parser2.prototype.parsePropertyPattern = function(params, kind) {
                var node = this.createNode();
                var computed = false;
                var shorthand = false;
                var method = false;
                var key;
                var value;
                if (this.lookahead.type === 3) {
                  var keyToken = this.lookahead;
                  key = this.parseVariableIdentifier();
                  var init = this.finalize(node, new Node.Identifier(keyToken.value));
                  if (this.match("=")) {
                    params.push(keyToken);
                    shorthand = true;
                    this.nextToken();
                    var expr = this.parseAssignmentExpression();
                    value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                  } else if (!this.match(":")) {
                    params.push(keyToken);
                    shorthand = true;
                    value = init;
                  } else {
                    this.expect(":");
                    value = this.parsePatternWithDefault(params, kind);
                  }
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
                return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
              };
              Parser2.prototype.parseObjectPattern = function(params, kind) {
                var node = this.createNode();
                var properties = [];
                this.expect("{");
                while (!this.match("}")) {
                  properties.push(this.parsePropertyPattern(params, kind));
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return this.finalize(node, new Node.ObjectPattern(properties));
              };
              Parser2.prototype.parsePattern = function(params, kind) {
                var pattern;
                if (this.match("[")) {
                  pattern = this.parseArrayPattern(params, kind);
                } else if (this.match("{")) {
                  pattern = this.parseObjectPattern(params, kind);
                } else {
                  if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                  }
                  params.push(this.lookahead);
                  pattern = this.parseVariableIdentifier(kind);
                }
                return pattern;
              };
              Parser2.prototype.parsePatternWithDefault = function(params, kind) {
                var startToken = this.lookahead;
                var pattern = this.parsePattern(params, kind);
                if (this.match("=")) {
                  this.nextToken();
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = true;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = previousAllowYield;
                  pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                }
                return pattern;
              };
              Parser2.prototype.parseVariableIdentifier = function(kind) {
                var node = this.createNode();
                var token = this.nextToken();
                if (token.type === 4 && token.value === "yield") {
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else if (!this.context.allowYield) {
                    this.throwUnexpectedToken(token);
                  }
                } else if (token.type !== 3) {
                  if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                  } else {
                    if (this.context.strict || token.value !== "let" || kind !== "var") {
                      this.throwUnexpectedToken(token);
                    }
                  }
                } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                  this.tolerateUnexpectedToken(token);
                }
                return this.finalize(node, new Node.Identifier(token.value));
              };
              Parser2.prototype.parseVariableDeclaration = function(options) {
                var node = this.createNode();
                var params = [];
                var id = this.parsePattern(params, "var");
                if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(id.name)) {
                    this.tolerateError(messages_1.Messages.StrictVarName);
                  }
                }
                var init = null;
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                  this.expect("=");
                }
                return this.finalize(node, new Node.VariableDeclarator(id, init));
              };
              Parser2.prototype.parseVariableDeclarationList = function(options) {
                var opt = { inFor: options.inFor };
                var list = [];
                list.push(this.parseVariableDeclaration(opt));
                while (this.match(",")) {
                  this.nextToken();
                  list.push(this.parseVariableDeclaration(opt));
                }
                return list;
              };
              Parser2.prototype.parseVariableStatement = function() {
                var node = this.createNode();
                this.expectKeyword("var");
                var declarations = this.parseVariableDeclarationList({ inFor: false });
                this.consumeSemicolon();
                return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
              };
              Parser2.prototype.parseEmptyStatement = function() {
                var node = this.createNode();
                this.expect(";");
                return this.finalize(node, new Node.EmptyStatement());
              };
              Parser2.prototype.parseExpressionStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseIfClause = function() {
                if (this.context.strict && this.matchKeyword("function")) {
                  this.tolerateError(messages_1.Messages.StrictFunction);
                }
                return this.parseStatement();
              };
              Parser2.prototype.parseIfStatement = function() {
                var node = this.createNode();
                var consequent;
                var alternate = null;
                this.expectKeyword("if");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  consequent = this.parseIfClause();
                  if (this.matchKeyword("else")) {
                    this.nextToken();
                    alternate = this.parseIfClause();
                  }
                }
                return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
              };
              Parser2.prototype.parseDoWhileStatement = function() {
                var node = this.createNode();
                this.expectKeyword("do");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                var body = this.parseStatement();
                this.context.inIteration = previousInIteration;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                } else {
                  this.expect(")");
                  if (this.match(";")) {
                    this.nextToken();
                  }
                }
                return this.finalize(node, new Node.DoWhileStatement(body, test));
              };
              Parser2.prototype.parseWhileStatement = function() {
                var node = this.createNode();
                var body;
                this.expectKeyword("while");
                this.expect("(");
                var test = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.parseStatement();
                  this.context.inIteration = previousInIteration;
                }
                return this.finalize(node, new Node.WhileStatement(test, body));
              };
              Parser2.prototype.parseForStatement = function() {
                var init = null;
                var test = null;
                var update = null;
                var forIn = true;
                var left, right;
                var node = this.createNode();
                this.expectKeyword("for");
                this.expect("(");
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  if (this.matchKeyword("var")) {
                    init = this.createNode();
                    this.nextToken();
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseVariableDeclarationList({ inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && this.matchKeyword("in")) {
                      var decl = declarations[0];
                      if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                      }
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.nextToken();
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                      this.expect(";");
                    }
                  } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                    init = this.createNode();
                    var kind = this.nextToken().value;
                    if (!this.context.strict && this.lookahead.value === "in") {
                      init = this.finalize(init, new Node.Identifier(kind));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = false;
                      var declarations = this.parseBindingList(kind, { inFor: true });
                      this.context.allowIn = previousAllowIn;
                      if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseExpression();
                        init = null;
                      } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                        this.nextToken();
                        left = init;
                        right = this.parseAssignmentExpression();
                        init = null;
                        forIn = false;
                      } else {
                        this.consumeSemicolon();
                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                      }
                    }
                  } else {
                    var initStartToken = this.lookahead;
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    this.context.allowIn = previousAllowIn;
                    if (this.matchKeyword("in")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (this.matchContextualKeyword("of")) {
                      if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                      }
                      this.nextToken();
                      this.reinterpretExpressionAsPattern(init);
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      if (this.match(",")) {
                        var initSeq = [init];
                        while (this.match(",")) {
                          this.nextToken();
                          initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                      }
                      this.expect(";");
                    }
                  }
                }
                if (typeof left === "undefined") {
                  if (!this.match(";")) {
                    test = this.parseExpression();
                  }
                  this.expect(";");
                  if (!this.match(")")) {
                    update = this.parseExpression();
                  }
                }
                var body;
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  var previousInIteration = this.context.inIteration;
                  this.context.inIteration = true;
                  body = this.isolateCoverGrammar(this.parseStatement);
                  this.context.inIteration = previousInIteration;
                }
                return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
              };
              Parser2.prototype.parseContinueStatement = function() {
                var node = this.createNode();
                this.expectKeyword("continue");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  label = id;
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration) {
                  this.throwError(messages_1.Messages.IllegalContinue);
                }
                return this.finalize(node, new Node.ContinueStatement(label));
              };
              Parser2.prototype.parseBreakStatement = function() {
                var node = this.createNode();
                this.expectKeyword("break");
                var label = null;
                if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                  var id = this.parseVariableIdentifier();
                  var key = "$" + id.name;
                  if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.UnknownLabel, id.name);
                  }
                  label = id;
                }
                this.consumeSemicolon();
                if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                  this.throwError(messages_1.Messages.IllegalBreak);
                }
                return this.finalize(node, new Node.BreakStatement(label));
              };
              Parser2.prototype.parseReturnStatement = function() {
                if (!this.context.inFunctionBody) {
                  this.tolerateError(messages_1.Messages.IllegalReturn);
                }
                var node = this.createNode();
                this.expectKeyword("return");
                var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                var argument = hasArgument ? this.parseExpression() : null;
                this.consumeSemicolon();
                return this.finalize(node, new Node.ReturnStatement(argument));
              };
              Parser2.prototype.parseWithStatement = function() {
                if (this.context.strict) {
                  this.tolerateError(messages_1.Messages.StrictModeWith);
                }
                var node = this.createNode();
                var body;
                this.expectKeyword("with");
                this.expect("(");
                var object = this.parseExpression();
                if (!this.match(")") && this.config.tolerant) {
                  this.tolerateUnexpectedToken(this.nextToken());
                  body = this.finalize(this.createNode(), new Node.EmptyStatement());
                } else {
                  this.expect(")");
                  body = this.parseStatement();
                }
                return this.finalize(node, new Node.WithStatement(object, body));
              };
              Parser2.prototype.parseSwitchCase = function() {
                var node = this.createNode();
                var test;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  test = null;
                } else {
                  this.expectKeyword("case");
                  test = this.parseExpression();
                }
                this.expect(":");
                var consequent = [];
                while (true) {
                  if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                    break;
                  }
                  consequent.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.SwitchCase(test, consequent));
              };
              Parser2.prototype.parseSwitchStatement = function() {
                var node = this.createNode();
                this.expectKeyword("switch");
                this.expect("(");
                var discriminant = this.parseExpression();
                this.expect(")");
                var previousInSwitch = this.context.inSwitch;
                this.context.inSwitch = true;
                var cases = [];
                var defaultFound = false;
                this.expect("{");
                while (true) {
                  if (this.match("}")) {
                    break;
                  }
                  var clause = this.parseSwitchCase();
                  if (clause.test === null) {
                    if (defaultFound) {
                      this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                  }
                  cases.push(clause);
                }
                this.expect("}");
                this.context.inSwitch = previousInSwitch;
                return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
              };
              Parser2.prototype.parseLabelledStatement = function() {
                var node = this.createNode();
                var expr = this.parseExpression();
                var statement;
                if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var id = expr;
                  var key = "$" + id.name;
                  if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                    this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                  }
                  this.context.labelSet[key] = true;
                  var body = void 0;
                  if (this.matchKeyword("class")) {
                    this.tolerateUnexpectedToken(this.lookahead);
                    body = this.parseClassDeclaration();
                  } else if (this.matchKeyword("function")) {
                    var token = this.lookahead;
                    var declaration = this.parseFunctionDeclaration();
                    if (this.context.strict) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                    } else if (declaration.generator) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                    }
                    body = declaration;
                  } else {
                    body = this.parseStatement();
                  }
                  delete this.context.labelSet[key];
                  statement = new Node.LabeledStatement(id, body);
                } else {
                  this.consumeSemicolon();
                  statement = new Node.ExpressionStatement(expr);
                }
                return this.finalize(node, statement);
              };
              Parser2.prototype.parseThrowStatement = function() {
                var node = this.createNode();
                this.expectKeyword("throw");
                if (this.hasLineTerminator) {
                  this.throwError(messages_1.Messages.NewlineAfterThrow);
                }
                var argument = this.parseExpression();
                this.consumeSemicolon();
                return this.finalize(node, new Node.ThrowStatement(argument));
              };
              Parser2.prototype.parseCatchClause = function() {
                var node = this.createNode();
                this.expectKeyword("catch");
                this.expect("(");
                if (this.match(")")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                var params = [];
                var param = this.parsePattern(params);
                var paramMap = {};
                for (var i = 0; i < params.length; i++) {
                  var key = "$" + params[i].value;
                  if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                    this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                  }
                  paramMap[key] = true;
                }
                if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                  if (this.scanner.isRestrictedWord(param.name)) {
                    this.tolerateError(messages_1.Messages.StrictCatchVariable);
                  }
                }
                this.expect(")");
                var body = this.parseBlock();
                return this.finalize(node, new Node.CatchClause(param, body));
              };
              Parser2.prototype.parseFinallyClause = function() {
                this.expectKeyword("finally");
                return this.parseBlock();
              };
              Parser2.prototype.parseTryStatement = function() {
                var node = this.createNode();
                this.expectKeyword("try");
                var block = this.parseBlock();
                var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                if (!handler && !finalizer) {
                  this.throwError(messages_1.Messages.NoCatchOrFinally);
                }
                return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
              };
              Parser2.prototype.parseDebuggerStatement = function() {
                var node = this.createNode();
                this.expectKeyword("debugger");
                this.consumeSemicolon();
                return this.finalize(node, new Node.DebuggerStatement());
              };
              Parser2.prototype.parseStatement = function() {
                var statement;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    statement = this.parseExpressionStatement();
                    break;
                  case 7:
                    var value = this.lookahead.value;
                    if (value === "{") {
                      statement = this.parseBlock();
                    } else if (value === "(") {
                      statement = this.parseExpressionStatement();
                    } else if (value === ";") {
                      statement = this.parseEmptyStatement();
                    } else {
                      statement = this.parseExpressionStatement();
                    }
                    break;
                  case 3:
                    statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        statement = this.parseBreakStatement();
                        break;
                      case "continue":
                        statement = this.parseContinueStatement();
                        break;
                      case "debugger":
                        statement = this.parseDebuggerStatement();
                        break;
                      case "do":
                        statement = this.parseDoWhileStatement();
                        break;
                      case "for":
                        statement = this.parseForStatement();
                        break;
                      case "function":
                        statement = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        statement = this.parseIfStatement();
                        break;
                      case "return":
                        statement = this.parseReturnStatement();
                        break;
                      case "switch":
                        statement = this.parseSwitchStatement();
                        break;
                      case "throw":
                        statement = this.parseThrowStatement();
                        break;
                      case "try":
                        statement = this.parseTryStatement();
                        break;
                      case "var":
                        statement = this.parseVariableStatement();
                        break;
                      case "while":
                        statement = this.parseWhileStatement();
                        break;
                      case "with":
                        statement = this.parseWithStatement();
                        break;
                      default:
                        statement = this.parseExpressionStatement();
                        break;
                    }
                    break;
                  default:
                    statement = this.throwUnexpectedToken(this.lookahead);
                }
                return statement;
              };
              Parser2.prototype.parseFunctionSourceElements = function() {
                var node = this.createNode();
                this.expect("{");
                var body = this.parseDirectivePrologues();
                var previousLabelSet = this.context.labelSet;
                var previousInIteration = this.context.inIteration;
                var previousInSwitch = this.context.inSwitch;
                var previousInFunctionBody = this.context.inFunctionBody;
                this.context.labelSet = {};
                this.context.inIteration = false;
                this.context.inSwitch = false;
                this.context.inFunctionBody = true;
                while (this.lookahead.type !== 2) {
                  if (this.match("}")) {
                    break;
                  }
                  body.push(this.parseStatementListItem());
                }
                this.expect("}");
                this.context.labelSet = previousLabelSet;
                this.context.inIteration = previousInIteration;
                this.context.inSwitch = previousInSwitch;
                this.context.inFunctionBody = previousInFunctionBody;
                return this.finalize(node, new Node.BlockStatement(body));
              };
              Parser2.prototype.validateParam = function(options, param, name) {
                var key = "$" + name;
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(name)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  }
                  if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                } else if (!options.firstRestricted) {
                  if (this.scanner.isRestrictedWord(name)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictParamName;
                  } else if (this.scanner.isStrictModeReservedWord(name)) {
                    options.firstRestricted = param;
                    options.message = messages_1.Messages.StrictReservedWord;
                  } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                    options.stricted = param;
                    options.message = messages_1.Messages.StrictParamDupe;
                  }
                }
                if (typeof Object.defineProperty === "function") {
                  Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
                } else {
                  options.paramSet[key] = true;
                }
              };
              Parser2.prototype.parseRestElement = function(params) {
                var node = this.createNode();
                this.expect("...");
                var arg = this.parsePattern(params);
                if (this.match("=")) {
                  this.throwError(messages_1.Messages.DefaultRestParameter);
                }
                if (!this.match(")")) {
                  this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                }
                return this.finalize(node, new Node.RestElement(arg));
              };
              Parser2.prototype.parseFormalParameter = function(options) {
                var params = [];
                var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                for (var i = 0; i < params.length; i++) {
                  this.validateParam(options, params[i], params[i].value);
                }
                options.simple = options.simple && param instanceof Node.Identifier;
                options.params.push(param);
              };
              Parser2.prototype.parseFormalParameters = function(firstRestricted) {
                var options;
                options = {
                  simple: true,
                  params: [],
                  firstRestricted
                };
                this.expect("(");
                if (!this.match(")")) {
                  options.paramSet = {};
                  while (this.lookahead.type !== 2) {
                    this.parseFormalParameter(options);
                    if (this.match(")")) {
                      break;
                    }
                    this.expect(",");
                    if (this.match(")")) {
                      break;
                    }
                  }
                }
                this.expect(")");
                return {
                  simple: options.simple,
                  params: options.params,
                  stricted: options.stricted,
                  firstRestricted: options.firstRestricted,
                  message: options.message
                };
              };
              Parser2.prototype.matchAsyncFunction = function() {
                var match2 = this.matchContextualKeyword("async");
                if (match2) {
                  var state = this.scanner.saveState();
                  this.scanner.scanComments();
                  var next = this.scanner.lex();
                  this.scanner.restoreState(state);
                  match2 = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
                }
                return match2;
              };
              Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted = null;
                if (!identifierIsOptional || !this.match("(")) {
                  var token = this.lookahead;
                  id = this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
              };
              Parser2.prototype.parseFunctionExpression = function() {
                var node = this.createNode();
                var isAsync = this.matchContextualKeyword("async");
                if (isAsync) {
                  this.nextToken();
                }
                this.expectKeyword("function");
                var isGenerator = isAsync ? false : this.match("*");
                if (isGenerator) {
                  this.nextToken();
                }
                var message;
                var id = null;
                var firstRestricted;
                var previousAllowAwait = this.context.await;
                var previousAllowYield = this.context.allowYield;
                this.context.await = isAsync;
                this.context.allowYield = !isGenerator;
                if (!this.match("(")) {
                  var token = this.lookahead;
                  id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                  if (this.context.strict) {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                    }
                  } else {
                    if (this.scanner.isRestrictedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictFunctionName;
                    } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                      firstRestricted = token;
                      message = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                var formalParameters = this.parseFormalParameters(firstRestricted);
                var params = formalParameters.params;
                var stricted = formalParameters.stricted;
                firstRestricted = formalParameters.firstRestricted;
                if (formalParameters.message) {
                  message = formalParameters.message;
                }
                var previousStrict = this.context.strict;
                var previousAllowStrictDirective = this.context.allowStrictDirective;
                this.context.allowStrictDirective = formalParameters.simple;
                var body = this.parseFunctionSourceElements();
                if (this.context.strict && firstRestricted) {
                  this.throwUnexpectedToken(firstRestricted, message);
                }
                if (this.context.strict && stricted) {
                  this.tolerateUnexpectedToken(stricted, message);
                }
                this.context.strict = previousStrict;
                this.context.allowStrictDirective = previousAllowStrictDirective;
                this.context.await = previousAllowAwait;
                this.context.allowYield = previousAllowYield;
                return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
              };
              Parser2.prototype.parseDirective = function() {
                var token = this.lookahead;
                var node = this.createNode();
                var expr = this.parseExpression();
                var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                this.consumeSemicolon();
                return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
              };
              Parser2.prototype.parseDirectivePrologues = function() {
                var firstRestricted = null;
                var body = [];
                while (true) {
                  var token = this.lookahead;
                  if (token.type !== 8) {
                    break;
                  }
                  var statement = this.parseDirective();
                  body.push(statement);
                  var directive = statement.directive;
                  if (typeof directive !== "string") {
                    break;
                  }
                  if (directive === "use strict") {
                    this.context.strict = true;
                    if (firstRestricted) {
                      this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                    }
                    if (!this.context.allowStrictDirective) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                    }
                  } else {
                    if (!firstRestricted && token.octal) {
                      firstRestricted = token;
                    }
                  }
                }
                return body;
              };
              Parser2.prototype.qualifiedPropertyName = function(token) {
                switch (token.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return true;
                  case 7:
                    return token.value === "[";
                  default:
                    break;
                }
                return false;
              };
              Parser2.prototype.parseGetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length > 0) {
                  this.tolerateError(messages_1.Messages.BadGetterArity);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseSetterMethod = function() {
                var node = this.createNode();
                var isGenerator = false;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = !isGenerator;
                var formalParameters = this.parseFormalParameters();
                if (formalParameters.params.length !== 1) {
                  this.tolerateError(messages_1.Messages.BadSetterArity);
                } else if (formalParameters.params[0] instanceof Node.RestElement) {
                  this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                }
                var method = this.parsePropertyMethod(formalParameters);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
              };
              Parser2.prototype.parseGeneratorMethod = function() {
                var node = this.createNode();
                var isGenerator = true;
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var params = this.parseFormalParameters();
                this.context.allowYield = false;
                var method = this.parsePropertyMethod(params);
                this.context.allowYield = previousAllowYield;
                return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
              };
              Parser2.prototype.isStartOfExpression = function() {
                var start = true;
                var value = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                    break;
                  case 4:
                    start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                    break;
                  default:
                    break;
                }
                return start;
              };
              Parser2.prototype.parseYieldExpression = function() {
                var node = this.createNode();
                this.expectKeyword("yield");
                var argument = null;
                var delegate = false;
                if (!this.hasLineTerminator) {
                  var previousAllowYield = this.context.allowYield;
                  this.context.allowYield = false;
                  delegate = this.match("*");
                  if (delegate) {
                    this.nextToken();
                    argument = this.parseAssignmentExpression();
                  } else if (this.isStartOfExpression()) {
                    argument = this.parseAssignmentExpression();
                  }
                  this.context.allowYield = previousAllowYield;
                }
                return this.finalize(node, new Node.YieldExpression(argument, delegate));
              };
              Parser2.prototype.parseClassElement = function(hasConstructor) {
                var token = this.lookahead;
                var node = this.createNode();
                var kind = "";
                var key = null;
                var value = null;
                var computed = false;
                var method = false;
                var isStatic = false;
                var isAsync = false;
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  var id = key;
                  if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                    token = this.lookahead;
                    isStatic = true;
                    computed = this.match("[");
                    if (this.match("*")) {
                      this.nextToken();
                    } else {
                      key = this.parseObjectPropertyKey();
                    }
                  }
                  if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                    var punctuator = this.lookahead.value;
                    if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                      isAsync = true;
                      token = this.lookahead;
                      key = this.parseObjectPropertyKey();
                      if (token.type === 3 && token.value === "constructor") {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                      }
                    }
                  }
                }
                var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                if (token.type === 3) {
                  if (token.value === "get" && lookaheadPropertyKey) {
                    kind = "get";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    this.context.allowYield = false;
                    value = this.parseGetterMethod();
                  } else if (token.value === "set" && lookaheadPropertyKey) {
                    kind = "set";
                    computed = this.match("[");
                    key = this.parseObjectPropertyKey();
                    value = this.parseSetterMethod();
                  }
                } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                  kind = "init";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseGeneratorMethod();
                  method = true;
                }
                if (!kind && key && this.match("(")) {
                  kind = "init";
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                }
                if (!kind) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                if (kind === "init") {
                  kind = "method";
                }
                if (!computed) {
                  if (isStatic && this.isPropertyKey(key, "prototype")) {
                    this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                  }
                  if (!isStatic && this.isPropertyKey(key, "constructor")) {
                    if (kind !== "method" || !method || value && value.generator) {
                      this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                    }
                    if (hasConstructor.value) {
                      this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                    } else {
                      hasConstructor.value = true;
                    }
                    kind = "constructor";
                  }
                }
                return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
              };
              Parser2.prototype.parseClassElementList = function() {
                var body = [];
                var hasConstructor = { value: false };
                this.expect("{");
                while (!this.match("}")) {
                  if (this.match(";")) {
                    this.nextToken();
                  } else {
                    body.push(this.parseClassElement(hasConstructor));
                  }
                }
                this.expect("}");
                return body;
              };
              Parser2.prototype.parseClassBody = function() {
                var node = this.createNode();
                var elementList = this.parseClassElementList();
                return this.finalize(node, new Node.ClassBody(elementList));
              };
              Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
              };
              Parser2.prototype.parseClassExpression = function() {
                var node = this.createNode();
                var previousStrict = this.context.strict;
                this.context.strict = true;
                this.expectKeyword("class");
                var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                var superClass = null;
                if (this.matchKeyword("extends")) {
                  this.nextToken();
                  superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                }
                var classBody = this.parseClassBody();
                this.context.strict = previousStrict;
                return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
              };
              Parser2.prototype.parseModule = function() {
                this.context.strict = true;
                this.context.isModule = true;
                this.scanner.isModule = true;
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Module(body));
              };
              Parser2.prototype.parseScript = function() {
                var node = this.createNode();
                var body = this.parseDirectivePrologues();
                while (this.lookahead.type !== 2) {
                  body.push(this.parseStatementListItem());
                }
                return this.finalize(node, new Node.Script(body));
              };
              Parser2.prototype.parseModuleSpecifier = function() {
                var node = this.createNode();
                if (this.lookahead.type !== 8) {
                  this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                }
                var token = this.nextToken();
                var raw = this.getTokenRaw(token);
                return this.finalize(node, new Node.Literal(token.value, raw));
              };
              Parser2.prototype.parseImportSpecifier = function() {
                var node = this.createNode();
                var imported;
                var local;
                if (this.lookahead.type === 3) {
                  imported = this.parseVariableIdentifier();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  }
                } else {
                  imported = this.parseIdentifierName();
                  local = imported;
                  if (this.matchContextualKeyword("as")) {
                    this.nextToken();
                    local = this.parseVariableIdentifier();
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                }
                return this.finalize(node, new Node.ImportSpecifier(local, imported));
              };
              Parser2.prototype.parseNamedImports = function() {
                this.expect("{");
                var specifiers = [];
                while (!this.match("}")) {
                  specifiers.push(this.parseImportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                return specifiers;
              };
              Parser2.prototype.parseImportDefaultSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportDefaultSpecifier(local));
              };
              Parser2.prototype.parseImportNamespaceSpecifier = function() {
                var node = this.createNode();
                this.expect("*");
                if (!this.matchContextualKeyword("as")) {
                  this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                }
                this.nextToken();
                var local = this.parseIdentifierName();
                return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
              };
              Parser2.prototype.parseImportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalImportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("import");
                var src;
                var specifiers = [];
                if (this.lookahead.type === 8) {
                  src = this.parseModuleSpecifier();
                } else {
                  if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                    specifiers.push(this.parseImportDefaultSpecifier());
                    if (this.match(",")) {
                      this.nextToken();
                      if (this.match("*")) {
                        specifiers.push(this.parseImportNamespaceSpecifier());
                      } else if (this.match("{")) {
                        specifiers = specifiers.concat(this.parseNamedImports());
                      } else {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                    }
                  } else {
                    this.throwUnexpectedToken(this.nextToken());
                  }
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  src = this.parseModuleSpecifier();
                }
                this.consumeSemicolon();
                return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
              };
              Parser2.prototype.parseExportSpecifier = function() {
                var node = this.createNode();
                var local = this.parseIdentifierName();
                var exported = local;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  exported = this.parseIdentifierName();
                }
                return this.finalize(node, new Node.ExportSpecifier(local, exported));
              };
              Parser2.prototype.parseExportDeclaration = function() {
                if (this.context.inFunctionBody) {
                  this.throwError(messages_1.Messages.IllegalExportDeclaration);
                }
                var node = this.createNode();
                this.expectKeyword("export");
                var exportDeclaration;
                if (this.matchKeyword("default")) {
                  this.nextToken();
                  if (this.matchKeyword("function")) {
                    var declaration = this.parseFunctionDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchKeyword("class")) {
                    var declaration = this.parseClassDeclaration(true);
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else if (this.matchContextualKeyword("async")) {
                    var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  } else {
                    if (this.matchContextualKeyword("from")) {
                      this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                    }
                    var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                    this.consumeSemicolon();
                    exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                  }
                } else if (this.match("*")) {
                  this.nextToken();
                  if (!this.matchContextualKeyword("from")) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  }
                  this.nextToken();
                  var src = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
                } else if (this.lookahead.type === 4) {
                  var declaration = void 0;
                  switch (this.lookahead.value) {
                    case "let":
                    case "const":
                      declaration = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      declaration = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else if (this.matchAsyncFunction()) {
                  var declaration = this.parseFunctionDeclaration();
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                } else {
                  var specifiers = [];
                  var source = null;
                  var isExportFromIdentifier = false;
                  this.expect("{");
                  while (!this.match("}")) {
                    isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                    specifiers.push(this.parseExportSpecifier());
                    if (!this.match("}")) {
                      this.expect(",");
                    }
                  }
                  this.expect("}");
                  if (this.matchContextualKeyword("from")) {
                    this.nextToken();
                    source = this.parseModuleSpecifier();
                    this.consumeSemicolon();
                  } else if (isExportFromIdentifier) {
                    var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                    this.throwError(message, this.lookahead.value);
                  } else {
                    this.consumeSemicolon();
                  }
                  exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
                }
                return exportDeclaration;
              };
              return Parser2;
            }();
            exports3.Parser = Parser;
          },
          /* 9 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            function assert20(condition, message) {
              if (!condition) {
                throw new Error("ASSERT: " + message);
              }
            }
            exports3.assert = assert20;
          },
          /* 10 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var ErrorHandler = function() {
              function ErrorHandler2() {
                this.errors = [];
                this.tolerant = false;
              }
              ErrorHandler2.prototype.recordError = function(error) {
                this.errors.push(error);
              };
              ErrorHandler2.prototype.tolerate = function(error) {
                if (this.tolerant) {
                  this.recordError(error);
                } else {
                  throw error;
                }
              };
              ErrorHandler2.prototype.constructError = function(msg, column) {
                var error = new Error(msg);
                try {
                  throw error;
                } catch (base) {
                  if (Object.create && Object.defineProperty) {
                    error = Object.create(base);
                    Object.defineProperty(error, "column", { value: column });
                  }
                }
                return error;
              };
              ErrorHandler2.prototype.createError = function(index, line, col, description) {
                var msg = "Line " + line + ": " + description;
                var error = this.constructError(msg, col);
                error.index = index;
                error.lineNumber = line;
                error.description = description;
                return error;
              };
              ErrorHandler2.prototype.throwError = function(index, line, col, description) {
                throw this.createError(index, line, col, description);
              };
              ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
                var error = this.createError(index, line, col, description);
                if (this.tolerant) {
                  this.recordError(error);
                } else {
                  throw error;
                }
              };
              return ErrorHandler2;
            }();
            exports3.ErrorHandler = ErrorHandler;
          },
          /* 11 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.Messages = {
              BadGetterArity: "Getter must not have any formal parameters",
              BadSetterArity: "Setter must have exactly one formal parameter",
              BadSetterRestParameter: "Setter function argument must not be a rest parameter",
              ConstructorIsAsync: "Class constructor may not be an async method",
              ConstructorSpecialMethod: "Class constructor may not be an accessor",
              DeclarationMissingInitializer: "Missing initializer in %0 declaration",
              DefaultRestParameter: "Unexpected token =",
              DuplicateBinding: "Duplicate binding %0",
              DuplicateConstructor: "A class may only have one constructor",
              DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
              ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
              GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
              IllegalBreak: "Illegal break statement",
              IllegalContinue: "Illegal continue statement",
              IllegalExportDeclaration: "Unexpected token",
              IllegalImportDeclaration: "Unexpected token",
              IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
              IllegalReturn: "Illegal return statement",
              InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
              InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
              InvalidLHSInAssignment: "Invalid left-hand side in assignment",
              InvalidLHSInForIn: "Invalid left-hand side in for-in",
              InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
              InvalidModuleSpecifier: "Unexpected token",
              InvalidRegExp: "Invalid regular expression",
              LetInLexicalBinding: "let is disallowed as a lexically bound name",
              MissingFromClause: "Unexpected token",
              MultipleDefaultsInSwitch: "More than one default clause in switch statement",
              NewlineAfterThrow: "Illegal newline after throw",
              NoAsAfterImportNamespace: "Unexpected token",
              NoCatchOrFinally: "Missing catch or finally after try",
              ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
              Redeclaration: "%0 '%1' has already been declared",
              StaticPrototype: "Classes may not have static property named prototype",
              StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
              StrictDelete: "Delete of an unqualified identifier in strict mode.",
              StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
              StrictFunctionName: "Function name may not be eval or arguments in strict mode",
              StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
              StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
              StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
              StrictModeWith: "Strict mode code may not include a with statement",
              StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
              StrictParamDupe: "Strict mode function may not have duplicate parameter names",
              StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
              StrictReservedWord: "Use of future reserved word in strict mode",
              StrictVarName: "Variable name may not be eval or arguments in strict mode",
              TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
              UnexpectedEOS: "Unexpected end of input",
              UnexpectedIdentifier: "Unexpected identifier",
              UnexpectedNumber: "Unexpected number",
              UnexpectedReserved: "Unexpected reserved word",
              UnexpectedString: "Unexpected string",
              UnexpectedTemplate: "Unexpected quasi %0",
              UnexpectedToken: "Unexpected token %0",
              UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
              UnknownLabel: "Undefined label '%0'",
              UnterminatedRegExp: "Invalid regular expression: missing /"
            };
          },
          /* 12 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var assert_1 = __webpack_require__(9);
            var character_1 = __webpack_require__(4);
            var messages_1 = __webpack_require__(11);
            function hexValue(ch) {
              return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
              return "01234567".indexOf(ch);
            }
            var Scanner = function() {
              function Scanner2(code, handler) {
                this.source = code;
                this.errorHandler = handler;
                this.trackComment = false;
                this.isModule = false;
                this.length = code.length;
                this.index = 0;
                this.lineNumber = code.length > 0 ? 1 : 0;
                this.lineStart = 0;
                this.curlyStack = [];
              }
              Scanner2.prototype.saveState = function() {
                return {
                  index: this.index,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart
                };
              };
              Scanner2.prototype.restoreState = function(state) {
                this.index = state.index;
                this.lineNumber = state.lineNumber;
                this.lineStart = state.lineStart;
              };
              Scanner2.prototype.eof = function() {
                return this.index >= this.length;
              };
              Scanner2.prototype.throwUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.tolerateUnexpectedToken = function(message) {
                if (message === void 0) {
                  message = messages_1.Messages.UnexpectedTokenIllegal;
                }
                this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
              };
              Scanner2.prototype.skipSingleLineComment = function(offset) {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - offset;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - offset
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  ++this.index;
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart - 1
                      };
                      var entry = {
                        multiLine: false,
                        slice: [start + offset, this.index - 1],
                        range: [start, this.index - 1],
                        loc
                      };
                      comments.push(entry);
                    }
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    return comments;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                return comments;
              };
              Scanner2.prototype.skipMultiLineComment = function() {
                var comments = [];
                var start, loc;
                if (this.trackComment) {
                  comments = [];
                  start = this.index - 2;
                  loc = {
                    start: {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 2
                    },
                    end: {}
                  };
                }
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isLineTerminator(ch)) {
                    if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    ++this.index;
                    this.lineStart = this.index;
                  } else if (ch === 42) {
                    if (this.source.charCodeAt(this.index + 1) === 47) {
                      this.index += 2;
                      if (this.trackComment) {
                        loc.end = {
                          line: this.lineNumber,
                          column: this.index - this.lineStart
                        };
                        var entry = {
                          multiLine: true,
                          slice: [start + 2, this.index - 2],
                          range: [start, this.index],
                          loc
                        };
                        comments.push(entry);
                      }
                      return comments;
                    }
                    ++this.index;
                  } else {
                    ++this.index;
                  }
                }
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart
                  };
                  var entry = {
                    multiLine: true,
                    slice: [start + 2, this.index],
                    range: [start, this.index],
                    loc
                  };
                  comments.push(entry);
                }
                this.tolerateUnexpectedToken();
                return comments;
              };
              Scanner2.prototype.scanComments = function() {
                var comments;
                if (this.trackComment) {
                  comments = [];
                }
                var start = this.index === 0;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isWhiteSpace(ch)) {
                    ++this.index;
                  } else if (character_1.Character.isLineTerminator(ch)) {
                    ++this.index;
                    if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                      ++this.index;
                    }
                    ++this.lineNumber;
                    this.lineStart = this.index;
                    start = true;
                  } else if (ch === 47) {
                    ch = this.source.charCodeAt(this.index + 1);
                    if (ch === 47) {
                      this.index += 2;
                      var comment = this.skipSingleLineComment(2);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                      start = true;
                    } else if (ch === 42) {
                      this.index += 2;
                      var comment = this.skipMultiLineComment();
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (start && ch === 45) {
                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                      this.index += 3;
                      var comment = this.skipSingleLineComment(3);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else if (ch === 60 && !this.isModule) {
                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                      this.index += 4;
                      var comment = this.skipSingleLineComment(4);
                      if (this.trackComment) {
                        comments = comments.concat(comment);
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                }
                return comments;
              };
              Scanner2.prototype.isFutureReservedWord = function(id) {
                switch (id) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isStrictModeReservedWord = function(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              };
              Scanner2.prototype.isRestrictedWord = function(id) {
                return id === "eval" || id === "arguments";
              };
              Scanner2.prototype.isKeyword = function(id) {
                switch (id.length) {
                  case 2:
                    return id === "if" || id === "in" || id === "do";
                  case 3:
                    return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                  case 4:
                    return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                  case 5:
                    return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                  case 6:
                    return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                  case 7:
                    return id === "default" || id === "finally" || id === "extends";
                  case 8:
                    return id === "function" || id === "continue" || id === "debugger";
                  case 10:
                    return id === "instanceof";
                  default:
                    return false;
                }
              };
              Scanner2.prototype.codePointAt = function(i) {
                var cp = this.source.charCodeAt(i);
                if (cp >= 55296 && cp <= 56319) {
                  var second = this.source.charCodeAt(i + 1);
                  if (second >= 56320 && second <= 57343) {
                    var first3 = cp;
                    cp = (first3 - 55296) * 1024 + second - 56320 + 65536;
                  }
                }
                return cp;
              };
              Scanner2.prototype.scanHexEscape = function(prefix) {
                var len = prefix === "u" ? 4 : 2;
                var code = 0;
                for (var i = 0; i < len; ++i) {
                  if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    code = code * 16 + hexValue(this.source[this.index++]);
                  } else {
                    return null;
                  }
                }
                return String.fromCharCode(code);
              };
              Scanner2.prototype.scanUnicodeCodePointEscape = function() {
                var ch = this.source[this.index];
                var code = 0;
                if (ch === "}") {
                  this.throwUnexpectedToken();
                }
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                    break;
                  }
                  code = code * 16 + hexValue(ch);
                }
                if (code > 1114111 || ch !== "}") {
                  this.throwUnexpectedToken();
                }
                return character_1.Character.fromCodePoint(code);
              };
              Scanner2.prototype.getIdentifier = function() {
                var start = this.index++;
                while (!this.eof()) {
                  var ch = this.source.charCodeAt(this.index);
                  if (ch === 92) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  } else if (ch >= 55296 && ch < 57343) {
                    this.index = start;
                    return this.getComplexIdentifier();
                  }
                  if (character_1.Character.isIdentifierPart(ch)) {
                    ++this.index;
                  } else {
                    break;
                  }
                }
                return this.source.slice(start, this.index);
              };
              Scanner2.prototype.getComplexIdentifier = function() {
                var cp = this.codePointAt(this.index);
                var id = character_1.Character.fromCodePoint(cp);
                this.index += id.length;
                var ch;
                if (cp === 92) {
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id = ch;
                }
                while (!this.eof()) {
                  cp = this.codePointAt(this.index);
                  if (!character_1.Character.isIdentifierPart(cp)) {
                    break;
                  }
                  ch = character_1.Character.fromCodePoint(cp);
                  id += ch;
                  this.index += ch.length;
                  if (cp === 92) {
                    id = id.substr(0, id.length - 1);
                    if (this.source.charCodeAt(this.index) !== 117) {
                      this.throwUnexpectedToken();
                    }
                    ++this.index;
                    if (this.source[this.index] === "{") {
                      ++this.index;
                      ch = this.scanUnicodeCodePointEscape();
                    } else {
                      ch = this.scanHexEscape("u");
                      if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken();
                      }
                    }
                    id += ch;
                  }
                }
                return id;
              };
              Scanner2.prototype.octalToDecimal = function(ch) {
                var octal = ch !== "0";
                var code = octalValue(ch);
                if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  octal = true;
                  code = code * 8 + octalValue(this.source[this.index++]);
                  if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    code = code * 8 + octalValue(this.source[this.index++]);
                  }
                }
                return {
                  code,
                  octal
                };
              };
              Scanner2.prototype.scanIdentifier = function() {
                var type;
                var start = this.index;
                var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                if (id.length === 1) {
                  type = 3;
                } else if (this.isKeyword(id)) {
                  type = 4;
                } else if (id === "null") {
                  type = 5;
                } else if (id === "true" || id === "false") {
                  type = 1;
                } else {
                  type = 3;
                }
                if (type !== 3 && start + id.length !== this.index) {
                  var restore = this.index;
                  this.index = start;
                  this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                  this.index = restore;
                }
                return {
                  type,
                  value: id,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanPunctuator = function() {
                var start = this.index;
                var str = this.source[this.index];
                switch (str) {
                  case "(":
                  case "{":
                    if (str === "{") {
                      this.curlyStack.push("{");
                    }
                    ++this.index;
                    break;
                  case ".":
                    ++this.index;
                    if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                      this.index += 2;
                      str = "...";
                    }
                    break;
                  case "}":
                    ++this.index;
                    this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    str = this.source.substr(this.index, 4);
                    if (str === ">>>=") {
                      this.index += 4;
                    } else {
                      str = str.substr(0, 3);
                      if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                        this.index += 3;
                      } else {
                        str = str.substr(0, 2);
                        if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                          this.index += 2;
                        } else {
                          str = this.source[this.index];
                          if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                            ++this.index;
                          }
                        }
                      }
                    }
                }
                if (this.index === start) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 7,
                  value: str,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanHexLiteral = function(start) {
                var num = "";
                while (!this.eof()) {
                  if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt("0x" + num, 16),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanBinaryLiteral = function(start) {
                var num = "";
                var ch;
                while (!this.eof()) {
                  ch = this.source[this.index];
                  if (ch !== "0" && ch !== "1") {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (!this.eof()) {
                  ch = this.source.charCodeAt(this.index);
                  if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                    this.throwUnexpectedToken();
                  }
                }
                return {
                  type: 6,
                  value: parseInt(num, 2),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
                var num = "";
                var octal = false;
                if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                  octal = true;
                  num = "0" + this.source[this.index++];
                } else {
                  ++this.index;
                }
                while (!this.eof()) {
                  if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                    break;
                  }
                  num += this.source[this.index++];
                }
                if (!octal && num.length === 0) {
                  this.throwUnexpectedToken();
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseInt(num, 8),
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.isImplicitOctalLiteral = function() {
                for (var i = this.index + 1; i < this.length; ++i) {
                  var ch = this.source[i];
                  if (ch === "8" || ch === "9") {
                    return false;
                  }
                  if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    return true;
                  }
                }
                return true;
              };
              Scanner2.prototype.scanNumericLiteral = function() {
                var start = this.index;
                var ch = this.source[start];
                assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                var num = "";
                if (ch !== ".") {
                  num = this.source[this.index++];
                  ch = this.source[this.index];
                  if (num === "0") {
                    if (ch === "x" || ch === "X") {
                      ++this.index;
                      return this.scanHexLiteral(start);
                    }
                    if (ch === "b" || ch === "B") {
                      ++this.index;
                      return this.scanBinaryLiteral(start);
                    }
                    if (ch === "o" || ch === "O") {
                      return this.scanOctalLiteral(ch, start);
                    }
                    if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                      if (this.isImplicitOctalLiteral()) {
                        return this.scanOctalLiteral(ch, start);
                      }
                    }
                  }
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === ".") {
                  num += this.source[this.index++];
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                  ch = this.source[this.index];
                }
                if (ch === "e" || ch === "E") {
                  num += this.source[this.index++];
                  ch = this.source[this.index];
                  if (ch === "+" || ch === "-") {
                    num += this.source[this.index++];
                  }
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                      num += this.source[this.index++];
                    }
                  } else {
                    this.throwUnexpectedToken();
                  }
                }
                if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                  this.throwUnexpectedToken();
                }
                return {
                  type: 6,
                  value: parseFloat(num),
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanStringLiteral = function() {
                var start = this.index;
                var quote = this.source[start];
                assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                ++this.index;
                var octal = false;
                var str = "";
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === quote) {
                    quote = "";
                    break;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            str += this.scanUnicodeCodePointEscape();
                          } else {
                            var unescaped_1 = this.scanHexEscape(ch);
                            if (unescaped_1 === null) {
                              this.throwUnexpectedToken();
                            }
                            str += unescaped_1;
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          str += unescaped;
                          break;
                        case "n":
                          str += "\n";
                          break;
                        case "r":
                          str += "\r";
                          break;
                        case "t":
                          str += "	";
                          break;
                        case "b":
                          str += "\b";
                          break;
                        case "f":
                          str += "\f";
                          break;
                        case "v":
                          str += "\v";
                          break;
                        case "8":
                        case "9":
                          str += ch;
                          this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            var octToDec = this.octalToDecimal(ch);
                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                          } else {
                            str += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    break;
                  } else {
                    str += ch;
                  }
                }
                if (quote !== "") {
                  this.index = start;
                  this.throwUnexpectedToken();
                }
                return {
                  type: 8,
                  value: str,
                  octal,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.scanTemplate = function() {
                var cooked = "";
                var terminated = false;
                var start = this.index;
                var head = this.source[start] === "`";
                var tail = false;
                var rawOffset = 2;
                ++this.index;
                while (!this.eof()) {
                  var ch = this.source[this.index++];
                  if (ch === "`") {
                    rawOffset = 1;
                    tail = true;
                    terminated = true;
                    break;
                  } else if (ch === "$") {
                    if (this.source[this.index] === "{") {
                      this.curlyStack.push("${");
                      ++this.index;
                      terminated = true;
                      break;
                    }
                    cooked += ch;
                  } else if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      switch (ch) {
                        case "n":
                          cooked += "\n";
                          break;
                        case "r":
                          cooked += "\r";
                          break;
                        case "t":
                          cooked += "	";
                          break;
                        case "u":
                          if (this.source[this.index] === "{") {
                            ++this.index;
                            cooked += this.scanUnicodeCodePointEscape();
                          } else {
                            var restore = this.index;
                            var unescaped_2 = this.scanHexEscape(ch);
                            if (unescaped_2 !== null) {
                              cooked += unescaped_2;
                            } else {
                              this.index = restore;
                              cooked += ch;
                            }
                          }
                          break;
                        case "x":
                          var unescaped = this.scanHexEscape(ch);
                          if (unescaped === null) {
                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                          }
                          cooked += unescaped;
                          break;
                        case "b":
                          cooked += "\b";
                          break;
                        case "f":
                          cooked += "\f";
                          break;
                        case "v":
                          cooked += "\v";
                          break;
                        default:
                          if (ch === "0") {
                            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                              this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                            }
                            cooked += "\0";
                          } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          } else {
                            cooked += ch;
                          }
                          break;
                      }
                    } else {
                      ++this.lineNumber;
                      if (ch === "\r" && this.source[this.index] === "\n") {
                        ++this.index;
                      }
                      this.lineStart = this.index;
                    }
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                    cooked += "\n";
                  } else {
                    cooked += ch;
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken();
                }
                if (!head) {
                  this.curlyStack.pop();
                }
                return {
                  type: 10,
                  value: this.source.slice(start + 1, this.index - rawOffset),
                  cooked,
                  head,
                  tail,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.testRegExp = function(pattern, flags) {
                var astralSubstitute = "\uFFFF";
                var tmp = pattern;
                var self = this;
                if (flags.indexOf("u") >= 0) {
                  tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 1114111) {
                      self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    if (codePoint <= 65535) {
                      return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                }
                try {
                  RegExp(tmp);
                } catch (e) {
                  this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(pattern, flags);
                } catch (exception) {
                  return null;
                }
              };
              Scanner2.prototype.scanRegExpBody = function() {
                var ch = this.source[this.index];
                assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                var str = this.source[this.index++];
                var classMarker = false;
                var terminated = false;
                while (!this.eof()) {
                  ch = this.source[this.index++];
                  str += ch;
                  if (ch === "\\") {
                    ch = this.source[this.index++];
                    if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    str += ch;
                  } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  } else if (classMarker) {
                    if (ch === "]") {
                      classMarker = false;
                    }
                  } else {
                    if (ch === "/") {
                      terminated = true;
                      break;
                    } else if (ch === "[") {
                      classMarker = true;
                    }
                  }
                }
                if (!terminated) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                return str.substr(1, str.length - 2);
              };
              Scanner2.prototype.scanRegExpFlags = function() {
                var str = "";
                var flags = "";
                while (!this.eof()) {
                  var ch = this.source[this.index];
                  if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                  }
                  ++this.index;
                  if (ch === "\\" && !this.eof()) {
                    ch = this.source[this.index];
                    if (ch === "u") {
                      ++this.index;
                      var restore = this.index;
                      var char = this.scanHexEscape("u");
                      if (char !== null) {
                        flags += char;
                        for (str += "\\u"; restore < this.index; ++restore) {
                          str += this.source[restore];
                        }
                      } else {
                        this.index = restore;
                        flags += "u";
                        str += "\\u";
                      }
                      this.tolerateUnexpectedToken();
                    } else {
                      str += "\\";
                      this.tolerateUnexpectedToken();
                    }
                  } else {
                    flags += ch;
                    str += ch;
                  }
                }
                return flags;
              };
              Scanner2.prototype.scanRegExp = function() {
                var start = this.index;
                var pattern = this.scanRegExpBody();
                var flags = this.scanRegExpFlags();
                var value = this.testRegExp(pattern, flags);
                return {
                  type: 9,
                  value: "",
                  pattern,
                  flags,
                  regex: value,
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start,
                  end: this.index
                };
              };
              Scanner2.prototype.lex = function() {
                if (this.eof()) {
                  return {
                    type: 2,
                    value: "",
                    lineNumber: this.lineNumber,
                    lineStart: this.lineStart,
                    start: this.index,
                    end: this.index
                  };
                }
                var cp = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(cp)) {
                  return this.scanIdentifier();
                }
                if (cp === 40 || cp === 41 || cp === 59) {
                  return this.scanPunctuator();
                }
                if (cp === 39 || cp === 34) {
                  return this.scanStringLiteral();
                }
                if (cp === 46) {
                  if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                    return this.scanNumericLiteral();
                  }
                  return this.scanPunctuator();
                }
                if (character_1.Character.isDecimalDigit(cp)) {
                  return this.scanNumericLiteral();
                }
                if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                  return this.scanTemplate();
                }
                if (cp >= 55296 && cp < 57343) {
                  if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                    return this.scanIdentifier();
                  }
                }
                return this.scanPunctuator();
              };
              return Scanner2;
            }();
            exports3.Scanner = Scanner;
          },
          /* 13 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.TokenName = {};
            exports3.TokenName[
              1
              /* BooleanLiteral */
            ] = "Boolean";
            exports3.TokenName[
              2
              /* EOF */
            ] = "<end>";
            exports3.TokenName[
              3
              /* Identifier */
            ] = "Identifier";
            exports3.TokenName[
              4
              /* Keyword */
            ] = "Keyword";
            exports3.TokenName[
              5
              /* NullLiteral */
            ] = "Null";
            exports3.TokenName[
              6
              /* NumericLiteral */
            ] = "Numeric";
            exports3.TokenName[
              7
              /* Punctuator */
            ] = "Punctuator";
            exports3.TokenName[
              8
              /* StringLiteral */
            ] = "String";
            exports3.TokenName[
              9
              /* RegularExpression */
            ] = "RegularExpression";
            exports3.TokenName[
              10
              /* Template */
            ] = "Template";
          },
          /* 14 */
          /***/
          function(module3, exports3) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.XHTMLEntities = {
              quot: '"',
              amp: "&",
              apos: "'",
              gt: ">",
              nbsp: "\xA0",
              iexcl: "\xA1",
              cent: "\xA2",
              pound: "\xA3",
              curren: "\xA4",
              yen: "\xA5",
              brvbar: "\xA6",
              sect: "\xA7",
              uml: "\xA8",
              copy: "\xA9",
              ordf: "\xAA",
              laquo: "\xAB",
              not: "\xAC",
              shy: "\xAD",
              reg: "\xAE",
              macr: "\xAF",
              deg: "\xB0",
              plusmn: "\xB1",
              sup2: "\xB2",
              sup3: "\xB3",
              acute: "\xB4",
              micro: "\xB5",
              para: "\xB6",
              middot: "\xB7",
              cedil: "\xB8",
              sup1: "\xB9",
              ordm: "\xBA",
              raquo: "\xBB",
              frac14: "\xBC",
              frac12: "\xBD",
              frac34: "\xBE",
              iquest: "\xBF",
              Agrave: "\xC0",
              Aacute: "\xC1",
              Acirc: "\xC2",
              Atilde: "\xC3",
              Auml: "\xC4",
              Aring: "\xC5",
              AElig: "\xC6",
              Ccedil: "\xC7",
              Egrave: "\xC8",
              Eacute: "\xC9",
              Ecirc: "\xCA",
              Euml: "\xCB",
              Igrave: "\xCC",
              Iacute: "\xCD",
              Icirc: "\xCE",
              Iuml: "\xCF",
              ETH: "\xD0",
              Ntilde: "\xD1",
              Ograve: "\xD2",
              Oacute: "\xD3",
              Ocirc: "\xD4",
              Otilde: "\xD5",
              Ouml: "\xD6",
              times: "\xD7",
              Oslash: "\xD8",
              Ugrave: "\xD9",
              Uacute: "\xDA",
              Ucirc: "\xDB",
              Uuml: "\xDC",
              Yacute: "\xDD",
              THORN: "\xDE",
              szlig: "\xDF",
              agrave: "\xE0",
              aacute: "\xE1",
              acirc: "\xE2",
              atilde: "\xE3",
              auml: "\xE4",
              aring: "\xE5",
              aelig: "\xE6",
              ccedil: "\xE7",
              egrave: "\xE8",
              eacute: "\xE9",
              ecirc: "\xEA",
              euml: "\xEB",
              igrave: "\xEC",
              iacute: "\xED",
              icirc: "\xEE",
              iuml: "\xEF",
              eth: "\xF0",
              ntilde: "\xF1",
              ograve: "\xF2",
              oacute: "\xF3",
              ocirc: "\xF4",
              otilde: "\xF5",
              ouml: "\xF6",
              divide: "\xF7",
              oslash: "\xF8",
              ugrave: "\xF9",
              uacute: "\xFA",
              ucirc: "\xFB",
              uuml: "\xFC",
              yacute: "\xFD",
              thorn: "\xFE",
              yuml: "\xFF",
              OElig: "\u0152",
              oelig: "\u0153",
              Scaron: "\u0160",
              scaron: "\u0161",
              Yuml: "\u0178",
              fnof: "\u0192",
              circ: "\u02C6",
              tilde: "\u02DC",
              Alpha: "\u0391",
              Beta: "\u0392",
              Gamma: "\u0393",
              Delta: "\u0394",
              Epsilon: "\u0395",
              Zeta: "\u0396",
              Eta: "\u0397",
              Theta: "\u0398",
              Iota: "\u0399",
              Kappa: "\u039A",
              Lambda: "\u039B",
              Mu: "\u039C",
              Nu: "\u039D",
              Xi: "\u039E",
              Omicron: "\u039F",
              Pi: "\u03A0",
              Rho: "\u03A1",
              Sigma: "\u03A3",
              Tau: "\u03A4",
              Upsilon: "\u03A5",
              Phi: "\u03A6",
              Chi: "\u03A7",
              Psi: "\u03A8",
              Omega: "\u03A9",
              alpha: "\u03B1",
              beta: "\u03B2",
              gamma: "\u03B3",
              delta: "\u03B4",
              epsilon: "\u03B5",
              zeta: "\u03B6",
              eta: "\u03B7",
              theta: "\u03B8",
              iota: "\u03B9",
              kappa: "\u03BA",
              lambda: "\u03BB",
              mu: "\u03BC",
              nu: "\u03BD",
              xi: "\u03BE",
              omicron: "\u03BF",
              pi: "\u03C0",
              rho: "\u03C1",
              sigmaf: "\u03C2",
              sigma: "\u03C3",
              tau: "\u03C4",
              upsilon: "\u03C5",
              phi: "\u03C6",
              chi: "\u03C7",
              psi: "\u03C8",
              omega: "\u03C9",
              thetasym: "\u03D1",
              upsih: "\u03D2",
              piv: "\u03D6",
              ensp: "\u2002",
              emsp: "\u2003",
              thinsp: "\u2009",
              zwnj: "\u200C",
              zwj: "\u200D",
              lrm: "\u200E",
              rlm: "\u200F",
              ndash: "\u2013",
              mdash: "\u2014",
              lsquo: "\u2018",
              rsquo: "\u2019",
              sbquo: "\u201A",
              ldquo: "\u201C",
              rdquo: "\u201D",
              bdquo: "\u201E",
              dagger: "\u2020",
              Dagger: "\u2021",
              bull: "\u2022",
              hellip: "\u2026",
              permil: "\u2030",
              prime: "\u2032",
              Prime: "\u2033",
              lsaquo: "\u2039",
              rsaquo: "\u203A",
              oline: "\u203E",
              frasl: "\u2044",
              euro: "\u20AC",
              image: "\u2111",
              weierp: "\u2118",
              real: "\u211C",
              trade: "\u2122",
              alefsym: "\u2135",
              larr: "\u2190",
              uarr: "\u2191",
              rarr: "\u2192",
              darr: "\u2193",
              harr: "\u2194",
              crarr: "\u21B5",
              lArr: "\u21D0",
              uArr: "\u21D1",
              rArr: "\u21D2",
              dArr: "\u21D3",
              hArr: "\u21D4",
              forall: "\u2200",
              part: "\u2202",
              exist: "\u2203",
              empty: "\u2205",
              nabla: "\u2207",
              isin: "\u2208",
              notin: "\u2209",
              ni: "\u220B",
              prod: "\u220F",
              sum: "\u2211",
              minus: "\u2212",
              lowast: "\u2217",
              radic: "\u221A",
              prop: "\u221D",
              infin: "\u221E",
              ang: "\u2220",
              and: "\u2227",
              or: "\u2228",
              cap: "\u2229",
              cup: "\u222A",
              int: "\u222B",
              there4: "\u2234",
              sim: "\u223C",
              cong: "\u2245",
              asymp: "\u2248",
              ne: "\u2260",
              equiv: "\u2261",
              le: "\u2264",
              ge: "\u2265",
              sub: "\u2282",
              sup: "\u2283",
              nsub: "\u2284",
              sube: "\u2286",
              supe: "\u2287",
              oplus: "\u2295",
              otimes: "\u2297",
              perp: "\u22A5",
              sdot: "\u22C5",
              lceil: "\u2308",
              rceil: "\u2309",
              lfloor: "\u230A",
              rfloor: "\u230B",
              loz: "\u25CA",
              spades: "\u2660",
              clubs: "\u2663",
              hearts: "\u2665",
              diams: "\u2666",
              lang: "\u27E8",
              rang: "\u27E9"
            };
          },
          /* 15 */
          /***/
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            var error_handler_1 = __webpack_require__(10);
            var scanner_1 = __webpack_require__(12);
            var token_1 = __webpack_require__(13);
            var Reader = function() {
              function Reader2() {
                this.values = [];
                this.curly = this.paren = -1;
              }
              Reader2.prototype.beforeFunctionExpression = function(t) {
                return [
                  "(",
                  "{",
                  "[",
                  "in",
                  "typeof",
                  "instanceof",
                  "new",
                  "return",
                  "case",
                  "delete",
                  "throw",
                  "void",
                  // assignment operators
                  "=",
                  "+=",
                  "-=",
                  "*=",
                  "**=",
                  "/=",
                  "%=",
                  "<<=",
                  ">>=",
                  ">>>=",
                  "&=",
                  "|=",
                  "^=",
                  ",",
                  // binary/unary operators
                  "+",
                  "-",
                  "*",
                  "**",
                  "/",
                  "%",
                  "++",
                  "--",
                  "<<",
                  ">>",
                  ">>>",
                  "&",
                  "|",
                  "^",
                  "!",
                  "~",
                  "&&",
                  "||",
                  "?",
                  ":",
                  "===",
                  "==",
                  ">=",
                  "<=",
                  "<",
                  ">",
                  "!=",
                  "!=="
                ].indexOf(t) >= 0;
              };
              Reader2.prototype.isRegexStart = function() {
                var previous = this.values[this.values.length - 1];
                var regex = previous !== null;
                switch (previous) {
                  case "this":
                  case "]":
                    regex = false;
                    break;
                  case ")":
                    var keyword = this.values[this.paren - 1];
                    regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                    break;
                  case "}":
                    regex = false;
                    if (this.values[this.curly - 3] === "function") {
                      var check = this.values[this.curly - 4];
                      regex = check ? !this.beforeFunctionExpression(check) : false;
                    } else if (this.values[this.curly - 4] === "function") {
                      var check = this.values[this.curly - 5];
                      regex = check ? !this.beforeFunctionExpression(check) : true;
                    }
                    break;
                  default:
                    break;
                }
                return regex;
              };
              Reader2.prototype.push = function(token) {
                if (token.type === 7 || token.type === 4) {
                  if (token.value === "{") {
                    this.curly = this.values.length;
                  } else if (token.value === "(") {
                    this.paren = this.values.length;
                  }
                  this.values.push(token.value);
                } else {
                  this.values.push(null);
                }
              };
              return Reader2;
            }();
            var Tokenizer = function() {
              function Tokenizer2(code, config) {
                this.errorHandler = new error_handler_1.ErrorHandler();
                this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                this.buffer = [];
                this.reader = new Reader();
              }
              Tokenizer2.prototype.errors = function() {
                return this.errorHandler.errors;
              };
              Tokenizer2.prototype.getNextToken = function() {
                if (this.buffer.length === 0) {
                  var comments = this.scanner.scanComments();
                  if (this.scanner.trackComment) {
                    for (var i = 0; i < comments.length; ++i) {
                      var e = comments[i];
                      var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                      var comment = {
                        type: e.multiLine ? "BlockComment" : "LineComment",
                        value
                      };
                      if (this.trackRange) {
                        comment.range = e.range;
                      }
                      if (this.trackLoc) {
                        comment.loc = e.loc;
                      }
                      this.buffer.push(comment);
                    }
                  }
                  if (!this.scanner.eof()) {
                    var loc = void 0;
                    if (this.trackLoc) {
                      loc = {
                        start: {
                          line: this.scanner.lineNumber,
                          column: this.scanner.index - this.scanner.lineStart
                        },
                        end: {}
                      };
                    }
                    var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                    var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(token);
                    var entry = {
                      type: token_1.TokenName[token.type],
                      value: this.scanner.source.slice(token.start, token.end)
                    };
                    if (this.trackRange) {
                      entry.range = [token.start, token.end];
                    }
                    if (this.trackLoc) {
                      loc.end = {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      };
                      entry.loc = loc;
                    }
                    if (token.type === 9) {
                      var pattern = token.pattern;
                      var flags = token.flags;
                      entry.regex = { pattern, flags };
                    }
                    this.buffer.push(entry);
                  }
                }
                return this.buffer.shift();
              };
              return Tokenizer2;
            }();
            exports3.Tokenizer = Tokenizer;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray3(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray3;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString3(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString3;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError4(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError4;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/.pnpm/array-timsort@1.0.3/node_modules/array-timsort/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/array-timsort@1.0.3/node_modules/array-timsort/src/index.js"(exports2, module2) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    var results;
    var log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }
      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }
        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }
          if (a >= 0) {
            return 1;
          }
          a = -a;
          b = -b;
        }
        const al = log10(a);
        const bl = log10(b);
        let t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) {
          return t;
        }
        return a < b ? -1 : 1;
      }
      const aStr = String(a);
      const bStr = String(b);
      if (aStr === bStr) {
        return 0;
      }
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      let r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare3) {
      let runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare3(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare3(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
        reverseRun(results, lo, runHi);
      } else {
        while (runHi < hi && compare3(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        const t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare3) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        const pivot = array[start];
        const pivotIndex = results[start];
        let left = lo;
        let right = start;
        while (left < right) {
          const mid = left + right >>> 1;
          if (compare3(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        let n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
            results[left + 3] = results[left + 2];
          /* falls through */
          case 2:
            array[left + 2] = array[left + 1];
            results[left + 2] = results[left + 1];
          /* falls through */
          case 1:
            array[left + 1] = array[left];
            results[left + 1] = results[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              results[left + n] = results[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
        results[left] = pivotIndex;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare3) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare3(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare3(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare3(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare3(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare3) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare3(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare3(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare3(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare3(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    var TimSort = class {
      constructor(array, compare3) {
        this.array = array;
        this.compare = compare3;
        const { length } = array;
        this.length = length;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
        this.tmp = new Array(this.tmpStorageLength);
        this.tmpIndex = new Array(this.tmpStorageLength);
        this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      /**
       * Push a new run on TimSort's stack.
       *
       * @param {number} runStart - Start index of the run in the original array.
       * @param {number} runLength - Length of the run;
       */
      pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      }
      /**
       * Merge runs on TimSort's stack so that the following holds for all i:
       * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
       * 2) runLength[i - 2] > runLength[i - 1]
       */
      mergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge all runs on TimSort's stack until only one remains.
       */
      forceMergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
          this.mergeAt(n);
        }
      }
      /**
       * Merge the runs on the stack at positions i and i+1. Must be always be called
       * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
       *
       * @param {number} i - Index of the run to merge in TimSort's stack.
       */
      mergeAt(i) {
        const { compare: compare3 } = this;
        const { array } = this;
        let start1 = this.runStart[i];
        let length1 = this.runLength[i];
        const start2 = this.runStart[i + 1];
        let length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        const k = gallopRight(array[start2], array, start1, length1, 0, compare3);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(
          array[start1 + length1 - 1],
          array,
          start2,
          length2,
          length2 - 1,
          compare3
        );
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length <= run2.length as it uses
       * TimSort temporary array to store run1. Use mergeHigh if run1.length >
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeLow(start1, length1, start2, length2) {
        const { compare: compare3 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
          tmpIndex[i] = results[start1 + i];
        }
        let cursor1 = 0;
        let cursor2 = start2;
        let dest = start1;
        array[dest] = array[cursor2];
        results[dest] = results[cursor2];
        dest++;
        cursor2++;
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count22 = 0;
          let exit = false;
          do {
            if (compare3(array[cursor2], tmp[cursor1]) < 0) {
              array[dest] = array[cursor2];
              results[dest] = results[cursor2];
              dest++;
              cursor2++;
              count22++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor1];
              results[dest] = tmpIndex[cursor1];
              dest++;
              cursor1++;
              count1++;
              count22 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count22) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare3);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
                results[dest + i] = tmpIndex[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor2];
            results[dest] = results[cursor2];
            dest++;
            cursor2++;
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count22 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare3);
            if (count22 !== 0) {
              for (i = 0; i < count22; i++) {
                array[dest + i] = array[cursor2 + i];
                results[dest + i] = results[cursor2 + i];
              }
              dest += count22;
              cursor2 += count22;
              length2 -= count22;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor1];
            results[dest] = tmpIndex[cursor1];
            dest++;
            cursor1++;
            if (--length1 === 1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
        } else if (length1 === 0) {
          throw new Error("mergeLow preconditions were not respected");
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
        }
      }
      /**
       * Merge two adjacent runs in a stable way. The runs must be such that the
       * first element of run1 is bigger than the first element in run2 and the
       * last element of run1 is greater than all the elements in run2.
       * The method should be called when run1.length > run2.length as it uses
       * TimSort temporary array to store run2. Use mergeLow if run1.length <=
       * run2.length.
       *
       * @param {number} start1 - First element in run1.
       * @param {number} length1 - Length of run1.
       * @param {number} start2 - First element in run2.
       * @param {number} length2 - Length of run2.
       */
      mergeHigh(start1, length1, start2, length2) {
        const { compare: compare3 } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
          tmpIndex[i] = results[start2 + i];
        }
        let cursor1 = start1 + length1 - 1;
        let cursor2 = length2 - 1;
        let dest = start2 + length2 - 1;
        let customCursor = 0;
        let customDest = 0;
        array[dest] = array[cursor1];
        results[dest] = results[cursor1];
        dest--;
        cursor1--;
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count22 = 0;
          let exit = false;
          do {
            if (compare3(tmp[cursor2], array[cursor1]) < 0) {
              array[dest] = array[cursor1];
              results[dest] = results[cursor1];
              dest--;
              cursor1--;
              count1++;
              count22 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor2];
              results[dest] = tmpIndex[cursor2];
              dest--;
              cursor2--;
              count22++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count22) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(
              tmp[cursor2],
              array,
              start1,
              length1,
              length1 - 1,
              compare3
            );
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
                results[customDest + i] = results[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor2];
            results[dest] = tmpIndex[cursor2];
            dest--;
            cursor2--;
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count22 = length2 - gallopLeft(
              array[cursor1],
              tmp,
              0,
              length2,
              length2 - 1,
              compare3
            );
            if (count22 !== 0) {
              dest -= count22;
              cursor2 -= count22;
              length2 -= count22;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count22; i++) {
                array[customDest + i] = tmp[customCursor + i];
                results[customDest + i] = tmpIndex[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor1];
            results[dest] = results[cursor1];
            dest--;
            cursor1--;
            if (--length1 === 0) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
        } else if (length2 === 0) {
          throw new Error("mergeHigh preconditions were not respected");
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
        }
      }
    };
    function sort(array, compare3, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError(
          `The "array" argument must be an array. Received ${array}`
        );
      }
      results = [];
      const { length } = array;
      let i = 0;
      while (i < length) {
        results[i] = i++;
      }
      if (!compare3) {
        compare3 = alphabeticalCompare;
      } else if (typeof compare3 !== "function") {
        hi = lo;
        lo = compare3;
        compare3 = alphabeticalCompare;
      }
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = length;
      }
      let remaining = hi - lo;
      if (remaining < 2) {
        return results;
      }
      let runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare3);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare3);
        return results;
      }
      const ts = new TimSort(array, compare3);
      const minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare3);
        if (runLength < minRun) {
          let force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare3);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
      return results;
    }
    module2.exports = {
      sort
    };
  }
});

// node_modules/.pnpm/has-own-prop@2.0.0/node_modules/has-own-prop/index.js
var require_has_own_prop = __commonJS({
  "node_modules/.pnpm/has-own-prop@2.0.0/node_modules/has-own-prop/index.js"(exports2, module2) {
    "use strict";
    var hasOwnProp = Object.prototype.hasOwnProperty;
    module2.exports = (object, property) => hasOwnProp.call(object, property);
  }
});

// node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/common.js"(exports2, module2) {
    var hasOwnProperty4 = require_has_own_prop();
    var {
      isObject,
      isArray: isArray3,
      isString: isString3,
      isNumber
    } = require_util();
    var PREFIX_BEFORE = "before";
    var PREFIX_AFTER_PROP = "after-prop";
    var PREFIX_AFTER_COLON = "after-colon";
    var PREFIX_AFTER_VALUE = "after-value";
    var PREFIX_AFTER = "after";
    var PREFIX_BEFORE_ALL = "before-all";
    var PREFIX_AFTER_ALL = "after-all";
    var BRACKET_OPEN = "[";
    var BRACKET_CLOSE = "]";
    var CURLY_BRACKET_OPEN = "{";
    var CURLY_BRACKET_CLOSE = "}";
    var COMMA = ",";
    var EMPTY = "";
    var MINUS = "-";
    var SYMBOL_PREFIXES = [
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER
    ];
    var NON_PROP_SYMBOL_KEYS = [
      PREFIX_BEFORE,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL
    ].map(Symbol.for);
    var COLON = ":";
    var UNDEFINED = void 0;
    var symbol = (prefix, key) => Symbol.for(prefix + COLON + key);
    var define2 = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
      const source_prop = symbol(prefix, source_key);
      if (!hasOwnProperty4(source, source_prop)) {
        return;
      }
      const target_prop = target_key === source_key ? source_prop : symbol(prefix, target_key);
      define2(target, target_prop, source[source_prop]);
      if (remove_source) {
        delete source[source_prop];
      }
    };
    var copy_comments = (target, source, target_key, source_key, remove_source) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        copy_comments_by_kind(
          target,
          source,
          target_key,
          source_key,
          prefix,
          remove_source
        );
      });
    };
    var swap_comments = (array, from2, to) => {
      if (from2 === to) {
        return;
      }
      SYMBOL_PREFIXES.forEach((prefix) => {
        const target_prop = symbol(prefix, to);
        if (!hasOwnProperty4(array, target_prop)) {
          copy_comments_by_kind(array, array, to, from2, prefix, true);
          return;
        }
        const comments = array[target_prop];
        delete array[target_prop];
        copy_comments_by_kind(array, array, to, from2, prefix, true);
        define2(array, symbol(prefix, from2), comments);
      });
    };
    var assign_non_prop_comments = (target, source) => {
      NON_PROP_SYMBOL_KEYS.forEach((key) => {
        const comments = source[key];
        if (comments) {
          define2(target, key, comments);
        }
      });
    };
    var assign3 = (target, source, keys3) => {
      keys3.forEach((key) => {
        if (!isString3(key) && !isNumber(key)) {
          return;
        }
        if (!hasOwnProperty4(source, key)) {
          return;
        }
        target[key] = source[key];
        copy_comments(target, source, key, key);
      });
      return target;
    };
    module2.exports = {
      SYMBOL_PREFIXES,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      symbol,
      define: define2,
      copy_comments,
      swap_comments,
      assign_non_prop_comments,
      assign(target, source, keys3) {
        if (!isObject(target)) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        if (!isObject(source)) {
          return target;
        }
        if (keys3 === UNDEFINED) {
          keys3 = Object.keys(source);
          assign_non_prop_comments(target, source);
        } else if (!isArray3(keys3)) {
          throw new TypeError("keys must be array or undefined");
        } else if (keys3.length === 0) {
          assign_non_prop_comments(target, source);
        }
        return assign3(target, source, keys3);
      }
    };
  }
});

// node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/array.js"(exports2, module2) {
    var { isArray: isArray3 } = require_util();
    var { sort } = require_src();
    var {
      SYMBOL_PREFIXES,
      UNDEFINED,
      symbol,
      copy_comments,
      swap_comments
    } = require_common();
    var reverse_comments = (array) => {
      const { length } = array;
      let i = 0;
      const max4 = length / 2;
      for (; i < max4; i++) {
        swap_comments(array, i, length - i - 1);
      }
    };
    var move_comment = (target, source, i, offset, remove) => {
      copy_comments(target, source, i + offset, i, remove);
    };
    var move_comments = (target, source, start, count3, offset, remove) => {
      if (offset > 0) {
        let i2 = count3;
        while (i2-- > 0) {
          move_comment(target, source, start + i2, offset, remove);
        }
        return;
      }
      let i = 0;
      while (i < count3) {
        const ii = i++;
        move_comment(target, source, start + ii, offset, remove);
      }
    };
    var remove_comments = (array, key) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        const prop = symbol(prefix, key);
        delete array[prop];
      });
    };
    var get_mapped = (map3, key) => {
      let mapped = key;
      while (mapped in map3) {
        mapped = map3[mapped];
      }
      return mapped;
    };
    var CommentArray = class _CommentArray extends Array {
      // - deleteCount + items.length
      // We should avoid `splice(begin, deleteCount, ...items)`,
      // because `splice(0, undefined)` is not equivalent to `splice(0)`,
      // as well as:
      // - slice
      splice(...args) {
        const { length } = this;
        const ret = super.splice(...args);
        let [begin, deleteCount, ...items] = args;
        if (begin < 0) {
          begin += length;
        }
        if (arguments.length === 1) {
          deleteCount = length - begin;
        } else {
          deleteCount = Math.min(length - begin, deleteCount);
        }
        const {
          length: item_length
        } = items;
        const offset = item_length - deleteCount;
        const start = begin + deleteCount;
        const count3 = length - start;
        move_comments(this, this, start, count3, offset, true);
        return ret;
      }
      slice(...args) {
        const { length } = this;
        const array = super.slice(...args);
        if (!array.length) {
          return new _CommentArray();
        }
        let [begin, before] = args;
        if (before === UNDEFINED) {
          before = length;
        } else if (before < 0) {
          before += length;
        }
        if (begin < 0) {
          begin += length;
        } else if (begin === UNDEFINED) {
          begin = 0;
        }
        move_comments(array, this, begin, before - begin, -begin);
        return array;
      }
      unshift(...items) {
        const { length } = this;
        const ret = super.unshift(...items);
        const {
          length: items_length
        } = items;
        if (items_length > 0) {
          move_comments(this, this, 0, length, items_length, true);
        }
        return ret;
      }
      shift() {
        const ret = super.shift();
        const { length } = this;
        remove_comments(this, 0);
        move_comments(this, this, 1, length, -1, true);
        return ret;
      }
      reverse() {
        super.reverse();
        reverse_comments(this);
        return this;
      }
      pop() {
        const ret = super.pop();
        remove_comments(this, this.length);
        return ret;
      }
      concat(...items) {
        let { length } = this;
        const ret = super.concat(...items);
        if (!items.length) {
          return ret;
        }
        move_comments(ret, this, 0, this.length, 0);
        items.forEach((item) => {
          const prev = length;
          length += isArray3(item) ? item.length : 1;
          if (!(item instanceof _CommentArray)) {
            return;
          }
          move_comments(ret, item, 0, item.length, prev);
        });
        return ret;
      }
      sort(...args) {
        const result = sort(
          this,
          ...args.slice(0, 1)
        );
        const map3 = /* @__PURE__ */ Object.create(null);
        result.forEach((source_index, index) => {
          if (source_index === index) {
            return;
          }
          const real_source_index = get_mapped(map3, source_index);
          if (real_source_index === index) {
            return;
          }
          map3[index] = real_source_index;
          swap_comments(this, index, real_source_index);
        });
        return this;
      }
    };
    module2.exports = {
      CommentArray
    };
  }
});

// node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/parse.js"(exports2, module2) {
    var esprima = require_esprima();
    var {
      CommentArray
    } = require_array();
    var {
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      define: define2,
      assign_non_prop_comments
    } = require_common();
    var tokenize = (code) => esprima.tokenize(code, {
      comment: true,
      loc: true
    });
    var previous_hosts = [];
    var comments_host = null;
    var unassigned_comments = null;
    var previous_props = [];
    var last_prop;
    var remove_comments = false;
    var inline = false;
    var tokens = null;
    var last = null;
    var current = null;
    var index;
    var reviver = null;
    var clean5 = () => {
      previous_props.length = previous_hosts.length = 0;
      last = null;
      last_prop = UNDEFINED;
    };
    var free = () => {
      clean5();
      tokens.length = 0;
      unassigned_comments = comments_host = tokens = last = current = reviver = null;
    };
    var symbolFor = (prefix) => Symbol.for(
      last_prop !== UNDEFINED ? prefix + COLON + last_prop : prefix
    );
    var transform2 = (k, v) => reviver ? reviver(k, v) : v;
    var unexpected = () => {
      const error = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
      Object.assign(error, current.loc.start);
      throw error;
    };
    var unexpected_end = () => {
      const error = new SyntaxError("Unexpected end of JSON input");
      Object.assign(error, last ? last.loc.end : {
        line: 1,
        column: 0
      });
      throw error;
    };
    var next = () => {
      const new_token = tokens[++index];
      inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
      last = current;
      current = new_token;
    };
    var type = () => {
      if (!current) {
        unexpected_end();
      }
      return current.type === "Punctuator" ? current.value : current.type;
    };
    var is = (t) => type() === t;
    var expect = (a) => {
      if (!is(a)) {
        unexpected();
      }
    };
    var set_comments_host = (new_host) => {
      previous_hosts.push(comments_host);
      comments_host = new_host;
    };
    var restore_comments_host = () => {
      comments_host = previous_hosts.pop();
    };
    var assign_after_comments = () => {
      if (!unassigned_comments) {
        return;
      }
      const after_comments = [];
      for (const comment of unassigned_comments) {
        if (comment.inline) {
          after_comments.push(comment);
        } else {
          break;
        }
      }
      const { length } = after_comments;
      if (!length) {
        return;
      }
      if (length === unassigned_comments.length) {
        unassigned_comments = null;
      } else {
        unassigned_comments.splice(0, length);
      }
      define2(comments_host, symbolFor(PREFIX_AFTER), after_comments);
    };
    var assign_comments = (prefix) => {
      if (!unassigned_comments) {
        return;
      }
      define2(comments_host, symbolFor(prefix), unassigned_comments);
      unassigned_comments = null;
    };
    var parse_comments = (prefix) => {
      const comments = [];
      while (current && (is("LineComment") || is("BlockComment"))) {
        const comment = {
          ...current,
          inline
        };
        comments.push(comment);
        next();
      }
      if (remove_comments) {
        return;
      }
      if (!comments.length) {
        return;
      }
      if (prefix) {
        define2(comments_host, symbolFor(prefix), comments);
        return;
      }
      unassigned_comments = comments;
    };
    var set_prop = (prop, push) => {
      if (push) {
        previous_props.push(last_prop);
      }
      last_prop = prop;
    };
    var restore_prop = () => {
      last_prop = previous_props.pop();
    };
    var parse_object = () => {
      const obj = {};
      set_comments_host(obj);
      set_prop(UNDEFINED, true);
      let started = false;
      let name;
      parse_comments();
      while (!is(CURLY_BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(CURLY_BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        expect("String");
        name = JSON.parse(current.value);
        set_prop(name);
        assign_comments(PREFIX_BEFORE);
        next();
        parse_comments(PREFIX_AFTER_PROP);
        expect(COLON);
        next();
        parse_comments(PREFIX_AFTER_COLON);
        obj[name] = transform2(name, walk3());
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return obj;
    };
    var parse_array = () => {
      const array = new CommentArray();
      set_comments_host(array);
      set_prop(UNDEFINED, true);
      let started = false;
      let i = 0;
      parse_comments();
      while (!is(BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        set_prop(i);
        assign_comments(PREFIX_BEFORE);
        array[i] = transform2(i, walk3());
        i++;
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return array;
    };
    function walk3() {
      let tt = type();
      if (tt === CURLY_BRACKET_OPEN) {
        next();
        return parse_object();
      }
      if (tt === BRACKET_OPEN) {
        next();
        return parse_array();
      }
      let negative = EMPTY;
      if (tt === MINUS) {
        next();
        tt = type();
        negative = MINUS;
      }
      let v;
      switch (tt) {
        case "String":
        case "Boolean":
        case "Null":
        case "Numeric":
          v = current.value;
          next();
          return JSON.parse(negative + v);
        default:
      }
    }
    var isObject = (subject) => Object(subject) === subject;
    var parse3 = (code, rev, no_comments) => {
      clean5();
      tokens = tokenize(code);
      reviver = rev;
      remove_comments = no_comments;
      if (!tokens.length) {
        unexpected_end();
      }
      index = -1;
      next();
      set_comments_host({});
      parse_comments(PREFIX_BEFORE_ALL);
      let result = walk3();
      parse_comments(PREFIX_AFTER_ALL);
      if (current) {
        unexpected();
      }
      if (!no_comments && result !== null) {
        if (!isObject(result)) {
          result = new Object(result);
        }
        assign_non_prop_comments(result, comments_host);
      }
      restore_comments_host();
      result = transform2("", result);
      free();
      return result;
    };
    module2.exports = {
      parse: parse3,
      tokenize
    };
  }
});

// node_modules/.pnpm/repeat-string@1.6.1/node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/.pnpm/repeat-string@1.6.1/node_modules/repeat-string/index.js"(exports2, module2) {
    "use strict";
    var res = "";
    var cache4;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1) return str;
      if (num === 2) return str + str;
      var max4 = str.length * num;
      if (cache4 !== str || typeof cache4 === "undefined") {
        cache4 = str;
        res = "";
      } else if (res.length >= max4) {
        return res.substr(0, max4);
      }
      while (max4 > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max4);
      return res;
    }
  }
});

// node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/stringify.js"(exports2, module2) {
    var {
      isArray: isArray3,
      isObject,
      isFunction,
      isNumber,
      isString: isString3
    } = require_util();
    var repeat = require_repeat_string();
    var {
      PREFIX_BEFORE_ALL,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      EMPTY,
      UNDEFINED
    } = require_common();
    var ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var SPACE = " ";
    var LF2 = "\n";
    var STR_NULL = "null";
    var BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
    var AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
    var AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
    var AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
    var AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var escape = (string) => {
      ESCAPABLE.lastIndex = 0;
      if (!ESCAPABLE.test(string)) {
        return string;
      }
      return string.replace(ESCAPABLE, (a) => {
        const c = meta[a];
        return typeof c === "string" ? c : a;
      });
    };
    var quote = (string) => `"${escape(string)}"`;
    var comment_stringify = (value, line) => line ? `//${value}` : `/*${value}*/`;
    var process_comments = (host, symbol_tag, deeper_gap, display_block) => {
      const comments = host[Symbol.for(symbol_tag)];
      if (!comments || !comments.length) {
        return EMPTY;
      }
      let is_line_comment = false;
      const str = comments.reduce((prev, {
        inline,
        type,
        value
      }) => {
        const delimiter = inline ? SPACE : LF2 + deeper_gap;
        is_line_comment = type === "LineComment";
        return prev + delimiter + comment_stringify(value, is_line_comment);
      }, EMPTY);
      return display_block || is_line_comment ? str + LF2 + deeper_gap : str;
    };
    var replacer = null;
    var indent = EMPTY;
    var clean5 = () => {
      replacer = null;
      indent = EMPTY;
    };
    var join4 = (one, two, gap) => one ? two ? one + two.trim() + LF2 + gap : one.trimRight() + LF2 + gap : two ? two.trimRight() + LF2 + gap : EMPTY;
    var join_content = (inside, value, gap) => {
      const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true);
      return join4(comment, inside, gap);
    };
    var array_stringify = (value, gap) => {
      const deeper_gap = gap + indent;
      const { length } = value;
      let inside = EMPTY;
      let after_comma = EMPTY;
      for (let i = 0; i < length; i++) {
        if (i !== 0) {
          inside += COMMA;
        }
        const before = join4(
          after_comma,
          process_comments(value, BEFORE(i), deeper_gap),
          deeper_gap
        );
        inside += before || LF2 + deeper_gap;
        inside += stringify3(i, value, deeper_gap) || STR_NULL;
        inside += process_comments(value, AFTER_VALUE(i), deeper_gap);
        after_comma = process_comments(value, AFTER(i), deeper_gap);
      }
      inside += join4(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return BRACKET_OPEN + join_content(inside, value, gap) + BRACKET_CLOSE;
    };
    var object_stringify = (value, gap) => {
      if (!value) {
        return "null";
      }
      const deeper_gap = gap + indent;
      let inside = EMPTY;
      let after_comma = EMPTY;
      let first3 = true;
      const keys3 = isArray3(replacer) ? replacer : Object.keys(value);
      const iteratee = (key) => {
        const sv = stringify3(key, value, deeper_gap);
        if (sv === UNDEFINED) {
          return;
        }
        if (!first3) {
          inside += COMMA;
        }
        first3 = false;
        const before = join4(
          after_comma,
          process_comments(value, BEFORE(key), deeper_gap),
          deeper_gap
        );
        inside += before || LF2 + deeper_gap;
        inside += quote(key) + process_comments(value, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value, AFTER_VALUE(key), deeper_gap);
        after_comma = process_comments(value, AFTER(key), deeper_gap);
      };
      keys3.forEach(iteratee);
      inside += join4(
        after_comma,
        process_comments(value, PREFIX_AFTER, deeper_gap),
        deeper_gap
      );
      return CURLY_BRACKET_OPEN + join_content(inside, value, gap) + CURLY_BRACKET_CLOSE;
    };
    function stringify3(key, holder, gap) {
      let value = holder[key];
      if (isObject(value) && isFunction(value.toJSON)) {
        value = value.toJSON(key);
      }
      if (isFunction(replacer)) {
        value = replacer.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return Number.isFinite(value) ? String(value) : STR_NULL;
        case "boolean":
        case "null":
          return String(value);
        // If the type is 'object', we might be dealing with an object or an array or
        // null.
        case "object":
          return isArray3(value) ? array_stringify(value, gap) : object_stringify(value, gap);
        // undefined
        default:
      }
    }
    var get_indent = (space) => isString3(space) ? space : isNumber(space) ? repeat(SPACE, space) : EMPTY;
    var { toString } = Object.prototype;
    var PRIMITIVE_OBJECT_TYPES = [
      "[object Number]",
      "[object String]",
      "[object Boolean]"
    ];
    var is_primitive_object = (subject) => {
      if (typeof subject !== "object") {
        return false;
      }
      const str = toString.call(subject);
      return PRIMITIVE_OBJECT_TYPES.includes(str);
    };
    module2.exports = (value, replacer_, space) => {
      const indent_ = get_indent(space);
      if (!indent_) {
        return JSON.stringify(value, replacer_);
      }
      if (!isFunction(replacer_) && !isArray3(replacer_)) {
        replacer_ = null;
      }
      replacer = replacer_;
      indent = indent_;
      const str = is_primitive_object(value) ? JSON.stringify(value) : stringify3("", { "": value }, EMPTY);
      clean5();
      return isObject(value) ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight() : str;
    };
  }
});

// node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/comment-json@4.2.5/node_modules/comment-json/src/index.js"(exports2, module2) {
    var { parse: parse3, tokenize } = require_parse3();
    var stringify3 = require_stringify2();
    var { CommentArray } = require_array();
    var { assign: assign3 } = require_common();
    module2.exports = {
      parse: parse3,
      stringify: stringify3,
      tokenize,
      CommentArray,
      assign: assign3
    };
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path13) {
      const ctrl = callVisitor(key, node, visitor, path13);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path13, ctrl);
        return visit_(key, ctrl, visitor, path13);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path13 = Object.freeze(path13.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path13);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path13 = Object.freeze(path13.concat(node));
          const ck = visit_("key", node.key, visitor, path13);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path13);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path13) {
      const ctrl = await callVisitor(key, node, visitor, path13);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path13, ctrl);
        return visitAsync_(key, ctrl, visitor, path13);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path13 = Object.freeze(path13.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path13);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path13 = Object.freeze(path13.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path13);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path13);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path13) {
      var _a3, _b, _c, _d, _e;
      if (typeof visitor === "function")
        return visitor(key, node, path13);
      if (identity.isMap(node))
        return (_a3 = visitor.Map) == null ? void 0 : _a3.call(visitor, key, node, path13);
      if (identity.isSeq(node))
        return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path13);
      if (identity.isPair(node))
        return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path13);
      if (identity.isScalar(node))
        return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path13);
      if (identity.isAlias(node))
        return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path13);
      return void 0;
    }
    function replaceNode(key, path13, node) {
      const parent = path13[path13.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars2 = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars2[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count: count3, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count3);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count3 = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count3)
            count3 = c;
        }
        return count3;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match2 = tags.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) ?? match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => {
        var _a3;
        return ((_a3 = t.identify) == null ? void 0 : _a3.call(t, value)) && !t.format;
      });
    }
    function createNode(value, tagName, ctx) {
      var _a3, _b, _c;
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map3 = (_b = (_a3 = ctx.schema[identity.MAP]).createNode) == null ? void 0 : _b.call(_a3, ctx.schema, null, ctx);
        map3.items.push(value);
        return map3;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName == null ? void 0 : tagName.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path13, value) {
      let v = value;
      for (let i = path13.length - 1; i >= 0; --i) {
        const k = path13[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path13) => path13 == null || typeof path13 === "object" && !!path13[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path13, value) {
        if (isEmptyPath(path13))
          this.add(value);
        else {
          const [key, ...rest] = path13;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path13) {
        const [key, ...rest] = path13;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path13, keepScalar) {
        const [key, ...rest] = path13;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path13) {
        const [key, ...rest] = path13;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path13, value) {
        const [key, ...rest] = path13;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split2 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split2 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split2 = i;
          }
          if (i >= end) {
            if (split2) {
              folds.push(split2);
              end = split2 + endStep;
              split2 = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split2 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${start}${value}${end}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => {
          var _a3;
          return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a3 = tag.test) == null ? void 0 : _a3.test(str));
        };
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      var _a3;
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) ?? match2[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        const match2 = tags.filter((t) => {
          var _a4;
          return (_a4 = t.identify) == null ? void 0 : _a4.call(t, obj);
        });
        tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = ((_a3 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a3.name) ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify3(item, ctx, onComment, onChompKeep) {
      var _a3;
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if ((_a3 = ctx.resolvedAliases) == null ? void 0 : _a3.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify3;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify3 = require_stringify3();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify3.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify3.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    function debug2(logLevel, ...messages2) {
      if (logLevel === "debug")
        console.log(...messages2);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug2;
    exports2.warn = warn;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log2 = require_log();
    var stringify3 = require_stringify3();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map3, { key, value }) {
      if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (identity.isSeq(value))
          for (const it of value.items)
            mergeToJSMap(ctx, map3, it);
        else if (Array.isArray(value))
          for (const it of value)
            mergeToJSMap(ctx, map3, it);
        else
          mergeToJSMap(ctx, map3, value);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map3 instanceof Map) {
          map3.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map3 instanceof Set) {
          map3.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map3)
            Object.defineProperty(map3, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map3[stringKey] = jsValue;
        }
      }
      return map3;
    }
    var isMergeKey = (key) => key === MERGE_KEY || identity.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map3, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map3 instanceof Map) {
          if (!map3.has(key))
            map3.set(key, value2);
        } else if (map3 instanceof Set) {
          map3.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
          Object.defineProperty(map3, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map3;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
        const strCtx = stringify3.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return (ctx == null ? void 0 : ctx.doc) ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify3 = require_stringify3();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify4(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify3.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify3.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map3 = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map3.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map3.items.sort(schema.sortMapEntries);
        }
        return map3;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        var _a3;
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair == null ? void 0 : pair.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = (_a3 = this.schema) == null ? void 0 : _a3.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it == null ? void 0 : it.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map3 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map3, item);
        return map3;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map3 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map4, onError) {
        if (!identity.isMap(map4))
          onError("Expected a mapping for this tag");
        return map4;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map3;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          return false;
        const del = this.items.splice(idx2, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          return void 0;
        const it = this.items[idx2];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx2 = asItemIndex(key);
        return typeof idx2 === "number" && idx2 < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx2 = asItemIndex(key);
        if (typeof idx2 !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx2];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx2] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx2 = identity.isScalar(key) ? key.value : key;
      if (idx2 && typeof idx2 === "string")
        idx2 = Number(idx2);
      return typeof idx2 === "number" && Number.isInteger(idx2) && idx2 >= 0 ? idx2 : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format: format3, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format3 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map3 = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map3.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys3 = Object.keys(it);
            if (keys3.length === 1) {
              key = keys3[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys3.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(map3);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value);
        }
        return map3;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map3, onError) {
        if (identity.isMap(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match2 = str.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map3.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map3 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map3.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map3.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys3 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys3} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string")
          return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        const keys3 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys3}`);
      });
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map3 = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge4, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.merge = !!merge4;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map3.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify3 = require_stringify3();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      var _a3;
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify3.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify3.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify3.stringify(doc.contents, ctx));
      }
      if ((_a3 = doc.directives) == null ? void 0 : _a3.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options == null ? void 0 : options._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path13, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path13, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path13) {
        if (Collection.isEmptyPath(path13)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path13) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path13, keepScalar) {
        if (Collection.isEmptyPath(path13))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path13, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path13) {
        if (Collection.isEmptyPath(path13))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path13) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path13, value) {
        if (Collection.isEmptyPath(path13)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path13), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path13, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new directives.Directives({ version: version2 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count: count3, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count3);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count3 = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count3 = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count3);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || (next == null ? void 0 : next.type) !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || (next == null ? void 0 : next.type) === "block-map" || (next == null ? void 0 : next.type) === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if ((fc == null ? void 0 : fc.type) === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      var _a3;
      const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLMap.YAMLMap;
      const map3 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep3, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? (sep3 == null ? void 0 : sep3[0]),
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep3) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map3.comment)
                map3.comment += "\n" + keyProps.comment;
              else
                map3.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (((_a3 = keyProps.found) == null ? void 0 : _a3.indent) !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep3 ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep3, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map3.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map3.range = [bm.offset, offset, commentEnd ?? offset];
      return map3;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep3 = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep3 + cb;
              sep3 = "";
              break;
            }
            case "newline":
              if (comment)
                sep3 += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep3, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? (sep3 == null ? void 0 : sep3[0]),
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep3 && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep3 && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep3, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          const valueProps = resolveProps.resolveProps(sep3 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep3)
                for (const st of sep3) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep3, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map3 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map3.items.push(pair);
          } else {
            const map3 = new YAMLMap.YAMLMap(ctx.schema);
            map3.flow = true;
            map3.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map3.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map3);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      var _a3;
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt == null ? void 0 : kt.collection) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = ((_a3 = tag.resolve) == null ? void 0 : _a3.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag == null ? void 0 : tag.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep3 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep3 + indent.slice(trimIndent) + content;
          sep3 = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep3 === " ")
            sep3 = "\n";
          else if (!prevMoreIndented && sep3 === "\n")
            sep3 = "\n\n";
          value += sep3 + indent.slice(trimIndent) + content;
          sep3 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep3 === "\n")
            value += "\n";
          else
            sep3 = "\n";
        } else {
          value += sep3 + content;
          sep3 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split2 = source.split(/\n( *)/);
      const first3 = split2[0];
      const m = first3.match(/^( *)/);
      const line0 = (m == null ? void 0 : m[1]) ? [m[1], first3.slice(m[1].length)] : ["", first3];
      const lines = [line0];
      for (let i = 1; i < split2.length; i += 2)
        lines.push([split2[i], split2[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first3, line;
      try {
        first3 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first3 = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match2 = first3.exec(source);
      if (!match2)
        return source;
      let res = match2[1];
      let sep3 = " ";
      let pos = first3.lastIndex;
      line.lastIndex = pos;
      while (match2 = line.exec(source)) {
        if (match2[1] === "") {
          if (sep3 === "\n")
            res += sep3;
          else
            sep3 = "\n";
        } else {
          res += sep3 + match2[1];
          sep3 = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match2 = last.exec(source);
      return res + sep3 + ((match2 == null ? void 0 : match2[1]) ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      var _a3;
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if ((_a3 = tag.test) == null ? void 0 : _a3.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => {
        var _a3;
        return tag2.default && ((_a3 = tag2.test) == null ? void 0 : _a3.test(value));
      }) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => {
          var _a3;
          return tag2.default && ((_a3 = tag2.test) == null ? void 0 : _a3.test(value));
        }) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while ((st == null ? void 0 : st.type) === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? (end == null ? void 0 : end[0]),
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      var _a3;
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (((_a3 = prelude[i + 1]) == null ? void 0 : _a3[0]) !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify3 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep3, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep3)
        for (const st of sep3)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify3;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path13) => {
      let item = cst;
      for (const [field, index] of path13) {
        const tok = item == null ? void 0 : item[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path13) => {
      const parent = visit.itemAtPath(cst, path13.slice(0, -1));
      const field = path13[path13.length - 1][0];
      const coll = parent == null ? void 0 : parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path13, item, visitor) {
      let ctrl = visitor(item, path13);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path13.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path13);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path13) : ctrl;
    }
    exports2.visit = visit;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty2(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty2(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty2(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty2(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty2(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token == null ? void 0 : token.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      var _a3;
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (((_a3 = prev[++i]) == null ? void 0 : _a3.type) === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep3;
          if (scalar.end) {
            sep3 = scalar.end;
            sep3.push(this.sourceToken);
            delete scalar.end;
          } else
            sep3 = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep3 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        var _a3;
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = (_a3 = prev == null ? void 0 : prev.value) == null ? void 0 : _a3.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep3 = it.sep;
                  sep3.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep3 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs8 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs8, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs8);
              } else {
                Object.assign(it, { key: fs8, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        var _a3;
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = (_a3 = prev == null ? void 0 : prev.value) == null ? void 0 : _a3.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs8 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs8, sep: [] });
              else if (it.sep)
                this.stack.push(fs8);
              else
                Object.assign(it, { key: fs8, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep3 = fc.end.splice(1, fc.end.length);
            sep3.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep3 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log2 = require_log();
    var lineCounter = require_line_counter();
    var parser2 = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser2.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser2.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse3(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify3(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse3;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify3;
  }
});

// node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/yaml@2.5.1/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser2 = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser2.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/.pnpm/callsites@3.1.0/node_modules/callsites/index.js"(exports2, module2) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module2.exports = callsites;
    module2.exports.default = callsites;
  }
});

// node_modules/.pnpm/parent-module@2.0.0/node_modules/parent-module/index.js
var require_parent_module = __commonJS({
  "node_modules/.pnpm/parent-module@2.0.0/node_modules/parent-module/index.js"(exports2, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filePath) => {
      const stacks = callsites();
      if (!filePath) {
        return stacks[2].getFileName();
      }
      let hasSeenValue = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilePath = stack.getFileName();
        if (typeof parentFilePath !== "string") {
          continue;
        }
        if (parentFilePath === filePath) {
          hasSeenValue = true;
          continue;
        }
        if (parentFilePath === "module.js") {
          continue;
        }
        if (hasSeenValue && parentFilePath !== filePath) {
          return parentFilePath;
        }
      }
    };
  }
});

// node_modules/.pnpm/clear-module@4.1.2/node_modules/clear-module/index.js
var require_clear_module = __commonJS({
  "node_modules/.pnpm/clear-module@4.1.2/node_modules/clear-module/index.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var resolveFrom2 = require_resolve_from();
    var parentModule = require_parent_module();
    var resolve3 = (moduleId) => {
      try {
        return resolveFrom2(path13.dirname(parentModule(__filename)), moduleId);
      } catch (_) {
      }
    };
    var clear = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      const filePath = resolve3(moduleId);
      if (!filePath) {
        return;
      }
      if (require.cache[filePath] && require.cache[filePath].parent) {
        let i = require.cache[filePath].parent.children.length;
        while (i--) {
          if (require.cache[filePath].parent.children[i].id === filePath) {
            require.cache[filePath].parent.children.splice(i, 1);
          }
        }
      }
      if (require.cache[filePath]) {
        const children = require.cache[filePath].children.map((child) => child.id);
        delete require.cache[filePath];
        for (const id of children) {
          clear(id);
        }
      }
    };
    clear.all = () => {
      const directory = path13.dirname(parentModule(__filename));
      for (const moduleId of Object.keys(require.cache)) {
        delete require.cache[resolveFrom2(directory, moduleId)];
      }
    };
    clear.match = (regex) => {
      for (const moduleId of Object.keys(require.cache)) {
        if (regex.test(moduleId)) {
          clear(moduleId);
        }
      }
    };
    clear.single = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
      }
      delete require.cache[resolve3(moduleId)];
    };
    module2.exports = clear;
  }
});

// node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js
var require_resolve_from2 = __commonJS({
  "node_modules/.pnpm/resolve-from@4.0.0/node_modules/resolve-from/index.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var Module = require("module");
    var fs8 = require("fs");
    var resolveFrom2 = (fromDir, moduleId, silent) => {
      if (typeof fromDir !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDir = fs8.realpathSync(fromDir);
      } catch (err) {
        if (err.code === "ENOENT") {
          fromDir = path13.resolve(fromDir);
        } else if (silent) {
          return null;
        } else {
          throw err;
        }
      }
      const fromFile = path13.join(fromDir, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (err) {
          return null;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId);
    module2.exports.silent = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId, true);
  }
});

// node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js
var require_parent_module2 = __commonJS({
  "node_modules/.pnpm/parent-module@1.0.1/node_modules/parent-module/index.js"(exports2, module2) {
    "use strict";
    var callsites = require_callsites();
    module2.exports = (filepath) => {
      const stacks = callsites();
      if (!filepath) {
        return stacks[2].getFileName();
      }
      let seenVal = false;
      stacks.shift();
      for (const stack of stacks) {
        const parentFilepath = stack.getFileName();
        if (typeof parentFilepath !== "string") {
          continue;
        }
        if (parentFilepath === filepath) {
          seenVal = true;
          continue;
        }
        if (parentFilepath === "module.js") {
          continue;
        }
        if (seenVal && parentFilepath !== filepath) {
          return parentFilepath;
        }
      }
    };
  }
});

// node_modules/.pnpm/import-fresh@3.3.0/node_modules/import-fresh/index.js
var require_import_fresh = __commonJS({
  "node_modules/.pnpm/import-fresh@3.3.0/node_modules/import-fresh/index.js"(exports2, module2) {
    "use strict";
    var path13 = require("path");
    var resolveFrom2 = require_resolve_from2();
    var parentModule = require_parent_module2();
    module2.exports = (moduleId) => {
      if (typeof moduleId !== "string") {
        throw new TypeError("Expected a string");
      }
      const parentPath = parentModule(__filename);
      const cwd = parentPath ? path13.dirname(parentPath) : __dirname;
      const filePath = resolveFrom2(cwd, moduleId);
      const oldModule = require.cache[filePath];
      if (oldModule && oldModule.parent) {
        let i = oldModule.parent.children.length;
        while (i--) {
          if (oldModule.parent.children[i].id === filePath) {
            oldModule.parent.children.splice(i, 1);
          }
        }
      }
      delete require.cache[filePath];
      const parent = require.cache[parentPath];
      return parent === void 0 ? require(filePath) : parent.require(filePath);
    };
  }
});

// node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/configFields.js
var require_configFields = __commonJS({
  "node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/configFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigFields = void 0;
    exports2.ConfigFields = {
      allowCompoundWords: "allowCompoundWords",
      cache: "cache",
      caseSensitive: "caseSensitive",
      description: "description",
      dictionaries: "dictionaries",
      dictionaryDefinitions: "dictionaryDefinitions",
      enabled: "enabled",
      enabledLanguageIds: "enabledLanguageIds",
      enableFiletypes: "enableFiletypes",
      enabledFileTypes: "enabledFileTypes",
      enableGlobDot: "enableGlobDot",
      failFast: "failFast",
      features: "features",
      files: "files",
      flagWords: "flagWords",
      gitignoreRoot: "gitignoreRoot",
      globRoot: "globRoot",
      ignorePaths: "ignorePaths",
      ignoreRegExpList: "ignoreRegExpList",
      ignoreWords: "ignoreWords",
      import: "import",
      includeRegExpList: "includeRegExpList",
      language: "language",
      languageId: "languageId",
      languageSettings: "languageSettings",
      loadDefaultConfiguration: "loadDefaultConfiguration",
      maxDuplicateProblems: "maxDuplicateProblems",
      maxNumberOfProblems: "maxNumberOfProblems",
      minWordLength: "minWordLength",
      name: "name",
      noConfigSearch: "noConfigSearch",
      noSuggestDictionaries: "noSuggestDictionaries",
      numSuggestions: "numSuggestions",
      overrides: "overrides",
      patterns: "patterns",
      pnpFiles: "pnpFiles",
      readonly: "readonly",
      reporters: "reporters",
      showStatus: "showStatus",
      spellCheckDelayMs: "spellCheckDelayMs",
      suggestionNumChanges: "suggestionNumChanges",
      suggestionsTimeout: "suggestionsTimeout",
      suggestWords: "suggestWords",
      useGitignore: "useGitignore",
      usePnP: "usePnP",
      userWords: "userWords",
      validateDirectives: "validateDirectives",
      words: "words",
      // Experimental
      parser: "parser"
    };
  }
});

// node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/CSpellReporter.js
var require_CSpellReporter = __commonJS({
  "node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/CSpellReporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageTypes = exports2.IssueType = void 0;
    var IssueType3;
    (function(IssueType4) {
      IssueType4[IssueType4["spelling"] = 0] = "spelling";
      IssueType4[IssueType4["directive"] = 1] = "directive";
    })(IssueType3 || (exports2.IssueType = IssueType3 = {}));
    exports2.MessageTypes = {
      Debug: "Debug",
      Info: "Info",
      Warning: "Warning"
    };
  }
});

// node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/defineConfig.js
var require_defineConfig = __commonJS({
  "node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/defineConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineConfig = defineConfig;
    function defineConfig(config) {
      return config;
    }
  }
});

// node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineConfig = exports2.MessageTypes = exports2.IssueType = exports2.ConfigFields = void 0;
    var configFields_js_1 = require_configFields();
    Object.defineProperty(exports2, "ConfigFields", { enumerable: true, get: function() {
      return configFields_js_1.ConfigFields;
    } });
    var CSpellReporter_js_1 = require_CSpellReporter();
    Object.defineProperty(exports2, "IssueType", { enumerable: true, get: function() {
      return CSpellReporter_js_1.IssueType;
    } });
    Object.defineProperty(exports2, "MessageTypes", { enumerable: true, get: function() {
      return CSpellReporter_js_1.MessageTypes;
    } });
    var defineConfig_js_1 = require_defineConfig();
    Object.defineProperty(exports2, "defineConfig", { enumerable: true, get: function() {
      return defineConfig_js_1.defineConfig;
    } });
  }
});

// src/server.ts
var import_node3 = __toESM(require_node3());

// src/init.ts
var import_node = __toESM(require_node3());

// node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version2) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version2;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument(uri, languageId, version2, content);
  }
  TextDocument2.create = create;
  function update(document, changes, version2) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version2);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits2(document, edits) {
    const text = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits2;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare3) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare3);
  mergeSort(right, compare3);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare3(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset2 = 0) {
  const result = isAtLineStart ? [textOffset2] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset2 + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  CompoundWordsMethod: () => CompoundWordsMethod,
  DocumentValidator: () => DocumentValidator,
  ENV_CSPELL_GLOB_ROOT: () => ENV_CSPELL_GLOB_ROOT,
  ExclusionHelper: () => exclusionHelper_exports,
  FSCapabilityFlags: () => FSCapabilityFlags,
  FeatureFlags: () => FeatureFlags,
  ImportError: () => ImportError,
  IncludeExcludeFlag: () => IncludeExcludeFlag,
  Link: () => index_link_exports,
  SpellingDictionaryLoadError: () => SpellingDictionaryLoadError,
  SuggestionError: () => SuggestionError,
  Text: () => textApi_exports,
  UnknownFeatureFlagError: () => UnknownFeatureFlagError,
  asyncIterableToArray: () => toArray,
  calcOverrideSettings: () => calcOverrideSettings,
  checkFilenameMatchesGlob: () => checkFilenameMatchesExcludeGlob,
  checkText: () => checkText,
  checkTextDocument: () => checkTextDocument,
  clearCachedFiles: () => clearCachedFiles,
  clearCaches: () => clearCaches,
  combineTextAndLanguageSettings: () => combineTextAndLanguageSettings,
  constructSettingsForText: () => combineTextAndLanguageSettings,
  createConfigLoader: () => createConfigLoader,
  createPerfTimer: () => createPerfTimer2,
  createSpellingDictionary: () => createSpellingDictionary,
  createSpellingDictionaryCollection: () => createCollection,
  createTextDocument: () => createTextDocument,
  currentSettingsFileVersion: () => currentSettingsFileVersion,
  defaultConfigFilenames: () => defaultConfigFilenames,
  defaultFileName: () => defaultFileName,
  defaultSettingsFilename: () => defaultFileName,
  determineFinalDocumentSettings: () => determineFinalDocumentSettings,
  extractDependencies: () => extractDependencies,
  extractImportErrors: () => extractImportErrors,
  fileToDocument: () => fileToDocument,
  fileToTextDocument: () => fileToTextDocument,
  finalizeSettings: () => finalizeSettings,
  getCachedFileSize: () => getCachedFileSize,
  getDefaultBundledSettingsAsync: () => getDefaultBundledSettingsAsync,
  getDefaultConfigLoader: () => getDefaultConfigLoader,
  getDefaultSettings: () => getDefaultSettings,
  getDictionary: () => getDictionary,
  getGlobalSettings: () => getGlobalSettings,
  getGlobalSettingsAsync: () => getGlobalSettingsAsync,
  getLanguageIdsForBaseFilename: () => findMatchingFileTypes,
  getLanguagesForExt: () => getFileTypesForExt,
  getLogger: () => getLogger,
  getSources: () => getSources,
  getSystemFeatureFlags: () => getSystemFeatureFlags,
  getVirtualFS: () => getVirtualFS,
  isBinaryFile: () => isBinaryFile2,
  isSpellingDictionaryLoadError: () => isSpellingDictionaryLoadError,
  loadConfig: () => loadConfig,
  loadPnP: () => loadPnP,
  mergeInDocSettings: () => mergeInDocSettings,
  mergeSettings: () => mergeSettings,
  readFile: () => readFileText,
  readFileSync: () => readFileTextSync,
  readRawSettings: () => readRawSettings,
  readSettings: () => readSettings,
  readSettingsFiles: () => readSettingsFiles,
  refreshDictionaryCache: () => refreshDictionaryCache,
  resolveFile: () => resolveFile,
  searchForConfig: () => searchForConfig,
  sectionCSpell: () => sectionCSpell,
  setLogger: () => setLogger,
  shouldCheckDocument: () => shouldCheckDocument,
  spellCheckDocument: () => spellCheckDocument,
  spellCheckFile: () => spellCheckFile,
  suggestionsForWord: () => suggestionsForWord,
  suggestionsForWords: () => suggestionsForWords,
  traceWords: () => traceWords,
  traceWordsAsync: () => traceWordsAsync,
  updateTextDocument: () => updateTextDocument,
  validateText: () => validateText2,
  writeToFile: () => writeToFile,
  writeToFileIterable: () => writeToFileIterable,
  writeToFileIterableP: () => writeToFileIterable
});

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/errors.js
var import_node_util = require("util");
var allowStringOrUndefined = {
  string: true,
  undefined: true
};
function isError(e) {
  if (e instanceof Error)
    return true;
  if (!e || typeof e !== "object")
    return false;
  const ex = e;
  return typeof ex.name == "string" && typeof ex.message == "string" && typeof ex.stack in allowStringOrUndefined;
}
function toError(e, errorFactory = UnknownError) {
  if (isError(e))
    return e;
  return new errorFactory(e);
}
var UnknownError = class extends Error {
  cause;
  constructor(cause) {
    super((0, import_node_util.format)(cause));
    this.cause = cause;
  }
};
function catchPromiseError(p, handler) {
  if (p === void 0)
    return void 0;
  return _catchPromiseError(p, handler);
}
async function _catchPromiseError(p, handler) {
  try {
    return await p;
  } catch (e) {
    return handler(e);
  }
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/events/events.js
var _listeners;
var EventEmitter = class {
  constructor(name) {
    __publicField(this, "name");
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    /**
     * The event listeners can subscribe to.
     */
    __publicField(this, "on", (listener) => {
      __privateGet(this, _listeners).add(listener);
      return {
        dispose: () => {
          __privateGet(this, _listeners).delete(listener);
        }
      };
    });
    /**
     * Dispose this object and free resources.
     */
    __publicField(this, "dispose", () => {
      __privateGet(this, _listeners).clear();
    });
    this.name = name;
  }
  /**
   * Notify all subscribers of the {@link EventEmitter.on event}. Failure
   * of one or more listener will not fail this function call.
   *
   * @param data The event object.
   */
  fire(event) {
    let errors;
    for (const listener of __privateGet(this, _listeners)) {
      try {
        listener(event);
      } catch (e) {
        errors = errors ?? [];
        errors.push(toError(e));
      }
    }
    return errors;
  }
};
_listeners = new WeakMap();
var ClearCacheEvent = class _ClearCacheEvent extends EventEmitter {
  constructor() {
    super(_ClearCacheEvent.eventName);
  }
  static eventName = "clear-cache";
};
var clearCacheEvent = new ClearCacheEvent();
function onClearCache(listener) {
  return clearCacheEvent.on(listener);
}
function dispatchClearCache() {
  clearCacheEvent.fire(void 0);
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/AutoCache.js
var CACHE_SIZE = 100;
var Cache01 = class {
  maxSize;
  hits = 0;
  misses = 0;
  swaps = 0;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
};
var Cache01Map = class extends Cache01 {
  count = 0;
  cache0 = /* @__PURE__ */ new Map();
  cache1 = /* @__PURE__ */ new Map();
  constructor(maxSize) {
    super(maxSize);
  }
  get(key) {
    const cache0 = this.cache0;
    const cache1 = this.cache1;
    let found = cache0.get(key);
    if (found !== void 0) {
      ++this.hits;
      return found;
    }
    found = cache1.get(key);
    if (found !== void 0) {
      ++this.hits;
      ++this.count;
      cache0.set(key, found);
      return found;
    }
    ++this.misses;
    return void 0;
  }
  set(key, value) {
    if (this.count >= this.maxSize) {
      const c = this.cache1;
      this.cache1 = this.cache0;
      this.cache0 = c;
      c.clear();
      this.swaps++;
      this.count = 0;
    }
    ++this.count;
    this.cache0.set(key, value);
    return this;
  }
};
function createCache01(size) {
  return new Cache01Map(size);
}
function autoCache(fn, size = CACHE_SIZE) {
  const cache4 = createCache01(size);
  const ac = get;
  ac.hits = 0;
  ac.misses = 0;
  ac.swaps = 0;
  function get(k) {
    const f = cache4.get(k);
    if (f !== void 0) {
      ++ac.hits;
      return f;
    }
    const r = fn(k);
    cache4.set(k, r);
    ac.swaps = cache4.swaps;
    ++ac.misses;
    return r;
  }
  return ac;
}
function extractStats(ac) {
  const { hits, misses, swaps } = ac;
  return { hits, misses, swaps };
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/helpers/iteratorToIterable.js
function* iteratorToIterable(iterator) {
  var _a3;
  try {
    let n;
    while (!(n = iterator.next()).done) {
      yield n.value;
    }
  } catch (e) {
    if (iterator.throw) {
      return iterator.throw(e);
    }
    throw e;
  } finally {
    (_a3 = iterator.return) == null ? void 0 : _a3.call(iterator);
  }
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/append.js
function opAppendSync(...iterablesToAppend) {
  function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fnAppend;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/combine.js
function opCombineSync(...fns) {
  function combine4(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine4;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/concatMap.js
function opConcatMapSync(mapFn) {
  function fnConcatMapSync(iterable) {
    function opConcatMapIterator() {
      const iter = iterable[Symbol.iterator]();
      let resultsIter = void 0;
      function nextConcatMap() {
        while (true) {
          if (resultsIter) {
            const { done: done2, value: value2 } = resultsIter.next();
            if (!done2) {
              return { value: value2 };
            }
            resultsIter = void 0;
          }
          const { done, value } = iter.next();
          if (done) {
            return { done, value: void 0 };
          }
          resultsIter = mapFn(value)[Symbol.iterator]();
        }
      }
      return {
        next: nextConcatMap
      };
    }
    return {
      [Symbol.iterator]: opConcatMapIterator
    };
  }
  return fnConcatMapSync;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/filter.js
function opFilterSync(filterFn) {
  function opFilterIterable(iterable) {
    function opFilterIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpFilter() {
        while (true) {
          const { done, value } = iter.next();
          if (done)
            return { done, value: void 0 };
          if (filterFn(value))
            return { value };
        }
      }
      return {
        next: nextOpFilter
      };
    }
    return {
      [Symbol.iterator]: opFilterIterator
    };
  }
  return opFilterIterable;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/flatten.js
function opFlattenSync() {
  function* fn(iter) {
    for (const v of iter) {
      yield* v;
    }
  }
  return fn;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/map.js
function opMapSync(mapFn) {
  function opMapIterable(iterable) {
    function opMapIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpMap() {
        const { done, value } = iter.next();
        if (done)
          return { done, value: void 0 };
        return { value: mapFn(value) };
      }
      return {
        next: nextOpMap
      };
    }
    return {
      [Symbol.iterator]: opMapIterator
    };
  }
  return opMapIterable;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/reduce.js
function opReduceSync(reduceFn, initialValue) {
  function* reduce3(head, tail) {
    for (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  function* fn(iter) {
    const ht = initialValue === void 0 ? headTail(iter) : { head: initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce3(ht.head, ht.tail);
  }
  return fn;
}
function headTail(iter) {
  const iterator = iter[Symbol.iterator]();
  const first3 = iterator.next();
  if (first3.done)
    return void 0;
  return { head: first3.value, tail: iteratorToIterable(iterator) };
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/take.js
function opTakeSync(count3) {
  function* fn(iter) {
    if (count3 <= 0)
      return;
    for (const v of iter) {
      yield v;
      if (--count3 <= 0)
        return;
    }
  }
  return fn;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/operators/unique.js
function opUniqueSync(k) {
  function fnK(key) {
    function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for (const v of iter) {
        const kk = key(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/pipe.js
function pipeSync(i, ...fns) {
  return opCombineSync(...fns)(i);
}

// node_modules/.pnpm/@cspell+cspell-pipe@8.14.2/node_modules/@cspell/cspell-pipe/dist/reduce.js
function reduceSync(iter, reduceFn, initialValue) {
  const i = initialValue === void 0 ? pipeSync(iter, opReduceSync(reduceFn)) : pipeSync(iter, opReduceSync(reduceFn, initialValue));
  return [...i][0];
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/memorizeLastCall.js
var SymEmpty = Symbol("memorizeLastCall");
function memorizeLastCall(fn) {
  let lastP = void 0;
  let lastR = SymEmpty;
  function calc(p) {
    if (lastR !== SymEmpty && lastP === p)
      return lastR;
    lastP = p;
    lastR = fn(p);
    return lastR;
  }
  return calc;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/ITrieNode/find.js
var defaultLegacyMinCompoundLength = 3;
var _defaultFindOptions = {
  matchCase: false,
  compoundMode: "compound",
  legacyMinCompoundLength: defaultLegacyMinCompoundLength
};
Object.freeze(_defaultFindOptions);
var arrayCompoundModes = ["none", "compound", "legacy"];
var knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
var notFound = { found: false, compoundUsed: false, caseMatched: false, forbidden: void 0 };
Object.freeze(notFound);
function findWordNode(root, word, options) {
  return _findWordNode(root, word, options);
}
function findWord(root, word, options) {
  if (root.find) {
    const found = root.find(word, (options == null ? void 0 : options.matchCase) || false);
    if (found)
      return found;
    if (!root.hasCompoundWords) {
      return notFound;
    }
  }
  const v = _findWordNode(root, word, options);
  return {
    found: v.found,
    compoundUsed: v.compoundUsed,
    caseMatched: v.caseMatched,
    forbidden: v.forbidden
  };
}
function _findWordNode(root, word, options) {
  const trieInfo = root.info;
  const matchCase3 = (options == null ? void 0 : options.matchCase) || false;
  const compoundMode = knownCompoundModes.get(options == null ? void 0 : options.compoundMode) || _defaultFindOptions.compoundMode;
  const compoundPrefix = compoundMode === "compound" ? trieInfo.compoundCharacter ?? root.compoundFix : "";
  const ignoreCasePrefix = matchCase3 ? "" : trieInfo.stripCaseAndAccentsPrefix ?? root.caseInsensitivePrefix;
  const checkForbidden = (options == null ? void 0 : options.checkForbidden) ?? true;
  function __findCompound() {
    const f = findCompoundWord(root, word, compoundPrefix, ignoreCasePrefix);
    const result = { ...f };
    if (f.found !== false && f.compoundUsed) {
      const r = !f.caseMatched ? walk(root, root.caseInsensitivePrefix) : root;
      result.forbidden = checkForbidden ? isForbiddenWord(r, word, root.forbidPrefix) : void 0;
    }
    return result;
  }
  function __findExact() {
    const n = root.getNode ? root.getNode(word) : walk(root, word);
    const isFound = isEndOfWordNode(n);
    const result = {
      found: isFound && word,
      compoundUsed: false,
      forbidden: checkForbidden ? isForbiddenWord(root, word, root.forbidPrefix) : void 0,
      node: n,
      caseMatched: true
    };
    return result;
  }
  switch (compoundMode) {
    case "none": {
      return matchCase3 ? __findExact() : __findCompound();
    }
    case "compound": {
      return __findCompound();
    }
    case "legacy": {
      return findLegacyCompound(root, word, options);
    }
  }
}
function findLegacyCompound(root, word, options) {
  const roots = [root];
  if (!(options == null ? void 0 : options.matchCase)) {
    roots.push(walk(root, root.caseInsensitivePrefix));
  }
  return findLegacyCompoundNode(roots, word, (options == null ? void 0 : options.legacyMinCompoundLength) || defaultLegacyMinCompoundLength);
}
function findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix) {
  var _a3;
  const stack = [
    // { n: root, compoundPrefix: '', cr: undefined, caseMatched: true },
    { n: root, compoundPrefix: ignoreCasePrefix, cr: void 0, caseMatched: true }
  ];
  const compoundPrefix = compoundCharacter || ignoreCasePrefix;
  const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
  const nw = word.normalize();
  const w = [...nw];
  function determineRoot(s) {
    const prefix = s.compoundPrefix;
    let r = root;
    let i2;
    for (i2 = 0; i2 < prefix.length && r; ++i2) {
      r = r.get(prefix[i2]);
    }
    const caseMatched2 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
    return {
      n: s.n,
      compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
      cr: r,
      caseMatched: caseMatched2
    };
  }
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = h && (n == null ? void 0 : n.get(h)) || void 0;
    if (c && i < word.length) {
      caseMatched = s.caseMatched;
      stack[i] = { n: c, compoundPrefix, cr: void 0, caseMatched };
    } else if (!c || !c.eow) {
      node = node || c;
      while (--i > 0) {
        const s2 = stack[i];
        if (!s2.compoundPrefix || !((_a3 = s2.n) == null ? void 0 : _a3.hasChildren()))
          continue;
        if (s2.n.get(compoundCharacter))
          break;
      }
      if (i >= 0 && stack[i].compoundPrefix) {
        compoundUsed = i > 0;
        const r = determineRoot(stack[i]);
        stack[i] = r;
        if (!r.cr) {
          break;
        }
        if (!i && !r.caseMatched && nw !== nw.toLowerCase()) {
          break;
        }
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  const found = i === word.length && word || false;
  const result = { found, compoundUsed, node, forbidden: void 0, caseMatched };
  return result;
}
function findCompoundWord(root, word, compoundCharacter, ignoreCasePrefix) {
  const { found, compoundUsed, node, caseMatched } = findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix);
  if (!node || !node.eow) {
    return { found: false, compoundUsed, node, forbidden: void 0, caseMatched };
  }
  return { found, compoundUsed, node, forbidden: void 0, caseMatched };
}
function findWordExact(root, word) {
  const r = root;
  if (r == null ? void 0 : r.findExact)
    return r.findExact(word);
  return isEndOfWordNode(walk(root, word));
}
function isEndOfWordNode(n) {
  return !!(n == null ? void 0 : n.eow);
}
function walk(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.get(h);
  }
  return n;
}
function findLegacyCompoundNode(roots, word, minCompoundLength) {
  var _a3;
  const root = roots[0];
  const numRoots = roots.length;
  const stack = [
    { n: root, usedRoots: 1, subLength: 0, isCompound: false, cr: void 0, caseMatched: true }
  ];
  const w = word;
  const wLen = w.length;
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = n == null ? void 0 : n.get(h);
    if (c && i < wLen) {
      stack[i] = {
        n: c,
        usedRoots: 0,
        subLength: s.subLength + 1,
        isCompound: s.isCompound,
        cr: void 0,
        caseMatched: s.caseMatched
      };
    } else if (!c || !c.eow || c.eow && s.subLength < minCompoundLength - 1) {
      while (--i > 0) {
        const s2 = stack[i];
        if (s2.usedRoots < numRoots && ((_a3 = s2.n) == null ? void 0 : _a3.eow) && (s2.subLength >= minCompoundLength || !s2.subLength) && wLen - i >= minCompoundLength) {
          break;
        }
      }
      if (i > 0 || stack[i].usedRoots < numRoots) {
        compoundUsed = i > 0;
        const s2 = stack[i];
        s2.cr = roots[s2.usedRoots++];
        s2.subLength = 0;
        s2.isCompound = compoundUsed;
        s2.caseMatched = s2.caseMatched && s2.usedRoots <= 1;
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function extractWord() {
    if (!word || i < word.length)
      return false;
    const letters = [];
    let subLen = 0;
    for (let j = 0; j < i; ++j) {
      const { subLength } = stack[j];
      if (subLength < subLen) {
        letters.push("+");
      }
      letters.push(word[j]);
      subLen = subLength;
    }
    return letters.join("");
  }
  const found = extractWord();
  const result = { found, compoundUsed, node, forbidden: void 0, caseMatched };
  return result;
}
function isForbiddenWord(root, word, forbiddenPrefix) {
  const r = root;
  if (r == null ? void 0 : r.isForbidden)
    return r.isForbidden(word);
  return findWordExact(root == null ? void 0 : root.get(forbiddenPrefix), word);
}
var createFindOptions = memorizeLastCall(_createFindOptions);
function _createFindOptions(options) {
  if (!options)
    return _defaultFindOptions;
  const d = _defaultFindOptions;
  return {
    matchCase: options.matchCase ?? d.matchCase,
    compoundMode: options.compoundMode ?? d.compoundMode,
    legacyMinCompoundLength: options.legacyMinCompoundLength ?? d.legacyMinCompoundLength,
    checkForbidden: options.checkForbidden ?? d.checkForbidden
  };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/walker/walkerTypes.js
var JOIN_SEPARATOR = "+";
var WORD_SEPARATOR = " ";
var CompoundWordsMethod;
(function(CompoundWordsMethod2) {
  CompoundWordsMethod2[CompoundWordsMethod2["NONE"] = 0] = "NONE";
  CompoundWordsMethod2[CompoundWordsMethod2["SEPARATE_WORDS"] = 1] = "SEPARATE_WORDS";
  CompoundWordsMethod2[CompoundWordsMethod2["JOIN_WORDS"] = 2] = "JOIN_WORDS";
})(CompoundWordsMethod || (CompoundWordsMethod = {}));

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/ITrieNode/walker/walker.js
function* compoundWalker(root, compoundingMethod) {
  const empty = Object.freeze([]);
  const roots = {
    [CompoundWordsMethod.NONE]: empty,
    [CompoundWordsMethod.JOIN_WORDS]: [[JOIN_SEPARATOR, root]],
    [CompoundWordsMethod.SEPARATE_WORDS]: [[WORD_SEPARATOR, root]]
  };
  const rc = roots[compoundingMethod].length ? roots[compoundingMethod] : void 0;
  function children(n) {
    if (n.hasChildren()) {
      const entries = n.entries();
      const c = Array.isArray(entries) ? entries : [...entries];
      return n.eow && rc ? [...c, ...rc] : c;
    }
    if (n.eow) {
      return roots[compoundingMethod];
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length) {
      const [char, node] = s.c[s.ci++];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper ?? true) {
        depth++;
        baseText = text;
        stack[depth] = { t: text, c: children(node), ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function* nodeWalker(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  stack[depth] = { t: "", n: root, c: Array.isArray(entries) ? entries : [...entries], ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const idx2 = s.ci++;
      const [char, node] = s.c[idx2];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper !== false) {
        depth++;
        baseText = text;
        const s2 = stack[depth];
        const entries2 = node.entries();
        const c = Array.isArray(entries2) ? entries2 : [...entries2];
        if (s2) {
          s2.t = text;
          s2.n = node;
          s2.c = c;
          s2.ci = 0;
        } else {
          stack[depth] = { t: text, n: node, c, ci: 0 };
        }
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function walker(root, compoundingMethod = CompoundWordsMethod.NONE) {
  return compoundingMethod === CompoundWordsMethod.NONE ? nodeWalker(root) : compoundWalker(root, compoundingMethod);
}
function walkerWords(root) {
  return walkerWordsITrie(root);
}
function* walkerWordsITrie(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  const c = Array.isArray(entries) ? entries : [...entries];
  stack[depth] = { t: "", n: root, c, ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node)
        continue;
      const text = baseText + char;
      if (node.eow)
        yield text;
      depth++;
      baseText = text;
      const entries2 = node.entries();
      const c2 = Array.isArray(entries2) ? entries2 : [...entries2];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c2;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node, c: c2, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/ITrieNode/trie-util.js
function iteratorTrieWords(node) {
  return walkerWords(node);
}
function findNode(node, word) {
  for (let i = 0; i < word.length; ++i) {
    const n = node.get(word[i]);
    if (!n)
      return void 0;
    node = n;
  }
  return node;
}
function countWords(root) {
  const visited = /* @__PURE__ */ new Map();
  function walk3(n) {
    const nestedCount = visited.get(n.id);
    if (nestedCount !== void 0) {
      return nestedCount;
    }
    let cnt = n.eow ? 1 : 0;
    visited.set(n, cnt);
    for (const c of n.values()) {
      cnt += walk3(c);
    }
    visited.set(n, cnt);
    return cnt;
  }
  return walk3(root);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieNode/trie.js
function trieRootToITrieRoot(root) {
  return ImplITrieRoot.toITrieNode(root);
}
function trieNodeToITrieNode(node) {
  return ImplITrieNode.toITrieNode(node);
}
var EmptyKeys = Object.freeze([]);
var EmptyValues = Object.freeze([]);
var EmptyEntries = Object.freeze([]);
var _ImplITrieNode_instances, findTrieNode_fn;
var _ImplITrieNode = class _ImplITrieNode {
  constructor(node) {
    __privateAdd(this, _ImplITrieNode_instances);
    __publicField(this, "node");
    __publicField(this, "id");
    __publicField(this, "_keys");
    this.node = node;
    this.id = node;
  }
  /** flag End of Word */
  get eow() {
    return !!this.node.f;
  }
  /** number of children */
  get size() {
    if (!this.node.c)
      return 0;
    return this.keys().length;
  }
  /** get keys to children */
  keys() {
    if (this._keys)
      return this._keys;
    const keys3 = this.node.c ? Object.keys(this.node.c) : EmptyKeys;
    this._keys = keys3;
    return keys3;
  }
  /** get the child nodes */
  values() {
    return !this.node.c ? EmptyValues : Object.values(this.node.c).map((n) => _ImplITrieNode.toITrieNode(n));
  }
  entries() {
    return !this.node.c ? EmptyEntries : Object.entries(this.node.c).map(([k, n]) => [k, _ImplITrieNode.toITrieNode(n)]);
  }
  /** get child ITrieNode */
  get(char) {
    var _a3;
    const n = (_a3 = this.node.c) == null ? void 0 : _a3[char];
    if (!n)
      return void 0;
    return _ImplITrieNode.toITrieNode(n);
  }
  getNode(chars) {
    return this.findNode(chars);
  }
  has(char) {
    const c = this.node.c;
    return c && char in c || false;
  }
  child(keyIdx) {
    const char = this.keys()[keyIdx];
    const n = char && this.get(char);
    if (!n)
      throw new Error("Index out of range.");
    return n;
  }
  hasChildren() {
    return !!this.node.c;
  }
  findNode(word) {
    const node = __privateMethod(this, _ImplITrieNode_instances, findTrieNode_fn).call(this, word);
    return node && _ImplITrieNode.toITrieNode(node);
  }
  findExact(word) {
    const node = __privateMethod(this, _ImplITrieNode_instances, findTrieNode_fn).call(this, word);
    return !!node && !!node.f;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
_ImplITrieNode_instances = new WeakSet();
findTrieNode_fn = function(word) {
  var _a3;
  let node = this.node;
  for (const char of word) {
    if (!node)
      return void 0;
    node = (_a3 = node.c) == null ? void 0 : _a3[char];
  }
  return node;
};
var ImplITrieNode = _ImplITrieNode;
var ImplITrieRoot = class extends ImplITrieNode {
  root;
  info;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(root) {
    super(root);
    this.root = root;
    const { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware } = root;
    this.info = { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware };
    this.hasForbiddenWords = !!root.c[forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[compoundCharacter];
    this.hasNonStrictWords = !!root.c[stripCaseAndAccentsPrefix];
  }
  get eow() {
    return false;
  }
  resolveId(id) {
    const n = id;
    return new ImplITrieNode(n);
  }
  get forbidPrefix() {
    return this.root.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.root.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.root.stripCaseAndAccentsPrefix;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/walker/walker.js
var useITrie = false;
var walkerWords2 = useITrie ? _walkerWords2 : _walkerWords;
function* _walkerWords(root) {
  const empty = [];
  function children(n) {
    if (n.c) {
      return Object.keys(n.c);
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", n: root.c, c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const char = s.c[s.ci++];
      const node = s.n[char];
      const text = baseText + char;
      if (node.f)
        yield text;
      depth++;
      baseText = text;
      const c = children(node);
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node.c;
        s.c = c;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node.c, c, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function _walkerWords2(root) {
  return walkerWordsITrie2(trieNodeToITrieNode(root));
}
function* walkerWordsITrie2(root) {
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", n: root, c: [...root.entries()], ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node)
        continue;
      const text = baseText + char;
      if (node.eow)
        yield text;
      depth++;
      baseText = text;
      const c = [...node.entries()];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node, c, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/suggestions/genSuggestionsOptions.js
var defaultGenSuggestionOptions = {
  compoundMethod: CompoundWordsMethod.NONE,
  ignoreCase: true,
  changeLimit: 5
};
var defaultSuggestionOptions = {
  ...defaultGenSuggestionOptions,
  numSuggestions: 8,
  includeTies: true,
  timeout: 5e3
};
var keyMapOfGenSuggestionOptionsStrict = {
  changeLimit: "changeLimit",
  compoundMethod: "compoundMethod",
  ignoreCase: "ignoreCase",
  compoundSeparator: "compoundSeparator"
};
var keyMapOfSuggestionOptionsStrict = {
  ...keyMapOfGenSuggestionOptionsStrict,
  filter: "filter",
  includeTies: "includeTies",
  numSuggestions: "numSuggestions",
  timeout: "timeout",
  weightMap: "weightMap"
};
function createSuggestionOptions(...opts) {
  const options = { ...defaultSuggestionOptions };
  const keys3 = Object.keys(keyMapOfSuggestionOptionsStrict);
  for (const opt of opts) {
    for (const key of keys3) {
      assign(options, opt, key);
    }
  }
  return options;
}
function assign(dest, src, k) {
  dest[k] = src[k] ?? dest[k];
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/PairingHeap.js
var PairingHeap = class {
  compare;
  _heap;
  _size = 0;
  constructor(compare3) {
    this.compare = compare3;
  }
  /** Add an item to the heap. */
  add(v) {
    this._heap = insert(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  /** take an item from the heap. */
  dequeue() {
    const n = this.next();
    if (n.done)
      return void 0;
    return n.value;
  }
  /** Add items to the heap */
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  /** get the next value */
  next() {
    if (!this._heap) {
      return { value: void 0, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead(this.compare, this._heap);
    return { value };
  }
  /** peek at the next value without removing it. */
  peek() {
    var _a3;
    return (_a3 = this._heap) == null ? void 0 : _a3.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  /** alias of `size` */
  get length() {
    return this._size;
  }
  /** number of entries in the heap. */
  get size() {
    return this._size;
  }
};
function removeHead(compare3, heap) {
  if (!heap || !heap.c)
    return void 0;
  return mergeSiblings(compare3, heap.c);
}
function insert(compare3, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare3(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge(compare3, a, b) {
  if (compare3(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings(compare3, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge(compare3, n, s);
  return ss ? merge(compare3, m, mergeSiblings(compare3, ss)) : m;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/suggestions/constants.js
var DEFAULT_COMPOUNDED_WORD_SEPARATOR = "\u2219";
var opCosts = {
  baseCost: 100,
  swapCost: 75,
  duplicateLetterCost: 80,
  compound: 1,
  visuallySimilar: 1,
  firstLetterBias: 5,
  wordBreak: 99,
  wordLengthCostFactor: 0.5
};

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/suggestions/orthography.js
var intl = new Intl.Collator("en", { sensitivity: "base" });
var compare = intl.compare;
var visualLetterGroups = [
  // cspell:disable
  forms("\u01CE\xE0\xE5\xC4\xC0A\xE3\xE2\xE1\u01DF\u1EB7\u1EAF\u1EA5\u0100\u0101\u0103\u0105a\xE4\xE6\u0250\u0251\u03B1\u0430\u1FB3") + "\u1FB3",
  forms("Bb\u1E03\u0432\u044A\u044C"),
  forms("\u010B\u010C\u010Dc\u0109\xE7C\xC7\u0107\u010A\u0421\u0441\u03C2"),
  forms("\u1E0E\u1E0B\u1E0F\u1E11\u010F\u0111\u1E0DDd"),
  forms("\u0113\xEB\xC8\xCA\xCB\u1EC1\xE9\xE8\u1EBF\u1EC7\u0115eE\u0112\u0117\u0119\u011B\xEA\u0259\u025B\u0451\u0401\u0435\u0292"),
  forms("f\u1E1FF\uFB00"),
  forms("\u0121\u0120\u011E\u01E7\u011D\u0123Gg\u0263"),
  forms("\u0127\u0126\u0125\u1E25Hh\u1E24\u021F\u043D"),
  forms("I\u012F\xEF\u0130\xCE\xCD\u012Bi\xCC\xEC\xED\xEE\u0131\u026A\u0268\u0457\u038A\u0399"),
  forms("jJ\u0135"),
  forms("\u0137Kk\u03BA\u043A\u045C"),
  forms("\u1E37\u0142\u013E\u013CLl\u013A\u1E36\u03AF\u03B9"),
  forms("M\u1E43\u1E41m"),
  forms("n\u0146\xD1N\u1E47\u0148\u0147\xF1\u0144\u014B\u045D\u0438\u0439"),
  forms("\xD2O\xF8\u022D\u014C\u014D\u0151\u1ECFo\xD6\xF2\u0231\u022F\xF3\xF4\xF5\xF6\u01A1\u0254\u03CC\u03B4\u043E"),
  forms("P\u1E57p\u0440\u0420\u03C1"),
  forms("Qq"),
  forms("\u0159R\u1E5Br\u0155\u0157\u0453\u0433\u044F"),
  forms("\u1E63\u0161\u0218\u1E62sS\u0160\u1E61\u015E\u015D\u015B\u0219\u0283\u03A3"),
  forms("t\u021B\u021A\u0165T\u1E6D\u1E6C\u1E6B"),
  forms("\xDC\xFC\xFB\u016A\u01B0\u016F\u016B\u0171\xFA\xDB\u016D\xD9\xF9u\u0173U"),
  forms("Vv\u03BD"),
  forms("\u0175wW\u1E83\u1E85\u1E81\u03C9\u0448"),
  forms("xX\u0445"),
  forms("\xFF\xFDY\u0177y\xDD\u1EF3\u0423\u045E\u0443"),
  forms("Z\u1E93\u017E\u017D\u017C\u017B\u017Az")
  // cspell:enable
];
function forms(letters) {
  const n = letters.normalize("NFC").replaceAll(new RegExp("\\p{M}", "gu"), "");
  const na = n.normalize("NFD").replaceAll(new RegExp("\\p{M}", "gu"), "");
  const s = new Set(n + n.toLowerCase() + n.toUpperCase() + na + na.toLowerCase() + na.toUpperCase());
  return [...s].join("");
}
var visualLetterMaskMap = calcVisualLetterMasks(visualLetterGroups);
function calcVisualLetterMasks(groups) {
  const map3 = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < groups.length; ++i) {
    const m = 1 << i;
    const g = groups[i];
    for (const c of g) {
      map3[c] = (map3[c] || 0) | m;
    }
  }
  return map3;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/distance/distanceAStarWeighted.js
var import_node_assert = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/distance/weightedMaps.js
var matchPossibleWordSeparators = /[+]/g;
function createWeightMap(...defs) {
  const map3 = _createWeightMap();
  addDefsToWeightMap(map3, defs);
  return map3;
}
function addDefToWeightMap(map3, ...defs) {
  return addDefsToWeightMap(map3, defs);
}
function addAdjustment(map3, ...adjustments) {
  for (const adj of adjustments) {
    map3.adjustments.set(adj.id, adj);
  }
  return map3;
}
function addDefsToWeightMap(map3, defs) {
  function addSet(set, def) {
    addSetToTrieCost(map3.insDel, set, def.insDel, def.penalty);
    addSetToTrieTrieCost(map3.replace, set, def.replace, def.penalty);
    addSetToTrieTrieCost(map3.swap, set, def.swap, def.penalty);
  }
  for (const _def of defs) {
    const def = normalizeDef(_def);
    const mapSets = splitMap(def);
    mapSets.forEach((s) => addSet(s, def));
  }
  return map3;
}
function _createWeightMap() {
  return {
    insDel: {},
    replace: {},
    swap: {},
    adjustments: /* @__PURE__ */ new Map()
  };
}
function lowest(a, b) {
  if (a === void 0)
    return b;
  if (b === void 0)
    return a;
  return a <= b ? a : b;
}
function highest(a, b) {
  if (a === void 0)
    return b;
  if (b === void 0)
    return a;
  return a >= b ? a : b;
}
function normalize(s) {
  const f = /* @__PURE__ */ new Set([s]);
  f.add(s.normalize("NFC"));
  f.add(s.normalize("NFD"));
  return f;
}
function* splitMapSubstringsIterable(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield* normalize(seq);
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield* normalize(char);
  }
}
function splitMapSubstrings(map3) {
  return [...splitMapSubstringsIterable(map3)];
}
function splitMap(def) {
  const { map: map3 } = def;
  const sets = map3.split("|");
  return sets.map(splitMapSubstrings).filter((s) => s.length > 0);
}
function addToTrieCost(trie, str, cost, penalties) {
  if (!str)
    return;
  let t = trie;
  for (const c of str) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  t.c = lowest(t.c, cost);
  t.p = highest(t.p, penalties);
}
function addToTrieTrieCost(trie, left, right, cost, penalties) {
  let t = trie;
  for (const c of left) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  const trieCost = t.t = t.t || /* @__PURE__ */ Object.create(null);
  addToTrieCost(trieCost, right, cost, penalties);
}
function addSetToTrieCost(trie, set, cost, penalties) {
  if (cost === void 0)
    return;
  for (const str of set) {
    addToTrieCost(trie, str, cost, penalties);
  }
}
function addSetToTrieTrieCost(trie, set, cost, penalties) {
  if (cost === void 0)
    return;
  for (const left of set) {
    for (const right of set) {
      if (left === right)
        continue;
      addToTrieTrieCost(trie, left, right, cost, penalties);
    }
  }
}
function* searchTrieNodes(trie, str, i) {
  const len = str.length;
  for (let n = trie.n; i < len && n; ) {
    const t = n[str[i]];
    if (!t)
      return;
    ++i;
    yield { i, t };
    n = t.n;
  }
}
function* findTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const { c, p } = n.t;
    if (c !== void 0) {
      yield { i: n.i, c, p: p || 0 };
    }
  }
}
function* findTrieTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const t = n.t.t;
    if (t !== void 0) {
      yield { i: n.i, t };
    }
  }
}
function createWeightCostCalculator(weightMap) {
  return new _WeightCostCalculator(weightMap);
}
var _WeightCostCalculator = class {
  weightMap;
  constructor(weightMap) {
    this.weightMap = weightMap;
  }
  *calcInsDelCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieCostPrefixes(this.weightMap.insDel, a, ai)) {
      yield { a, b, ai: del.i, bi, c: c + del.c, p: p + del.p };
    }
    for (const ins of findTrieCostPrefixes(this.weightMap.insDel, b, bi)) {
      yield { a, b, ai, bi: ins.i, c: c + ins.c, p: p + ins.p };
    }
  }
  *calcReplaceCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieTrieCostPrefixes(this.weightMap.replace, a, ai)) {
      for (const ins of findTrieCostPrefixes(del.t, b, bi)) {
        yield { a, b, ai: del.i, bi: ins.i, c: c + ins.c, p: p + ins.p };
      }
    }
  }
  *calcSwapCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    const swap = this.weightMap.swap;
    for (const left of findTrieTrieCostPrefixes(swap, a, ai)) {
      for (const right of findTrieCostPrefixes(left.t, a, left.i)) {
        const sw = a.slice(left.i, right.i) + a.slice(ai, left.i);
        if (b.slice(bi).startsWith(sw)) {
          const len = sw.length;
          yield { a, b, ai: ai + len, bi: bi + len, c: c + right.c, p: p + right.p };
        }
      }
    }
  }
  calcAdjustment(word) {
    let penalty = 0;
    for (const adj of this.weightMap.adjustments.values()) {
      if (adj.regexp.global) {
        for (const _m of word.matchAll(adj.regexp)) {
          penalty += adj.penalty;
        }
      } else if (adj.regexp.test(word)) {
        penalty += adj.penalty;
      }
    }
    return penalty;
  }
};
function normalizeDef(def) {
  const { map: map3, ...rest } = def;
  return { ...rest, map: normalizeMap(map3) };
}
function normalizeMap(map3) {
  return map3.replaceAll(matchPossibleWordSeparators, DEFAULT_COMPOUNDED_WORD_SEPARATOR);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/distance/distanceAStarWeighted.js
function distanceAStarWeighted(wordA, wordB, map3, cost = 100) {
  const calc = createWeightCostCalculator(map3);
  const best = _distanceAStarWeightedEx(wordA, wordB, calc, cost);
  const penalty = calc.calcAdjustment(wordB);
  return best.c + best.p + penalty;
}
function _distanceAStarWeightedEx(wordA, wordB, map3, cost = 100) {
  const a = "^" + wordA + "$";
  const b = "^" + wordB + "$";
  const aN = a.length;
  const bN = b.length;
  const candidates = new CandidatePool(aN, bN);
  candidates.add({ ai: 0, bi: 0, c: 0, p: 0, f: void 0 });
  function opSub(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN && bi < bN) {
      const cc = a[ai] === b[bi] ? c : c + cost;
      candidates.add({ ai: ai + 1, bi: bi + 1, c: cc, p, f: n });
    }
  }
  function opIns(n) {
    const { ai, bi, c, p } = n;
    if (bi < bN) {
      candidates.add({ ai, bi: bi + 1, c: c + cost, p, f: n });
    }
  }
  function opDel(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN) {
      candidates.add({ ai: ai + 1, bi, c: c + cost, p, f: n });
    }
  }
  function opSwap(n) {
    const { ai, bi, c, p } = n;
    if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) {
      candidates.add({ ai: ai + 2, bi: bi + 2, c: c + cost, p, f: n });
    }
  }
  function opMap2(n) {
    const { ai, bi, c, p } = n;
    const pos = { a, b, ai, bi, c, p };
    const costCalculations = [map3.calcInsDelCosts(pos), map3.calcSwapCosts(pos), map3.calcReplaceCosts(pos)];
    costCalculations.forEach((iter) => {
      for (const nn of iter) {
        candidates.add({ ...nn, f: n });
      }
    });
  }
  let best;
  while (best = candidates.next()) {
    if (best.ai === aN && best.bi === bN)
      break;
    opSwap(best);
    opIns(best);
    opDel(best);
    opMap2(best);
    opSub(best);
  }
  (0, import_node_assert.default)(best);
  return best;
}
var CandidatePool = class {
  aN;
  bN;
  pool = new PairingHeap(compare2);
  grid = [];
  constructor(aN, bN) {
    this.aN = aN;
    this.bN = bN;
  }
  next() {
    let n;
    while (n = this.pool.dequeue()) {
      if (!n.d)
        return n;
    }
    return void 0;
  }
  add(n) {
    const i = idx(n.ai, n.bi, this.bN);
    const g = this.grid[i];
    if (!g) {
      this.grid[i] = n;
      this.pool.add(n);
      return;
    }
    if (g.c <= n.c)
      return;
    g.d = true;
    this.grid[i] = n;
    this.pool.add(n);
  }
};
function idx(r, c, cols) {
  return r * cols + c;
}
function compare2(a, b) {
  return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/distance/distance.js
var defaultCost = 100;
function editDistanceWeighted(wordA, wordB, weights, editCost = defaultCost) {
  return distanceAStarWeighted(wordA, wordB, weights, editCost);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/timer.js
function startTimer() {
  const start = performance.now();
  return () => performance.now() - start;
}
function createPerfTimer() {
  const timer = startTimer();
  const active = /* @__PURE__ */ new Map();
  const events = [{ name: "start", at: 0 }];
  function updateEvent(event, atTime = timer()) {
    const elapsed = atTime - event.at;
    event.elapsed = (event.elapsed || 0) + elapsed;
    return elapsed;
  }
  function start(name) {
    const event = createEvent(name || "start");
    events.push(event);
    name && active.set(name, event);
    return () => updateEvent(event);
  }
  function stop(name) {
    const knownEvent = name && active.get(name);
    if (knownEvent) {
      return updateEvent(knownEvent);
    }
    return mark(name || "stop");
  }
  function createEvent(name) {
    return { name, at: timer() };
  }
  function mark(name) {
    const event = createEvent(name);
    events.push(event);
    return event.at;
  }
  function formatReport() {
    const lineElements = [
      { name: "Event Name", at: "Time", elapsed: "Elapsed" },
      { name: "----------", at: "----", elapsed: "-------" },
      ...mapEvents()
    ];
    function mapEvents() {
      const stack = [];
      return events.map((e) => {
        for (let s = stack.pop(); s; s = stack.pop()) {
          if (s >= e.at + (e.elapsed || 0)) {
            stack.push(s);
            break;
          }
        }
        const d = stack.length;
        if (e.elapsed) {
          stack.push(e.at + e.elapsed);
        }
        return {
          name: "| ".repeat(d) + (e.name || "").replaceAll("	", "  "),
          at: `${t(e.at)}`,
          elapsed: e.elapsed ? `${t(e.elapsed)}` : "--"
        };
      });
    }
    function t(ms) {
      return ms.toFixed(3) + "ms";
    }
    function m(v, s) {
      return Math.max(v, s.length);
    }
    const lengths = lineElements.reduce((a, b) => ({ name: m(a.name, b.name), at: m(a.at, b.at), elapsed: m(a.elapsed, b.elapsed) }), { name: 0, at: 0, elapsed: 0 });
    const lines = lineElements.map((e) => `${e.at.padStart(lengths.at)}  ${e.name.padEnd(lengths.name)}  ${e.elapsed.padStart(lengths.elapsed)}`);
    return lines.join("\n");
  }
  function measureFn(name, fn) {
    const s = start(name);
    const v = fn();
    s();
    return v;
  }
  async function measureAsyncFn(name, fn) {
    const s = start(name);
    const v = await fn();
    s();
    return v;
  }
  function report(reporter = console.log) {
    reporter(formatReport());
  }
  return {
    start,
    stop,
    mark,
    elapsed: timer,
    report,
    formatReport,
    measureFn,
    measureAsyncFn
  };
}
var globalPerfTimer = void 0;
function getGlobalPerfTimer() {
  const timer = globalPerfTimer || createPerfTimer();
  globalPerfTimer = timer;
  return timer;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/util.js
function isDefined(a) {
  return a !== void 0;
}
function cleanCopy(t) {
  const r = { ...t };
  return clean(r);
}
function clean(t) {
  for (const prop in t) {
    if (t[prop] === void 0) {
      delete t[prop];
    }
  }
  return t;
}
function unique(a) {
  return [...new Set(a)];
}
function regexQuote(text) {
  return text.replaceAll(/([[\]\-+(){},|*.\\])/g, "\\$1");
}
function replaceAllFactory(match2, replaceWithText) {
  const r = RegExp(regexQuote(match2), "g");
  return (text) => text.replace(r, replaceWithText);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/suggestions/suggestCollector.js
var defaultMaxNumberSuggestions = 10;
var BASE_COST = 100;
var MAX_NUM_CHANGES = 5;
var MAX_COST_SCALE = 0.5;
var MAX_ALLOWED_COST_SCALE = 1.03 * MAX_COST_SCALE;
var collator = new Intl.Collator();
var regexSeparator = new RegExp(`[${regexQuote(WORD_SEPARATOR)}]`, "g");
var wordLengthCost = [0, 50, 25, 5, 0];
var EXTRA_WORD_COST = 5;
var DEFAULT_COLLECTOR_TIMEOUT = 1e3;
var symStopProcessing = Symbol("Collector Stop Processing");
function compSuggestionResults(a, b) {
  const aPref = a.isPreferred && -1 || 0;
  const bPref = b.isPreferred && -1 || 0;
  return aPref - bPref || a.cost - b.cost || a.word.length - b.word.length || collator.compare(a.word, b.word);
}
var defaultSuggestionCollectorOptions = Object.freeze({
  numSuggestions: defaultMaxNumberSuggestions,
  filter: () => true,
  changeLimit: MAX_NUM_CHANGES,
  includeTies: false,
  ignoreCase: true,
  timeout: DEFAULT_COLLECTOR_TIMEOUT,
  weightMap: void 0,
  compoundSeparator: "",
  compoundMethod: void 0
});
function suggestionCollector(wordToMatch, options) {
  const { filter: filter3 = () => true, changeLimit = MAX_NUM_CHANGES, includeTies = false, ignoreCase: ignoreCase2 = true, timeout = DEFAULT_COLLECTOR_TIMEOUT, weightMap, compoundSeparator = defaultSuggestionCollectorOptions.compoundSeparator } = options;
  const numSuggestions = Math.max(options.numSuggestions, 0) || 0;
  const numSugToHold = weightMap ? numSuggestions * 2 : numSuggestions;
  const sugs = /* @__PURE__ */ new Map();
  let maxCost = BASE_COST * Math.min(wordToMatch.length * MAX_ALLOWED_COST_SCALE, changeLimit);
  const useSeparator = compoundSeparator || (weightMap ? DEFAULT_COMPOUNDED_WORD_SEPARATOR : defaultSuggestionCollectorOptions.compoundSeparator);
  const fnCleanWord = !useSeparator || useSeparator === compoundSeparator ? (w) => w : replaceAllFactory(useSeparator, "");
  if (useSeparator && weightMap) {
    addDefToWeightMap(weightMap, { map: useSeparator, insDel: 50 });
  }
  const genSuggestionOptions = clean({
    changeLimit,
    ignoreCase: ignoreCase2,
    compoundMethod: options.compoundMethod,
    compoundSeparator: useSeparator
  });
  let timeRemaining = timeout;
  function dropMax() {
    if (sugs.size < 2 || !numSuggestions) {
      sugs.clear();
      return;
    }
    const sorted = [...sugs.values()].sort(compSuggestionResults);
    let i = numSugToHold - 1;
    maxCost = sorted[i].cost;
    for (; i < sorted.length && sorted[i].cost <= maxCost; ++i) {
    }
    for (; i < sorted.length; ++i) {
      sugs.delete(sorted[i].word);
    }
  }
  function adjustCost(sug) {
    if (sug.isPreferred)
      return sug;
    const words = sug.word.split(regexSeparator);
    const extraCost = words.map((w) => wordLengthCost[w.length] || 0).reduce((a, b) => a + b, 0) + (words.length - 1) * EXTRA_WORD_COST;
    return { word: sug.word, cost: sug.cost + extraCost };
  }
  function collectSuggestion(suggestion) {
    const { word, cost, isPreferred } = adjustCost(suggestion);
    if (cost <= maxCost && filter3(suggestion.word, cost)) {
      const known = sugs.get(word);
      if (known) {
        known.cost = Math.min(known.cost, cost);
        known.isPreferred = known.isPreferred || isPreferred;
      } else {
        sugs.set(word, { word, cost, isPreferred });
        if (cost < maxCost && sugs.size > numSugToHold) {
          dropMax();
        }
      }
    }
    return maxCost;
  }
  function collect2(src, timeout2, filter4) {
    let stop = false;
    timeout2 = timeout2 ?? timeRemaining;
    timeout2 = Math.min(timeout2, timeRemaining);
    if (timeout2 < 0)
      return;
    const timer = startTimer();
    let ir;
    while (!(ir = src.next(stop || maxCost)).done) {
      if (timer() > timeout2) {
        stop = symStopProcessing;
      }
      const { value } = ir;
      if (!value)
        continue;
      if (isSuggestionResult(value)) {
        if (!filter4 || filter4(value.word, value.cost)) {
          collectSuggestion(value);
        }
        continue;
      }
    }
    timeRemaining -= timer();
  }
  function cleanCompoundResult(sr) {
    const { word, cost } = sr;
    const cWord = fnCleanWord(word);
    if (cWord !== word) {
      return {
        word: cWord,
        cost,
        compoundWord: word,
        isPreferred: void 0
      };
    }
    return { ...sr };
  }
  function suggestions() {
    if (numSuggestions < 1 || !sugs.size)
      return [];
    const NF = "NFD";
    const nWordToMatch = wordToMatch.normalize(NF);
    const rawValues = [...sugs.values()];
    const values = weightMap ? rawValues.map(({ word, cost, isPreferred }) => ({
      word,
      cost: isPreferred ? cost : editDistanceWeighted(nWordToMatch, word.normalize(NF), weightMap, 110),
      isPreferred
    })) : rawValues;
    const sorted = values.sort(compSuggestionResults).map(cleanCompoundResult);
    let i = Math.min(sorted.length, numSuggestions) - 1;
    const limit = includeTies ? sorted.length : Math.min(sorted.length, numSuggestions);
    const iCost = sorted[i].cost;
    const maxCost2 = Math.min(iCost, weightMap ? changeLimit * BASE_COST - 1 : iCost);
    for (i = 1; i < limit && sorted[i].cost <= maxCost2; ++i) {
    }
    sorted.length = i;
    return sorted;
  }
  const collector = {
    collect: collect2,
    add: function(suggestion) {
      collectSuggestion(suggestion);
      return this;
    },
    get suggestions() {
      return suggestions();
    },
    get maxCost() {
      return maxCost;
    },
    get word() {
      return wordToMatch;
    },
    get maxNumSuggestions() {
      return numSuggestions;
    },
    get changeLimit() {
      return changeLimit;
    },
    includesTies: includeTies,
    ignoreCase: ignoreCase2,
    symbolStopProcessing: symStopProcessing,
    genSuggestionOptions
  };
  return collector;
}
function impersonateCollector(collector, word) {
  const r = Object.create(collector);
  Object.defineProperty(r, "word", { value: word, writable: false });
  return r;
}
function isSuggestionResult(s) {
  const r = s;
  return !!r && typeof r === "object" && (r == null ? void 0 : r.cost) !== void 0 && r.word != void 0;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/suggestions/suggestAStar.js
function comparePath(a, b) {
  return a.c / (a.i + 1) - b.c / (b.i + 1) + (b.i - a.i);
}
function suggestAStar(trie, word, options = {}) {
  const opts = createSuggestionOptions(options);
  const collector = suggestionCollector(word, opts);
  collector.collect(getSuggestionsAStar(trie, word, opts));
  return collector.suggestions;
}
function* getSuggestionsAStar(trie, srcWord, options = {}) {
  const { compoundMethod, changeLimit, ignoreCase: ignoreCase2, weightMap } = createSuggestionOptions(options);
  const visMap = visualLetterMaskMap;
  const root = trie.getRoot();
  const rootIgnoreCase = ignoreCase2 && root.get(root.info.stripCaseAndAccentsPrefix) || void 0;
  const pathHeap = new PairingHeap(comparePath);
  const resultHeap = new PairingHeap(compareSuggestion);
  const rootPNode = { n: root, i: 0, c: 0, s: "", p: void 0, t: createCostTrie() };
  const BC = opCosts.baseCost;
  const VC = opCosts.visuallySimilar;
  const DL = opCosts.duplicateLetterCost;
  const wordSeparator = compoundMethod === CompoundWordsMethod.JOIN_WORDS ? JOIN_SEPARATOR : WORD_SEPARATOR;
  const sc = specialChars(trie.info);
  const comp = trie.info.compoundCharacter;
  const compRoot = root.get(comp);
  const compRootIgnoreCase = rootIgnoreCase && rootIgnoreCase.get(comp);
  const emitted = /* @__PURE__ */ Object.create(null);
  const srcLetters = [...srcWord];
  let limit = BC * Math.min(srcLetters.length * opCosts.wordLengthCostFactor, changeLimit);
  pathHeap.add(rootPNode);
  if (rootIgnoreCase) {
    pathHeap.add({ n: rootIgnoreCase, i: 0, c: 0, s: "", p: void 0, t: createCostTrie() });
  }
  let best = pathHeap.dequeue();
  let maxSize = pathHeap.size;
  let suggestionsGenerated = 0;
  let nodesProcessed = 0;
  let nodesProcessedLimit = 1e3;
  let minGen = 1;
  while (best) {
    if (++nodesProcessed > nodesProcessedLimit) {
      nodesProcessedLimit += 1e3;
      if (suggestionsGenerated < minGen) {
        break;
      }
      minGen += suggestionsGenerated;
    }
    if (best.c > limit) {
      best = pathHeap.dequeue();
      maxSize = Math.max(maxSize, pathHeap.size);
      continue;
    }
    processPath(best);
    for (const sug of resultHeap) {
      ++suggestionsGenerated;
      if (sug.cost > limit)
        continue;
      if (sug.word in emitted && emitted[sug.word] <= sug.cost)
        continue;
      const action = yield sug;
      emitted[sug.word] = sug.cost;
      if (typeof action === "number") {
        limit = Math.min(action, limit);
      }
      if (typeof action === "symbol") {
        return;
      }
    }
    best = pathHeap.dequeue();
    maxSize = Math.max(maxSize, pathHeap.size);
  }
  return;
  function compareSuggestion(a, b) {
    const pa = a.isPreferred && 1 || 0;
    const pb = b.isPreferred && 1 || 0;
    return pb - pa || a.cost - b.cost || // eslint-disable-next-line unicorn/prefer-code-point
    Math.abs(a.word.charCodeAt(0) - srcWord.charCodeAt(0)) - // eslint-disable-next-line unicorn/prefer-code-point
    Math.abs(b.word.charCodeAt(0) - srcWord.charCodeAt(0));
  }
  function processPath(p) {
    const len = srcLetters.length;
    if (p.n.eow && p.i === len) {
      const word = pNodeToWord(p);
      const result = { word, cost: p.c };
      resultHeap.add(result);
    }
    calcEdges(p);
  }
  function calcEdges(p) {
    const { n, i, t } = p;
    const s = srcLetters[i];
    const sg = visMap[s] || 0;
    const cost0 = p.c;
    const cost = cost0 + BC + (i ? 0 : opCosts.firstLetterBias);
    const costVis = cost0 + VC;
    const costLegacyCompound = cost0 + opCosts.wordBreak;
    const costCompound = cost0 + opCosts.compound;
    if (s) {
      const m = n.get(s);
      if (m) {
        storePath(t, m, i + 1, cost0, s, p, "=", s);
      }
      if (weightMap) {
        processWeightMapEdges(p, weightMap);
      }
      const ns = srcLetters[i + 1];
      if (s == ns && m) {
        storePath(t, m, i + 2, cost0 + DL, s, p, "dd", s);
      }
      storePath(t, n, i + 1, cost, "", p, "d", "");
      for (const [ss, node] of n.entries()) {
        if (node.id === (m == null ? void 0 : m.id) || ss in sc)
          continue;
        const g = visMap[ss] || 0;
        const c = sg & g ? costVis : cost;
        storePath(t, node, i + 1, c, ss, p, "r", ss);
      }
      if (n.eow && i && compoundMethod) {
        storePath(t, root, i, costLegacyCompound, wordSeparator, p, "L", wordSeparator);
      }
      if (ns) {
        const n1 = n.get(ns);
        const n2 = n1 == null ? void 0 : n1.get(s);
        if (n2) {
          const ss = ns + s;
          storePath(t, n2, i + 2, cost0 + opCosts.swapCost, ss, p, "s", ss);
        }
      }
    }
    if (compRoot && costCompound <= limit && n.get(comp)) {
      if (compRootIgnoreCase) {
        storePath(t, compRootIgnoreCase, i, costCompound, "", p, "~+", "~+");
      }
      storePath(t, compRoot, i, costCompound, "", p, "+", "+");
    }
    if (cost <= limit) {
      for (const [char, node] of n.entries()) {
        if (char in sc)
          continue;
        storePath(t, node, i, cost, char, p, "i", char);
      }
    }
  }
  function processWeightMapEdges(p, weightMap2) {
    delLetters(p, weightMap2, srcLetters, storePath);
    insLetters(p, weightMap2, srcLetters, storePath);
    repLetters(p, weightMap2, srcLetters, storePath);
    return;
  }
  function storePath(t, n, i, c, s, p, a, ss) {
    const tt = getCostTrie(t, ss);
    const curr = tt.c[i];
    if (curr <= c || c > limit)
      return void 0;
    tt.c[i] = c;
    pathHeap.add({ n, i, c, s, p, t: tt, a });
  }
}
function delLetters(pNode, weightMap, letters, storePath) {
  const { t, n } = pNode;
  const trie = weightMap.insDel;
  let ii = pNode.i;
  const cost0 = pNode.c - pNode.i;
  const len = letters.length;
  for (let nn = trie.n; ii < len && nn; ) {
    const tt = nn[letters[ii]];
    if (!tt)
      return;
    ++ii;
    if (tt.c !== void 0) {
      storePath(t, n, ii, cost0 + tt.c, "", pNode, "d", "");
    }
    nn = tt.n;
  }
}
function insLetters(p, weightMap, _letters, storePath) {
  const { t, i, c, n } = p;
  const cost0 = c;
  searchTrieCostNodesMatchingTrie2(weightMap.insDel, n, (s, tc, n2) => {
    if (tc.c !== void 0) {
      storePath(t, n2, i, cost0 + tc.c, s, p, "i", s);
    }
  });
}
function repLetters(pNode, weightMap, letters, storePath) {
  const node = pNode.n;
  const pt = pNode.t;
  const cost0 = pNode.c;
  const len = letters.length;
  const trie = weightMap.replace;
  let i = pNode.i;
  for (let n = trie.n; i < len && n; ) {
    const t = n[letters[i]];
    if (!t)
      return;
    ++i;
    const tInsert = t.t;
    if (tInsert) {
      searchTrieCostNodesMatchingTrie2(tInsert, node, (s, tt, n2) => {
        const c = tt.c;
        if (c === void 0) {
          return;
        }
        storePath(pt, n2, i, cost0 + c + (tt.p || 0), s, pNode, "r", s);
      });
    }
    n = t.n;
  }
}
function createCostTrie() {
  return { c: [], t: /* @__PURE__ */ Object.create(null) };
}
function getCostTrie(t, s) {
  var _a3, _b;
  if (s.length == 1) {
    return (_a3 = t.t)[s] ?? (_a3[s] = createCostTrie());
  }
  if (!s) {
    return t;
  }
  let tt = t;
  for (const c of s) {
    tt = (_b = tt.t)[c] ?? (_b[c] = createCostTrie());
  }
  return tt;
}
function pNodeToWord(p) {
  const parts = [];
  let n = p;
  while (n) {
    parts.push(n.s);
    n = n.p;
  }
  parts.reverse();
  return parts.join("");
}
function specialChars(options) {
  const charSet = /* @__PURE__ */ Object.create(null);
  for (const c of Object.values(options)) {
    charSet[c] = true;
  }
  return charSet;
}
function searchTrieCostNodesMatchingTrie2(trie, node, emit, s = "") {
  const n = trie.n;
  if (!n)
    return;
  for (const [key, c] of node.entries()) {
    const t = n[key];
    if (!t)
      continue;
    const pfx = s + key;
    emit(pfx, t, c);
    if (t.n) {
      searchTrieCostNodesMatchingTrie2(t, c, emit, pfx);
    }
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlobBuilder.js
var import_node_assert2 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/constants.js
var COMPOUND_FIX = "+";
var OPTIONAL_COMPOUND_FIX = "*";
var CASE_INSENSITIVE_PREFIX = "~";
var FORBID_PREFIX = "!";
var LINE_COMMENT = "#";
var IDENTITY_PREFIX = "=";
var defaultTrieInfo = Object.freeze({
  compoundCharacter: COMPOUND_FIX,
  forbiddenWordPrefix: FORBID_PREFIX,
  stripCaseAndAccentsPrefix: CASE_INSENSITIVE_PREFIX,
  isCaseAware: true,
  hasForbiddenWords: false,
  hasCompoundWords: false,
  hasNonStrictWords: false
});

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/mergeDefaults.js
function mergeDefaults(value, defaultValue) {
  const result = { ...defaultValue };
  if (value) {
    for (const [k, v] of Object.entries(value)) {
      if (k in result) {
        result[k] = v ?? result[k];
      }
    }
  }
  return result;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/mergeOptionalWithDefaults.js
function mergeOptionalWithDefaults(...options) {
  return options.reduce((acc, opt) => mergeDefaults(opt, acc), defaultTrieInfo);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/text.js
function expandCharacterSet(line, rangeChar = "-") {
  const charSet = /* @__PURE__ */ new Set();
  let mode = 0;
  let prev = "";
  for (const char of line) {
    if (mode) {
      expandRange(prev, char).forEach((a) => charSet.add(a));
      mode = 0;
    }
    if (char === rangeChar && prev) {
      mode = 1;
      continue;
    }
    charSet.add(char);
    prev = char;
  }
  if (mode)
    charSet.add(rangeChar);
  return charSet;
}
function expandRange(a, b) {
  const values = [];
  const end = b.codePointAt(0);
  const begin = a.codePointAt(0);
  if (!(begin && end))
    return values;
  for (let i = begin; i <= end; ++i) {
    values.push(String.fromCodePoint(i));
  }
  return values;
}
function caseForms(letter, locale) {
  const forms2 = /* @__PURE__ */ new Set([letter]);
  function tryCases(s) {
    forms2.add(s.toLocaleLowerCase(locale));
    forms2.add(s.toLocaleUpperCase(locale));
  }
  tryCases(letter);
  [...forms2].forEach(tryCases);
  return [...forms2].filter((a) => !!a);
}
function accentForms(letter) {
  const forms2 = /* @__PURE__ */ new Set([letter, letter.normalize("NFC"), letter.normalize("NFD")]);
  return forms2;
}
function stripAccents(characters) {
  return characters.normalize("NFD").replaceAll(new RegExp("\\p{M}", "gu"), "");
}
function stripNonAccents(characters) {
  return characters.normalize("NFD").replaceAll(/[^\p{M}]/gu, "");
}
function isValidUtf16Character(char) {
  const len = char.length;
  const code = char.charCodeAt(0) & 64512;
  const valid = len === 1 && (code & 63488) !== 55296 || // eslint-disable-next-line unicorn/prefer-code-point
  len === 2 && (code & 64512) === 55296 && (char.charCodeAt(1) & 64512) === 56320;
  return valid;
}
function assertValidUtf16Character(char) {
  if (!isValidUtf16Character(char)) {
    const len = char.length;
    const codes3 = toCharCodes(char.slice(0, 2)).map((c) => "0x" + ("0000" + c.toString(16)).slice(-4));
    let message;
    if (len == 1) {
      message = `Invalid utf16 character, lone surrogate: ${codes3[0]}`;
    } else if (len == 2) {
      message = `Invalid utf16 character, not a valid surrogate pair: [${codes3.join(", ")}]`;
    } else {
      message = `Invalid utf16 character, must be a single character, found: ${len}`;
    }
    throw new Error(message);
  }
}
function toCharCodes(s) {
  const values = [];
  for (let i = 0; i < s.length; ++i) {
    values.push(s.charCodeAt(i));
  }
  return values;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/Utf8.js
function encodeUtf8N_BE(code) {
  if (code < 128) {
    return code;
  }
  if (code < 2048) {
    return 49280 | (code & 1984) << 2 | code & 63;
  }
  if (code < 65536) {
    return 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
  }
  return 4034953344 + ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
}
var Utf8Accumulator = class _Utf8Accumulator {
  remaining = 0;
  value = 0;
  decode(byte) {
    let remaining = this.remaining;
    if (byte & ~255)
      return this.reset();
    if ((byte & 128) === 0) {
      if (remaining)
        return this.reset();
      return byte;
    }
    if (remaining) {
      if ((byte & 192) !== 128)
        return this.reset();
      let value = this.value;
      value = value << 6 | byte & 63;
      this.value = value;
      remaining -= 1;
      this.remaining = remaining;
      return remaining ? void 0 : value;
    }
    if ((byte & 224) === 192) {
      this.value = byte & 31;
      this.remaining = 1;
      return void 0;
    }
    if ((byte & 240) === 224) {
      this.value = byte & 15;
      this.remaining = 2;
      return void 0;
    }
    if ((byte & 248) === 240) {
      this.value = byte & 7;
      this.remaining = 3;
      return void 0;
    }
    return this.reset();
  }
  reset() {
    this.remaining = 0;
    this.value = 0;
    return 65533;
  }
  clone(into = new _Utf8Accumulator()) {
    into.remaining = this.remaining;
    into.value = this.value;
    return into;
  }
  static isMultiByte(v) {
    return (v & 128) !== 0;
  }
  static isSingleByte(v) {
    return (v & 128) === 0;
  }
  static create() {
    return new this();
  }
};
function encodeTextToUtf8Into(text, into, offset = 0) {
  let i = offset;
  const len = text.length;
  for (let j = 0; j < len; j++) {
    let code = text.charCodeAt(j);
    code = (code & 63488) === 55296 ? text.codePointAt(j++) || 0 : code;
    if (code < 128) {
      into[i++] = code;
      continue;
    }
    if (code < 2048) {
      const u2 = 49280 | (code & 1984) << 2 | code & 63;
      into[i++] = u2 >>> 8;
      into[i++] = u2 & 255;
      continue;
    }
    if (code < 65536) {
      const u2 = 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
      into[i++] = u2 >>> 16;
      into[i++] = u2 >>> 8 & 255;
      into[i++] = u2 & 255;
      continue;
    }
    const u = 4034953344 | ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
    into[i++] = u >>> 24 & 255;
    into[i++] = u >>> 16 & 255;
    into[i++] = u >>> 8 & 255;
    into[i++] = u & 255;
  }
  return i - offset;
}
function encodeTextToUtf8(text) {
  const array = new Array(text.length);
  const len = encodeTextToUtf8Into(text, array);
  array.length !== len && (array.length = len);
  return array;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/CharIndex.js
var emptySeq = [0];
Object.freeze(emptySeq);
var _charToUtf8SeqMap, _lastWord, _lastWordSeq, _multiByteChars;
var CharIndex = class {
  constructor(charIndex) {
    __publicField(this, "charIndex");
    __privateAdd(this, _charToUtf8SeqMap);
    __privateAdd(this, _lastWord, "");
    __privateAdd(this, _lastWordSeq, []);
    __privateAdd(this, _multiByteChars);
    this.charIndex = charIndex;
    __privateSet(this, _charToUtf8SeqMap, buildCharIndexSequenceMap(charIndex));
    __privateSet(this, _multiByteChars, [...__privateGet(this, _charToUtf8SeqMap).values()].some((c) => c.length > 1));
  }
  getCharUtf8Seq(c) {
    const found = __privateGet(this, _charToUtf8SeqMap).get(c);
    if (found)
      return found;
    const s = encodeTextToUtf8(c);
    __privateGet(this, _charToUtf8SeqMap).set(c, s);
    return s;
  }
  wordToUtf8Seq(word) {
    if (__privateGet(this, _lastWord) === word)
      return __privateGet(this, _lastWordSeq);
    const seq = encodeTextToUtf8(word);
    __privateSet(this, _lastWord, word);
    __privateSet(this, _lastWordSeq, seq);
    return seq;
  }
  indexContainsMultiByteChars() {
    return __privateGet(this, _multiByteChars);
  }
  get size() {
    return this.charIndex.length;
  }
  toJSON() {
    return { charIndex: this.charIndex };
  }
};
_charToUtf8SeqMap = new WeakMap();
_lastWord = new WeakMap();
_lastWordSeq = new WeakMap();
_multiByteChars = new WeakMap();
function buildCharIndexSequenceMap(charIndex) {
  const map3 = /* @__PURE__ */ new Map();
  for (const key of charIndex) {
    map3.set(key, encodeTextToUtf8(key));
  }
  return map3;
}
var _mapIdxToSeq;
var CharIndexBuilder = class {
  constructor() {
    __publicField(this, "charIndex", []);
    __publicField(this, "charIndexMap", /* @__PURE__ */ new Map());
    __publicField(this, "charIndexSeqMap", /* @__PURE__ */ new Map());
    __privateAdd(this, _mapIdxToSeq, /* @__PURE__ */ new Map());
    this.getUtf8Value("");
  }
  getUtf8Value(c) {
    const found = this.charIndexMap.get(c);
    if (found !== void 0) {
      return found;
    }
    const nc = c.normalize("NFC");
    this.charIndex.push(nc);
    const utf8 = encodeUtf8N_BE(nc.codePointAt(0) || 0);
    this.charIndexMap.set(c, utf8);
    this.charIndexMap.set(nc, utf8);
    this.charIndexMap.set(c.normalize("NFD"), utf8);
    return utf8;
  }
  utf8ValueToUtf8Seq(idx2) {
    const found = __privateGet(this, _mapIdxToSeq).get(idx2);
    if (found !== void 0) {
      return found;
    }
    const seq = splitUtf8(idx2);
    __privateGet(this, _mapIdxToSeq).set(idx2, seq);
    return seq;
  }
  charToUtf8Seq(c) {
    const idx2 = this.getUtf8Value(c);
    return this.utf8ValueToUtf8Seq(idx2);
  }
  wordToUtf8Seq(word) {
    const seq = new Array(word.length);
    let i = 0;
    for (const c of word) {
      const idx2 = this.getUtf8Value(c);
      const cSep = this.utf8ValueToUtf8Seq(idx2);
      if (typeof cSep === "number") {
        seq[i++] = cSep;
        continue;
      }
      for (const cIdx of cSep) {
        seq[i++] = cIdx;
      }
    }
    if (seq.length !== i)
      seq.length = i;
    return seq;
  }
  get size() {
    return this.charIndex.length;
  }
  build() {
    return new CharIndex(this.charIndex);
  }
};
_mapIdxToSeq = new WeakMap();
function splitUtf8(utf8) {
  if (utf8 <= 255)
    return [utf8];
  if (utf8 <= 65535)
    return [utf8 >> 8 & 255, utf8 & 255];
  if (utf8 <= 16777215)
    return [utf8 >> 16 & 255, utf8 >> 8 & 255, utf8 & 255];
  return [utf8 >> 24 & 255, utf8 >> 16 & 255, utf8 >> 8 & 255, utf8 & 255].filter((v) => v);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlobBitMaskInfo.js
function extractInfo(info) {
  const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = info;
  return {
    NodeMaskEOW,
    NodeMaskChildCharIndex,
    NodeChildRefShift
  };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlobInternals.js
var FastTrieBlobInternals = class {
  nodes;
  charIndex;
  NodeMaskEOW;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  info;
  constructor(nodes, charIndex, maskInfo, info) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.info = mergeOptionalWithDefaults(info);
  }
};
var FastTrieBlobInternalsAndMethods = class extends FastTrieBlobInternals {
  nodeFindNode;
  nodeFindExact;
  nodeGetChild;
  isForbidden;
  findExact;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, maskInfo, info, trieMethods) {
    super(nodes, charIndex, maskInfo, info);
    this.nodeFindExact = trieMethods.nodeFindExact;
    this.nodeGetChild = trieMethods.nodeGetChild;
    this.isForbidden = trieMethods.isForbidden;
    this.findExact = trieMethods.findExact;
    this.nodeFindNode = trieMethods.nodeFindNode;
    this.hasForbiddenWords = trieMethods.hasForbiddenWords;
    this.hasCompoundWords = trieMethods.hasCompoundWords;
    this.hasNonStrictWords = trieMethods.hasNonStrictWords;
  }
};
function sortNodes(nodes, mask) {
  if (Object.isFrozen(nodes)) {
    assertSorted(nodes, mask);
    return nodes;
  }
  for (let i = 0; i < nodes.length; ++i) {
    let node = nodes[i];
    if (node.length > 2) {
      const isFrozen = Object.isFrozen(node);
      node = isFrozen ? Uint32Array.from(node) : node;
      const nodeInfo = node[0];
      node[0] = 0;
      node.sort((a, b) => !a ? -1 : !b ? 1 : (a & mask) - (b & mask));
      node[0] = nodeInfo;
      if (isFrozen) {
        nodes[i] = node;
        Object.freeze(node);
      }
    }
  }
  Object.freeze(nodes);
  return nodes;
}
function assertSorted(nodes, mask) {
  for (let i = 0; i < nodes.length; ++i) {
    const node = nodes[i];
    if (node.length > 2) {
      let last = -1;
      for (let j = 1; j < node.length; ++j) {
        const n = node[j] & mask;
        if (n < last) {
          throw new Error(`Node ${i} is not sorted. ${last} > ${n}`);
        }
        last = n;
      }
    }
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlobIRoot.js
var EmptyKeys2 = Object.freeze([]);
var EmptyNodes = Object.freeze([]);
var EmptyEntries2 = Object.freeze([]);
var FastTrieBlobINode = class _FastTrieBlobINode {
  trie;
  nodeIdx;
  id;
  node;
  eow;
  _keys;
  _count;
  _size;
  _chained;
  _nodesEntries;
  _entries;
  _values;
  charToIdx;
  constructor(trie, nodeIdx) {
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node[0] & trie.NodeMaskEOW);
    this._count = node.length - 1;
    this.id = nodeIdx;
    this.findExact = (word) => trie.nodeFindExact(nodeIdx, word);
  }
  /** get keys to children */
  keys() {
    if (this._keys)
      return this._keys;
    if (!this._count)
      return EmptyKeys2;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count)
      return EmptyNodes;
    if (this._values)
      return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries)
      return this._entries;
    if (!this._count)
      return EmptyEntries2;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new _FastTrieBlobINode(this.trie, value)]);
    return this._entries;
  }
  /** get child ITrieNode */
  get(char) {
    const idx2 = this.trie.nodeGetChild(this.id, char);
    if (idx2 === void 0)
      return void 0;
    return new _FastTrieBlobINode(this.trie, idx2);
  }
  getNode(chars) {
    const idx2 = this.trie.nodeFindNode(this.id, chars);
    if (idx2 === void 0)
      return void 0;
    return new _FastTrieBlobINode(this.trie, idx2);
  }
  has(char) {
    const idx2 = this.trie.nodeGetChild(this.id, char);
    return idx2 !== void 0;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.node[keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new _FastTrieBlobINode(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m)
      return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys3 = this.keys();
    for (let i = 0; i < keys3.length; ++i) {
      map3[keys3[i]] = i;
    }
    this.charToIdx = map3;
    return map3;
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.id, word);
  }
  isForbidden(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.forbiddenWordPrefix);
    if (n === void 0)
      return false;
    return this.trie.nodeFindExact(n, word);
  }
  findCaseInsensitive(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.stripCaseAndAccentsPrefix);
    if (n === void 0)
      return false;
    return this.trie.nodeFindExact(n, word);
  }
  containsChainedIndexes() {
    if (this._chained !== void 0)
      return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const len = this._count;
    const node = this.node;
    for (let i = 1; i <= len && !found; ++i) {
      const entry = node[i];
      const codePoint = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(codePoint);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries)
      return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.node;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0; i < this._count; ++i) {
        const entry = nodes[i + 1];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{ n: this.node, c: 1, acc }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { n: node, c: off } = s;
      if (off >= node.length) {
        --depth;
        continue;
      }
      ++s.c;
      const entry = node[off];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc2 = s.acc.clone();
      const codePoint = acc2.decode(charIdx);
      if (codePoint !== void 0) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx];
        continue;
      }
      const idx2 = entry >>> NodeChildRefShift;
      const ss = stack[++depth];
      if (ss) {
        ss.n = nodes[idx2];
        ss.c = 1;
        ss.acc = acc2;
      } else {
        stack[depth] = { n: nodes[idx2], c: 1, acc: acc2 };
      }
    }
    return entries;
  }
  get size() {
    if (this._size === void 0) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
var FastTrieBlobIRoot = class extends FastTrieBlobINode {
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(trie, nodeIdx) {
    super(trie, nodeIdx);
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new FastTrieBlobINode(this.trie, id);
  }
  find(word, strict) {
    let found = this.findExact(word);
    if (found) {
      return { found: word, compoundUsed: false, caseMatched: true };
    }
    if (strict)
      return void 0;
    found = this.findCaseInsensitive(word);
    return found ? { found: word, compoundUsed: false, caseMatched: false } : void 0;
  }
  get info() {
    return this.trie.info;
  }
  get forbidPrefix() {
    return this.trie.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.trie.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.trie.info.stripCaseAndAccentsPrefix;
  }
};

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/TrieBlob.js
var import_node_os = require("os");

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/TrieBlobIRoot.js
var _a;
var TrieBlobInternals = class {
  nodes;
  charIndex;
  NodeMaskEOW;
  NodeMaskNumChildren;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  nodeFindExact;
  isForbidden;
  findExact;
  nodeGetChild;
  nodeFindNode;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, maskInfo, methods) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeMaskNumChildren, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskNumChildren = NodeMaskNumChildren;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.nodeFindExact = methods.nodeFindExact;
    this.isForbidden = methods.isForbidden;
    this.findExact = methods.findExact;
    this.nodeGetChild = methods.nodeGetChild;
    this.nodeFindNode = methods.nodeFindNode;
    this.hasForbiddenWords = methods.hasForbiddenWords;
    this.hasCompoundWords = methods.hasCompoundWords;
    this.hasNonStrictWords = methods.hasNonStrictWords;
  }
};
var EmptyKeys3 = Object.freeze([]);
var EmptyNodes2 = Object.freeze([]);
var EmptyEntries3 = Object.freeze([]);
var _TrieBlobINode_instances, getChildNodeIdx_fn, getChildNode_fn;
var TrieBlobINode = class {
  constructor(trie, nodeIdx) {
    __privateAdd(this, _TrieBlobINode_instances);
    __publicField(this, "trie");
    __publicField(this, "nodeIdx");
    __publicField(this, "id");
    __publicField(this, "node");
    __publicField(this, "eow");
    __publicField(this, "_keys");
    __publicField(this, "_count");
    __publicField(this, "_size");
    __publicField(this, "_chained");
    __publicField(this, "_nodesEntries");
    __publicField(this, "_entries");
    __publicField(this, "_values");
    __publicField(this, "charToIdx");
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node & trie.NodeMaskEOW);
    this._count = node & trie.NodeMaskNumChildren;
    this.id = nodeIdx;
  }
  /** get keys to children */
  keys() {
    if (this._keys)
      return this._keys;
    if (!this._count)
      return EmptyKeys3;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count)
      return EmptyNodes2;
    if (this._values)
      return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries)
      return this._entries;
    if (!this._count)
      return EmptyEntries3;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new _a(this.trie, value)]);
    return this._entries;
  }
  /** get child ITrieNode */
  get(char) {
    return __privateMethod(this, _TrieBlobINode_instances, getChildNode_fn).call(this, char);
  }
  has(char) {
    return this.trie.nodeGetChild(this.nodeIdx, char) !== void 0;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.trie.nodes[this.nodeIdx + keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new _a(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m)
      return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys3 = this.keys();
    for (let i = 0; i < keys3.length; ++i) {
      map3[keys3[i]] = i;
    }
    this.charToIdx = map3;
    return map3;
  }
  getNode(word) {
    const n = this.trie.nodeFindNode(this.nodeIdx, word);
    return n === void 0 ? void 0 : new _a(this.trie, n);
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.nodeIdx, word);
  }
  containsChainedIndexes() {
    if (this._chained !== void 0)
      return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const offset = this.nodeIdx + 1;
    const nodes = this.trie.nodes;
    const len = this._count;
    for (let i = 0; i < len && !found; ++i) {
      const entry = nodes[i + offset];
      const charIdx = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(charIdx);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries)
      return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.trie.nodes;
      const offset = this.nodeIdx + 1;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0; i < this._count; ++i) {
        const entry = nodes[offset + i];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const NodeMaskNumChildren = this.trie.NodeMaskNumChildren;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{ nodeIdx: this.nodeIdx + 1, lastIdx: this.nodeIdx + this._count, acc }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { nodeIdx, lastIdx } = s;
      if (nodeIdx > lastIdx) {
        --depth;
        continue;
      }
      ++s.nodeIdx;
      const entry = nodes[nodeIdx];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc2 = s.acc.clone();
      const codePoint = acc2.decode(charIdx);
      if (codePoint !== void 0) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx2 = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx2];
        continue;
      }
      const idx2 = entry >>> NodeChildRefShift;
      const lIdx = idx2 + (nodes[idx2] & NodeMaskNumChildren);
      const ss = stack[++depth];
      if (ss) {
        ss.nodeIdx = idx2 + 1;
        ss.lastIdx = lIdx;
        ss.acc = acc2;
      } else {
        stack[depth] = { nodeIdx: idx2 + 1, lastIdx: lIdx, acc: acc2 };
      }
    }
    return entries;
  }
  get size() {
    if (this._size === void 0) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
_TrieBlobINode_instances = new WeakSet();
getChildNodeIdx_fn = function(char) {
  return this.trie.nodeGetChild(this.nodeIdx, char);
};
getChildNode_fn = function(char) {
  if (this.charToIdx) {
    const keyIdx = this.charToIdx[char];
    if (keyIdx === void 0)
      return void 0;
    return this.child(keyIdx);
  }
  const idx2 = __privateMethod(this, _TrieBlobINode_instances, getChildNodeIdx_fn).call(this, char);
  if (idx2 === void 0)
    return void 0;
  return new _a(this.trie, idx2);
};
_a = TrieBlobINode;
var TrieBlobIRoot = class extends TrieBlobINode {
  info;
  find;
  isForbidden;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(trie, nodeIdx, info, methods) {
    super(trie, nodeIdx);
    this.info = info;
    this.find = methods.find;
    this.isForbidden = trie.isForbidden;
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new TrieBlobINode(this.trie, id);
  }
  get forbidPrefix() {
    return this.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.info.stripCaseAndAccentsPrefix;
  }
};

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/TrieBlob.js
var _a2;
var NodeHeaderNumChildrenBits = 8;
var NodeHeaderNumChildrenShift = 0;
var HEADER_SIZE_UINT32 = 8;
var HEADER_SIZE = HEADER_SIZE_UINT32 * 4;
var HEADER_OFFSET = 0;
var HEADER_OFFSET_SIG = HEADER_OFFSET;
var HEADER_OFFSET_ENDIAN = HEADER_OFFSET_SIG + 8;
var HEADER_OFFSET_VERSION = HEADER_OFFSET_ENDIAN + 4;
var HEADER_OFFSET_NODES = HEADER_OFFSET_VERSION + 4;
var HEADER_OFFSET_NODES_LEN = HEADER_OFFSET_NODES + 4;
var HEADER_OFFSET_CHAR_INDEX = HEADER_OFFSET_NODES_LEN + 4;
var HEADER_OFFSET_CHAR_INDEX_LEN = HEADER_OFFSET_CHAR_INDEX + 4;
var HEADER = {
  header: HEADER_OFFSET,
  sig: HEADER_OFFSET_SIG,
  version: HEADER_OFFSET_VERSION,
  endian: HEADER_OFFSET_ENDIAN,
  nodes: HEADER_OFFSET_NODES,
  nodesLen: HEADER_OFFSET_NODES_LEN,
  charIndex: HEADER_OFFSET_CHAR_INDEX,
  charIndexLen: HEADER_OFFSET_CHAR_INDEX_LEN
};
var headerSig = "TrieBlob";
var version = "00.01.00";
var endianSig = 67305985;
var _forbidIdx, _compoundIdx, _nonStrictIdx, _size, _iTrieRoot, _nodes8, _beAdj, _TrieBlob_instances, hasWord_fn, findNode_fn, lookupNode_fn;
var TrieBlob = class {
  constructor(nodes, charIndex, info) {
    __privateAdd(this, _TrieBlob_instances);
    __publicField(this, "nodes");
    __publicField(this, "charIndex");
    __publicField(this, "info");
    __privateAdd(this, _forbidIdx);
    __privateAdd(this, _compoundIdx);
    __privateAdd(this, _nonStrictIdx);
    __privateAdd(this, _size);
    __privateAdd(this, _iTrieRoot);
    /** the nodes data in 8 bits */
    __privateAdd(this, _nodes8);
    __privateAdd(this, _beAdj, (0, import_node_os.endianness)() === "BE" ? 3 : 0);
    __publicField(this, "wordToCharacters", (word) => [...word]);
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    this.nodes = nodes;
    this.charIndex = charIndex;
    trieBlobSort(nodes);
    this.info = mergeOptionalWithDefaults(info);
    __privateSet(this, _nodes8, new Uint8Array(nodes.buffer, nodes.byteOffset + __privateGet(this, _beAdj)));
    __privateSet(this, _forbidIdx, this._lookupNode(0, this.info.forbiddenWordPrefix));
    __privateSet(this, _compoundIdx, this._lookupNode(0, this.info.compoundCharacter));
    __privateSet(this, _nonStrictIdx, this._lookupNode(0, this.info.stripCaseAndAccentsPrefix));
    this.hasForbiddenWords = !!__privateGet(this, _forbidIdx);
    this.hasCompoundWords = !!__privateGet(this, _compoundIdx);
    this.hasNonStrictWords = !!__privateGet(this, _nonStrictIdx);
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToNodeCharIndexSequence(letter) {
    return this.charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, 0, word);
  }
  isForbiddenWord(word) {
    return !!__privateGet(this, _forbidIdx) && __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, __privateGet(this, _forbidIdx), word);
  }
  /**
   * Try to find the word in the trie. The word must be normalized.
   * If `strict` is `true` the case and accents must match.
   * Compound words are supported assuming that the compound character is in the trie.
   *
   * @param word - the word to find (normalized)
   * @param strict - if `true` the case and accents must match.
   */
  find(word, strict) {
    if (!this.hasCompoundWords) {
      const found = __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, 0, word);
      if (found)
        return { found: word, compoundUsed: false, caseMatched: true };
      if (strict || !__privateGet(this, _nonStrictIdx))
        return { found: false, compoundUsed: false, caseMatched: false };
      return { found: __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, __privateGet(this, _nonStrictIdx), word) && word, compoundUsed: false, caseMatched: false };
    }
    return void 0;
  }
  getRoot() {
    return __privateGet(this, _iTrieRoot) ?? __privateSet(this, _iTrieRoot, this._getRoot());
  }
  _getRoot() {
    const trieData = new TrieBlobInternals(this.nodes, this.charIndex, {
      NodeMaskEOW: _a2.NodeMaskEOW,
      NodeMaskNumChildren: _a2.NodeMaskNumChildren,
      NodeMaskChildCharIndex: _a2.NodeMaskChildCharIndex,
      NodeChildRefShift: _a2.NodeChildRefShift
    }, {
      nodeFindExact: (idx2, word) => __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, idx2, word),
      nodeGetChild: (idx2, letter) => this._lookupNode(idx2, letter),
      nodeFindNode: (idx2, word) => __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, idx2, word),
      isForbidden: (word) => this.isForbiddenWord(word),
      findExact: (word) => this.has(word),
      hasCompoundWords: this.hasCompoundWords,
      hasForbiddenWords: this.hasForbiddenWords,
      hasNonStrictWords: this.hasNonStrictWords
    });
    return new TrieBlobIRoot(trieData, 0, this.info, {
      find: (word, strict) => this.find(word, strict)
    });
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  /**
   * Find the node index for the given character.
   * @param nodeIdx - node index to start the search
   * @param char - character to look for
   * @returns
   */
  _lookupNode(nodeIdx, char) {
    const indexSeq = this.letterToNodeCharIndexSequence(char);
    const currNodeIdx = __privateMethod(this, _TrieBlob_instances, lookupNode_fn).call(this, nodeIdx, indexSeq);
    return currNodeIdx;
  }
  *words() {
    const NodeMaskNumChildren = _a2.NodeMaskNumChildren;
    const NodeMaskEOW = _a2.NodeMaskEOW;
    const NodeMaskChildCharIndex = _a2.NodeMaskChildCharIndex;
    const NodeChildRefShift = _a2.NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{ nodeIdx: 0, pos: 0, word: "", acc: Utf8Accumulator.create() }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, acc } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node & NodeMaskEOW) {
        yield word;
      }
      const len = node & NodeMaskNumChildren;
      if (pos >= len) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = nodes[nodeIdx + nextPos];
      const nAcc = acc.clone();
      const codePoint = nAcc.decode(entry & NodeMaskChildCharIndex);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        acc: nAcc
      };
    }
  }
  get size() {
    if (__privateGet(this, _size))
      return __privateGet(this, _size);
    const NodeMaskNumChildren = _a2.NodeMaskNumChildren;
    const nodes = this.nodes;
    let p = 0;
    let count3 = 0;
    while (p < nodes.length) {
      ++count3;
      p += (nodes[p] & NodeMaskNumChildren) + 1;
    }
    __privateSet(this, _size, count3);
    return count3;
  }
  toJSON() {
    return {
      options: this.info,
      nodes: nodesToJson(this.nodes),
      charIndex: this.charIndex
    };
  }
  encodeBin() {
    const charIndex = Buffer.from(this.charIndex.charIndex.join("\n"));
    const charIndexLen = charIndex.byteLength + 3 & ~3;
    const nodeOffset = HEADER_SIZE + charIndexLen;
    const size = nodeOffset + this.nodes.length * 4;
    const useLittle = isLittleEndian();
    const buffer = Buffer.alloc(size);
    const header = new DataView(buffer.buffer);
    const nodeData = new Uint8Array(this.nodes.buffer);
    buffer.write(headerSig, HEADER.sig, "utf8");
    buffer.write(version, HEADER.version, "utf8");
    header.setUint32(HEADER.endian, endianSig, useLittle);
    header.setUint32(HEADER.nodes, nodeOffset, useLittle);
    header.setUint32(HEADER.nodesLen, this.nodes.length, useLittle);
    header.setUint32(HEADER.charIndex, HEADER_SIZE, useLittle);
    header.setUint32(HEADER.charIndexLen, charIndex.length, useLittle);
    buffer.set(charIndex, HEADER_SIZE);
    buffer.set(nodeData, nodeOffset);
    return buffer;
  }
  static decodeBin(blob) {
    if (!checkSig(blob)) {
      throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    }
    const header = new DataView(blob.buffer);
    const useLittle = isLittleEndian();
    if (header.getUint32(HEADER.endian, useLittle) !== endianSig) {
      throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    }
    const offsetNodes = header.getUint32(HEADER.nodes, useLittle);
    const lenNodes = header.getUint32(HEADER.nodesLen, useLittle);
    const offsetCharIndex = header.getUint32(HEADER.charIndex, useLittle);
    const lenCharIndex = header.getUint32(HEADER.charIndexLen, useLittle);
    const charIndex = Buffer.from(blob.subarray(offsetCharIndex, offsetCharIndex + lenCharIndex)).toString("utf8").split("\n");
    const nodes = new Uint32Array(blob.buffer, offsetNodes, lenNodes);
    const trieBlob = new _a2(nodes, new CharIndex(charIndex), defaultTrieInfo);
    return trieBlob;
  }
  static nodesView(trie) {
    return new Uint32Array(trie.nodes);
  }
};
_forbidIdx = new WeakMap();
_compoundIdx = new WeakMap();
_nonStrictIdx = new WeakMap();
_size = new WeakMap();
_iTrieRoot = new WeakMap();
_nodes8 = new WeakMap();
_beAdj = new WeakMap();
_TrieBlob_instances = new WeakSet();
/**
 * Check if the word is in the trie starting at the given node index.
 */
hasWord_fn = function(nodeIdx, word) {
  const nodeIdxFound = __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, nodeIdx, word);
  if (!nodeIdxFound)
    return false;
  const node = this.nodes[nodeIdxFound];
  const m = _a2.NodeMaskEOW;
  return (node & m) === m;
};
findNode_fn = function(nodeIdx, word) {
  const wordIndexes = this.wordToUtf8Seq(word);
  return __privateMethod(this, _TrieBlob_instances, lookupNode_fn).call(this, nodeIdx, wordIndexes);
};
/**
 * Find the node index for the given Utf8 character sequence.
 * @param nodeIdx - node index to start the search
 * @param seq - the byte sequence of the character to look for
 * @returns
 */
lookupNode_fn = function(nodeIdx, seq) {
  const NodeMaskNumChildren = _a2.NodeMaskNumChildren;
  const NodeChildRefShift = _a2.NodeChildRefShift;
  const nodes = this.nodes;
  const nodes8 = __privateGet(this, _nodes8);
  const wordIndexes = seq;
  const len = wordIndexes.length;
  let node = nodes[nodeIdx];
  for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
    const letterIdx = wordIndexes[p];
    const count3 = node & NodeMaskNumChildren;
    const idx4 = nodeIdx << 2;
    if (count3 > 15) {
      const pEnd = idx4 + (count3 << 2);
      let i2 = idx4 + 4;
      let j = pEnd;
      while (j - i2 >= 4) {
        const m = i2 + j >> 1 & ~3;
        if (nodes8[m] < letterIdx) {
          i2 = m + 4;
        } else {
          j = m;
        }
      }
      if (i2 > pEnd || nodes8[i2] !== letterIdx)
        return void 0;
      nodeIdx = nodes[i2 >> 2] >>> NodeChildRefShift;
      continue;
    }
    let i = idx4 + count3 * 4;
    for (; i > idx4; i -= 4) {
      if (nodes8[i] === letterIdx) {
        break;
      }
    }
    if (i <= idx4)
      return void 0;
    nodeIdx = nodes[i >> 2] >>> NodeChildRefShift;
  }
  return nodeIdx;
};
// #prepLookup() {
//     const NodeMaskNumChildren = TrieBlob.NodeMaskNumChildren;
//     const NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
//     const NodeChildRefShift = TrieBlob.NodeChildRefShift;
//     const stack: WalkStackItem[] = [];
//     const iter = this.#walk(stack)[Symbol.iterator]();
//     const nodes = this.nodes;
//     let n: IteratorResult<number>;
//     let deeper = true;
//     while (!(n = iter.next(deeper)).done) {
//         const depth = n.value;
//         const nodeIdx = stack[depth].nodeIdx;
//         const node = nodes[nodeIdx];
//         const len = node & NodeMaskNumChildren;
//         deeper = len > lookupCount;
//         if (deeper) {
//             const map = new Map<number, number>();
//             this.#nodeIdxLookup.set(nodeIdx, map);
//             for (let i = len; i > 0; --i) {
//                 const n = nodes[i + nodeIdx];
//                 map.set(n & NodeMaskChildCharIndex, n >> NodeChildRefShift);
//             }
//             // const parent = depth > 0 ? stack[depth - 1].nodeIdx : -1;
//             // console.error('Node %d has %d children, parent %d', nodeIdx, len, parent);
//         }
//     }
// }
// Keeping this for a bit, until we are sure we don't need it.
// *#walk(wStack: WalkStackItem[]): Generator<number, undefined, undefined | boolean> {
//     const NodeMaskNumChildren = TrieBlob.NodeMaskNumChildren;
//     const NodeChildRefShift = TrieBlob.NodeChildRefShift;
//     const nodes = this.nodes;
//     const stack = wStack;
//     stack[0] = { nodeIdx: 0, pos: 0 };
//     let depth = 0;
//     while (depth >= 0) {
//         const { nodeIdx, pos } = stack[depth];
//         const node = nodes[nodeIdx];
//         // pos is 0 when first entering a node
//         if (!pos) {
//             const deeper = yield depth;
//             if (deeper === false) {
//                 --depth;
//                 continue;
//             }
//         }
//         const len = node & NodeMaskNumChildren;
//         if (pos >= len) {
//             --depth;
//             continue;
//         }
//         const nextPos = ++stack[depth].pos;
//         const entry = nodes[nodeIdx + nextPos];
//         ++depth;
//         stack[depth] = stack[depth] || { nodeIdx: 0, pos: 0 };
//         (stack[depth].nodeIdx = entry >>> NodeChildRefShift), (stack[depth].pos = 0);
//     }
// }
__publicField(TrieBlob, "NodeMaskEOW", 256 & 65535);
__publicField(TrieBlob, "NodeMaskNumChildren", (1 << NodeHeaderNumChildrenBits) - 1 & 65535);
__publicField(TrieBlob, "NodeMaskNumChildrenShift", NodeHeaderNumChildrenShift);
__publicField(TrieBlob, "NodeChildRefShift", 8);
/**
 * Only 8 bits are reserved for the character index.
 * The max index is {@link TrieBlob.SpecialCharIndexMask} - 1.
 * Node chaining is used to reference higher character indexes.
 * - @see {@link TrieBlob.SpecialCharIndexMask}
 * - @see {@link TrieBlob.MaxCharIndex}
 */
__publicField(TrieBlob, "NodeMaskChildCharIndex", 255);
_a2 = TrieBlob;
function isLittleEndian() {
  const buf = new Uint8Array([1, 2, 3, 4]);
  const view = new DataView(buf.buffer);
  return view.getUint32(0, true) === 67305985;
}
function checkSig(blob) {
  if (blob.length < HEADER_SIZE) {
    return false;
  }
  const buf = Buffer.from(blob, 0, headerSig.length);
  if (buf.toString("utf8", 0, headerSig.length) !== headerSig) {
    return false;
  }
  return true;
}
var ErrorDecodeTrieBlob = class extends Error {
  constructor(message) {
    super(message);
  }
};
function nodesToJson(nodes) {
  function nodeElement(offset2) {
    const node = nodes[offset2];
    const numChildren = node & TrieBlob.NodeMaskNumChildren;
    const eow = !!(node & TrieBlob.NodeMaskEOW);
    const children = [];
    for (let i = 1; i <= numChildren; ++i) {
      children.push({
        c: ("00" + (nodes[offset2 + i] & TrieBlob.NodeMaskChildCharIndex).toString(16)).slice(-2),
        o: nodes[offset2 + i] >>> TrieBlob.NodeChildRefShift
      });
    }
    return { id: offset2, eow, n: offset2 + numChildren + 1, c: children };
  }
  const elements = [];
  let offset = 0;
  while (offset < nodes.length) {
    const e = nodeElement(offset);
    elements.push(e);
    offset = e.n;
  }
  return elements;
}
function trieBlobSort(data) {
  const MaskNumChildren = TrieBlob.NodeMaskNumChildren;
  const MaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  const limit = data.length;
  let idx2 = 0;
  let node = data[0];
  let nc = node & MaskNumChildren;
  for (; idx2 < limit; idx2 += nc + 1, node = data[idx2], nc = node & MaskNumChildren) {
    if (!nc)
      continue;
    const start = idx2 + 1;
    const end = start + nc;
    let last = 0;
    let i = start;
    for (; i < end; ++i) {
      const cIdx = data[i] & MaskChildCharIndex;
      if (last >= cIdx)
        break;
      last = cIdx;
    }
    if (i === end)
      continue;
    const sorted = data.slice(start, end).sort((a, b) => (a & MaskChildCharIndex) - (b & MaskChildCharIndex));
    sorted.forEach((v, i2) => data[start + i2] = v);
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlob.js
var checkSorted = false;
var _forbidIdx2, _compoundIdx2, _nonStrictIdx2, _FastTrieBlob_instances, has_fn, hasSorted_fn, lookupNode_fn2, searchNodeForChar_fn;
var _FastTrieBlob = class _FastTrieBlob {
  constructor(nodes, _charIndex, bitMasksInfo, info) {
    __privateAdd(this, _FastTrieBlob_instances);
    __publicField(this, "nodes");
    __publicField(this, "_charIndex");
    __publicField(this, "bitMasksInfo");
    __publicField(this, "info");
    __publicField(this, "_readonly", false);
    __privateAdd(this, _forbidIdx2);
    __privateAdd(this, _compoundIdx2);
    __privateAdd(this, _nonStrictIdx2);
    __publicField(this, "_iTrieRoot");
    __publicField(this, "wordToCharacters");
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    this.nodes = nodes;
    this._charIndex = _charIndex;
    this.bitMasksInfo = bitMasksInfo;
    this.info = info;
    this.wordToCharacters = (word) => [...word];
    __privateSet(this, _forbidIdx2, __privateMethod(this, _FastTrieBlob_instances, searchNodeForChar_fn).call(this, 0, this.info.forbiddenWordPrefix) || 0);
    __privateSet(this, _compoundIdx2, __privateMethod(this, _FastTrieBlob_instances, searchNodeForChar_fn).call(this, 0, this.info.compoundCharacter) || 0);
    __privateSet(this, _nonStrictIdx2, __privateMethod(this, _FastTrieBlob_instances, searchNodeForChar_fn).call(this, 0, this.info.stripCaseAndAccentsPrefix) || 0);
    this.hasForbiddenWords = !!__privateGet(this, _forbidIdx2);
    this.hasCompoundWords = !!__privateGet(this, _compoundIdx2);
    this.hasNonStrictWords = !!__privateGet(this, _nonStrictIdx2);
    if (checkSorted) {
      assertSorted(this.nodes, bitMasksInfo.NodeMaskChildCharIndex);
    }
  }
  wordToUtf8Seq(word) {
    return this._charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this._charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return __privateMethod(this, _FastTrieBlob_instances, has_fn).call(this, 0, word);
  }
  hasCaseInsensitive(word) {
    if (!__privateGet(this, _nonStrictIdx2))
      return false;
    return __privateMethod(this, _FastTrieBlob_instances, has_fn).call(this, __privateGet(this, _nonStrictIdx2), word);
  }
  *words() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const accumulator = Utf8Accumulator.create();
    const stack = [{ nodeIdx: 0, pos: 0, word: "", accumulator }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, accumulator: accumulator2 } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node[0] & NodeMaskEOW) {
        yield word;
      }
      if (pos >= node.length - 1) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = node[nextPos];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc = accumulator2.clone();
      const codePoint = acc.decode(charIdx);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        accumulator: acc
      };
    }
  }
  toTrieBlob() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const nodes = this.nodes;
    function calcNodeToIndex(nodes2) {
      let offset2 = 0;
      const idx2 = Array(nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        idx2[i] = offset2;
        offset2 += nodes2[i].length;
      }
      idx2[nodes2.length] = offset2;
      return idx2;
    }
    const nodeToIndex = calcNodeToIndex(nodes);
    const nodeElementCount = nodeToIndex[nodeToIndex.length - 1];
    const binNodes = new Uint32Array(nodeElementCount);
    const lenShift = TrieBlob.NodeMaskNumChildrenShift;
    const refShift = TrieBlob.NodeChildRefShift;
    let offset = 0;
    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      binNodes[offset++] = node.length - 1 << lenShift | node[0];
      for (let j = 1; j < node.length; ++j) {
        const v = node[j];
        const nodeRef = v >>> NodeChildRefShift;
        const charIndex = v & NodeMaskChildCharIndex;
        binNodes[offset++] = nodeToIndex[nodeRef] << refShift | charIndex;
      }
    }
    return new TrieBlob(binNodes, this._charIndex, this.info);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  toJSON() {
    return {
      info: this.info,
      nodes: nodesToJSON(this.nodes)
      // charIndex: this._charIndex,
    };
  }
  static create(data) {
    return new _FastTrieBlob(data.nodes, data.charIndex, extractInfo(data), data.info);
  }
  static toITrieNodeRoot(trie) {
    return new FastTrieBlobIRoot(new FastTrieBlobInternalsAndMethods(trie.nodes, trie._charIndex, trie.bitMasksInfo, trie.info, {
      nodeFindNode: (idx2, word) => {
        var _a3;
        return __privateMethod(_a3 = trie, _FastTrieBlob_instances, lookupNode_fn2).call(_a3, idx2, trie.wordToUtf8Seq(word));
      },
      nodeFindExact: (idx2, word) => {
        var _a3;
        return __privateMethod(_a3 = trie, _FastTrieBlob_instances, has_fn).call(_a3, idx2, word);
      },
      nodeGetChild: (idx2, letter) => {
        var _a3;
        return __privateMethod(_a3 = trie, _FastTrieBlob_instances, searchNodeForChar_fn).call(_a3, idx2, letter);
      },
      isForbidden: (word) => trie.isForbiddenWord(word),
      findExact: (word) => trie.has(word),
      hasForbiddenWords: trie.hasForbiddenWords,
      hasCompoundWords: trie.hasCompoundWords,
      hasNonStrictWords: trie.hasNonStrictWords
    }), 0);
  }
  get iTrieRoot() {
    return this._iTrieRoot ?? (this._iTrieRoot = _FastTrieBlob.toITrieNodeRoot(this));
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  isForbiddenWord(word) {
    return !!__privateGet(this, _forbidIdx2) && __privateMethod(this, _FastTrieBlob_instances, has_fn).call(this, __privateGet(this, _forbidIdx2), word);
  }
  nodeInfo(nodeIndex, accumulator) {
    const acc = accumulator ?? Utf8Accumulator.create();
    const n = this.nodes[nodeIndex];
    const eow = !!(n[0] & this.bitMasksInfo.NodeMaskEOW);
    const children = [];
    children.length = n.length - 1;
    for (let p = 1; p < n.length; ++p) {
      const v = n[p];
      const cIdx = v & this.bitMasksInfo.NodeMaskChildCharIndex;
      const a = acc.clone();
      const codePoint = a.decode(cIdx);
      const c = codePoint !== void 0 ? String.fromCodePoint(codePoint) : "\u220E";
      const i = v >>> this.bitMasksInfo.NodeChildRefShift;
      children[p] = { c, i, cIdx };
    }
    return { eow, children };
  }
  /** number of nodes */
  get size() {
    return this.nodes.length;
  }
  get charIndex() {
    return [...this._charIndex.charIndex];
  }
  static fromTrieBlob(trie) {
    const bitMasksInfo = {
      NodeMaskEOW: TrieBlob.NodeMaskEOW,
      NodeMaskChildCharIndex: TrieBlob.NodeMaskChildCharIndex,
      NodeChildRefShift: TrieBlob.NodeChildRefShift
    };
    const trieNodesBin = TrieBlob.nodesView(trie);
    const nodeOffsets = [];
    for (let offset = 0; offset < trieNodesBin.length; offset += (trieNodesBin[offset] & TrieBlob.NodeMaskNumChildren) + 1) {
      nodeOffsets.push(offset);
    }
    const offsetToNodeIndex = new Map(nodeOffsets.map((offset, i) => [offset, i]));
    const nodes = Array.from({ length: nodeOffsets.length });
    for (let i = 0; i < nodes.length; ++i) {
      const offset = nodeOffsets[i];
      const n = trieNodesBin[offset];
      const eow = n & TrieBlob.NodeMaskEOW;
      const count3 = n & TrieBlob.NodeMaskNumChildren;
      const node = new Uint32Array(count3 + 1);
      node[0] = eow;
      nodes[i] = node;
      for (let j = 1; j <= count3; ++j) {
        const n2 = trieNodesBin[offset + j];
        const charIndex = n2 & TrieBlob.NodeMaskChildCharIndex;
        const nodeIndex = n2 >>> TrieBlob.NodeChildRefShift;
        const idx2 = offsetToNodeIndex.get(nodeIndex);
        if (idx2 === void 0) {
          throw new Error(`Invalid node index ${nodeIndex}`);
        }
        node[j] = idx2 << TrieBlob.NodeChildRefShift | charIndex;
      }
    }
    return new _FastTrieBlob(sortNodes(nodes, TrieBlob.NodeMaskChildCharIndex), trie.charIndex, bitMasksInfo, trie.info);
  }
  static isFastTrieBlob(obj) {
    return obj instanceof _FastTrieBlob;
  }
};
_forbidIdx2 = new WeakMap();
_compoundIdx2 = new WeakMap();
_nonStrictIdx2 = new WeakMap();
_FastTrieBlob_instances = new WeakSet();
has_fn = function(nodeIdx, word) {
  return __privateMethod(this, _FastTrieBlob_instances, hasSorted_fn).call(this, nodeIdx, word);
};
hasSorted_fn = function(nodeIdx, word) {
  const charIndexes = this.wordToUtf8Seq(word);
  const found = __privateMethod(this, _FastTrieBlob_instances, lookupNode_fn2).call(this, nodeIdx, charIndexes);
  if (found === void 0)
    return false;
  const node = this.nodes[found];
  return !!(node[0] & this.bitMasksInfo.NodeMaskEOW);
};
/**
 * Find the node index for the given Utf8 character sequence.
 * @param nodeIdx - node index to start the search
 * @param seq - the byte sequence of the character to look for
 * @returns
 */
lookupNode_fn2 = function(nodeIdx, seq) {
  const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
  const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
  const nodes = this.nodes;
  const len = seq.length;
  let node = nodes[nodeIdx];
  for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
    const letterIdx = seq[p];
    const count3 = node.length;
    if (count3 < 2)
      return void 0;
    let i = 1;
    let j = count3 - 1;
    let c = -1;
    while (i < j) {
      const m = i + j >> 1;
      c = node[m] & NodeMaskChildCharIndex;
      if (c < letterIdx) {
        i = m + 1;
      } else {
        j = m;
      }
    }
    if (i >= count3 || (node[i] & NodeMaskChildCharIndex) !== letterIdx)
      return void 0;
    nodeIdx = node[i] >>> NodeChildRefShift;
    if (!nodeIdx)
      return void 0;
  }
  return nodeIdx;
};
/** Search from nodeIdx for the node index representing the character. */
searchNodeForChar_fn = function(nodeIdx, char) {
  const charIndexes = this.letterToUtf8Seq(char);
  return __privateMethod(this, _FastTrieBlob_instances, lookupNode_fn2).call(this, nodeIdx, charIndexes);
};
__publicField(_FastTrieBlob, "NodeMaskEOW", TrieBlob.NodeMaskEOW);
__publicField(_FastTrieBlob, "NodeChildRefShift", TrieBlob.NodeChildRefShift);
__publicField(_FastTrieBlob, "NodeMaskChildCharIndex", TrieBlob.NodeMaskChildCharIndex);
__publicField(_FastTrieBlob, "DefaultBitMaskInfo", {
  NodeMaskEOW: _FastTrieBlob.NodeMaskEOW,
  NodeMaskChildCharIndex: _FastTrieBlob.NodeMaskChildCharIndex,
  NodeChildRefShift: _FastTrieBlob.NodeChildRefShift
});
var FastTrieBlob = _FastTrieBlob;
function nodesToJSON(nodes) {
  const mapNodeToAcc = /* @__PURE__ */ new Map();
  function mapNode(node, i) {
    if (node.length === 1) {
      return {
        i,
        w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0
      };
    }
    const acc = mapNodeToAcc.get(node) || Utf8Accumulator.create();
    function mapChild(n) {
      const index = n >>> TrieBlob.NodeChildRefShift;
      const seq = n & TrieBlob.NodeMaskChildCharIndex;
      const cAcc = acc.clone();
      const codePoint = cAcc.decode(seq);
      if (codePoint === void 0) {
        mapNodeToAcc.set(nodes[index], cAcc);
      }
      return {
        i: index,
        c: codePoint && String.fromCodePoint(codePoint),
        s: seq.toString(16).padStart(2, "0")
      };
    }
    return {
      i,
      w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0,
      c: [...node.slice(1)].map(mapChild)
    };
  }
  return nodes.map((n, i) => mapNode(n, i));
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/resolveMap.js
function resolveMap(map3, key, resolve3) {
  const r = map3.get(key);
  if (r !== void 0)
    return r;
  const v = resolve3(key);
  map3.set(key, v);
  return v;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieBlob/FastTrieBlobBuilder.js
var _FastTrieBlobBuilder_instances, assertNotReadonly_fn;
var _FastTrieBlobBuilder = class _FastTrieBlobBuilder {
  constructor(options, bitMasksInfo = _FastTrieBlobBuilder.DefaultBitMaskInfo) {
    __privateAdd(this, _FastTrieBlobBuilder_instances);
    __publicField(this, "charIndex", new CharIndexBuilder());
    __publicField(this, "nodes");
    __publicField(this, "_readonly", false);
    __publicField(this, "IdxEOW");
    __publicField(this, "_cursor");
    __publicField(this, "_options");
    __publicField(this, "wordToCharacters", (word) => [...word]);
    __publicField(this, "bitMasksInfo");
    this._options = mergeOptionalWithDefaults(options);
    this.bitMasksInfo = bitMasksInfo;
    this.nodes = [[0], Object.freeze([_FastTrieBlobBuilder.NodeMaskEOW])];
    this.IdxEOW = 1;
  }
  setOptions(options) {
    this._options = mergeOptionalWithDefaults(this.options, options);
    return this.options;
  }
  get options() {
    return this._options;
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this.charIndex.charToUtf8Seq(letter);
  }
  insert(word) {
    __privateMethod(this, _FastTrieBlobBuilder_instances, assertNotReadonly_fn).call(this);
    if (typeof word === "string") {
      return this._insert(word);
    }
    const words = word;
    for (const w of words) {
      this._insert(w);
    }
    return this;
  }
  getCursor() {
    __privateMethod(this, _FastTrieBlobBuilder_instances, assertNotReadonly_fn).call(this);
    this._cursor ?? (this._cursor = this.createCursor());
    return this._cursor;
  }
  createCursor() {
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const LetterMask = this.bitMasksInfo.NodeMaskChildCharIndex;
    const refNodes = [0, 1];
    function childPos(node, letterIdx) {
      for (let i = 1; i < node.length; ++i) {
        if ((node[i] & LetterMask) === letterIdx) {
          return i;
        }
      }
      return 0;
    }
    (0, import_node_assert2.default)(this.nodes.length === 2);
    const eow = 1;
    const eowShifted = eow << NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{ nodeIdx: 0, pos: 0, pDepth: -1 }];
    let nodeIdx = 0;
    let depth = 0;
    const insertChar = (char) => {
      if (!nodes[nodeIdx]) {
        refNodes.push(nodeIdx);
      }
      const pDepth = depth;
      const utf8Seq = this.letterToUtf8Seq(char);
      for (let i = 0; i < utf8Seq.length; ++i) {
        insertCharIndexes(utf8Seq[i], pDepth);
      }
    };
    const insertCharIndexes = (seq, pDepth) => {
      if (nodes[nodeIdx] && Object.isFrozen(nodes[nodeIdx])) {
        nodeIdx = nodes.push([...nodes[nodeIdx]]) - 1;
        const { pos: pos2, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos2] = pNode[pos2] & LetterMask | nodeIdx << NodeChildRefShift;
      }
      const node = nodes[nodeIdx] || [0];
      nodes[nodeIdx] = node;
      const hasIdx = childPos(node, seq);
      const childIdx = hasIdx ? node[hasIdx] >>> NodeChildRefShift : nodes.length;
      const pos = hasIdx || node.push(childIdx << NodeChildRefShift | seq) - 1;
      ++depth;
      const s = stack[depth];
      if (s) {
        s.nodeIdx = nodeIdx;
        s.pos = pos;
        s.pDepth = pDepth;
      } else {
        stack[depth] = { nodeIdx, pos, pDepth };
      }
      nodeIdx = childIdx;
    };
    const markEOW = () => {
      if (nodeIdx === eow)
        return;
      const node = nodes[nodeIdx];
      if (!node) {
        const { pos, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos] = pNode[pos] & LetterMask | eowShifted;
      } else {
        nodes[nodeIdx] = node;
        node[0] |= NodeMaskEOW;
      }
      nodeIdx = eow;
    };
    const reference = (refId) => {
      const refNodeIdx = refNodes[refId];
      (0, import_node_assert2.default)(refNodeIdx !== void 0);
      (0, import_node_assert2.default)(nodes[nodeIdx] === void 0);
      (0, import_node_assert2.default)(nodes[refNodeIdx]);
      Object.freeze(nodes[refNodeIdx]);
      const s = stack[depth];
      nodeIdx = s.nodeIdx;
      const pos = s.pos;
      const node = nodes[nodeIdx];
      node[pos] = refNodeIdx << NodeChildRefShift | node[pos] & LetterMask;
    };
    const backStep = (num) => {
      if (!num)
        return;
      (0, import_node_assert2.default)(num <= depth && num > 0);
      for (let n = num; n > 0; --n) {
        depth = stack[depth].pDepth;
      }
      nodeIdx = stack[depth + 1].nodeIdx;
    };
    const c = {
      insertChar,
      markEOW,
      reference,
      backStep
    };
    return c;
  }
  _insert(word) {
    word = word.trim();
    if (!word)
      return this;
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const IdxEOW = this.IdxEOW;
    const nodes = this.nodes;
    const utf8Seq = this.wordToUtf8Seq(word);
    const len = utf8Seq.length;
    let nodeIdx = 0;
    for (let p = 0; p < len; ++p) {
      const seq = utf8Seq[p];
      const node = nodes[nodeIdx];
      const count3 = node.length;
      let i = count3 - 1;
      for (; i > 0; --i) {
        if ((node[i] & NodeMaskChildCharIndex) === seq) {
          break;
        }
      }
      if (i > 0) {
        nodeIdx = node[i] >>> NodeChildRefShift;
        if (nodeIdx === 1 && p < len - 1) {
          nodeIdx = this.nodes.push([NodeMaskEOW]) - 1;
          node[i] = nodeIdx << NodeChildRefShift | seq;
        }
        continue;
      }
      nodeIdx = p < len - 1 ? this.nodes.push([0]) - 1 : IdxEOW;
      node.push(nodeIdx << NodeChildRefShift | seq);
    }
    if (nodeIdx > 1) {
      const node = nodes[nodeIdx];
      node[0] |= NodeMaskEOW;
    }
    return this;
  }
  has(word) {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const charIndexes = this.wordToUtf8Seq(word);
    const len = charIndexes.length;
    let nodeIdx = 0;
    let node = nodes[nodeIdx];
    for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = charIndexes[p];
      const count3 = node.length;
      let i = count3 - 1;
      for (; i > 0; --i) {
        if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
          break;
        }
      }
      if (i < 1)
        return false;
      nodeIdx = node[i] >>> NodeChildRefShift;
    }
    return !!(node[0] & NodeMaskEOW);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  build() {
    this._cursor = void 0;
    this._readonly = true;
    this.freeze();
    return FastTrieBlob.create(new FastTrieBlobInternals(sortNodes(this.nodes.map((n) => Uint32Array.from(n)), this.bitMasksInfo.NodeMaskChildCharIndex), this.charIndex.build(), this.bitMasksInfo, this.options));
  }
  toJSON() {
    return {
      options: this.options,
      nodes: nodesToJSON(this.nodes.map((n) => Uint32Array.from(n)))
    };
  }
  static fromWordList(words, options) {
    const ft = new _FastTrieBlobBuilder(options);
    return ft.insert(words).build();
  }
  static fromTrieRoot(root) {
    const bitMasksInfo = _FastTrieBlobBuilder.DefaultBitMaskInfo;
    const NodeChildRefShift = bitMasksInfo.NodeChildRefShift;
    const NodeCharIndexMask = bitMasksInfo.NodeMaskChildCharIndex;
    const NodeMaskEOW = bitMasksInfo.NodeMaskEOW;
    const tf = new _FastTrieBlobBuilder(void 0, bitMasksInfo);
    const IdxEOW = tf.IdxEOW;
    const known = /* @__PURE__ */ new Map([[root, 0]]);
    function resolveNode(n) {
      if (n.f && !n.c)
        return IdxEOW;
      const node = [n.f ? NodeMaskEOW : 0];
      return tf.nodes.push(node) - 1;
    }
    function walk3(n) {
      const found = known.get(n);
      if (found)
        return found;
      const nodeIdx = resolveMap(known, n, resolveNode);
      const node = tf.nodes[nodeIdx];
      if (!n.c)
        return nodeIdx;
      const children = Object.entries(n.c);
      for (let p = 0; p < children.length; ++p) {
        const [char, childNode] = children[p];
        addCharToNode(node, char, childNode);
      }
      return nodeIdx;
    }
    function resolveChild(node, charIndex) {
      let i = 1;
      for (i = 1; i < node.length && (node[i] & NodeCharIndexMask) !== charIndex; ++i) {
      }
      return i;
    }
    function addCharToNode(node, char, n) {
      const indexSeq = tf.letterToUtf8Seq(char);
      assertValidUtf16Character(char);
      for (const idx2 of indexSeq.slice(0, -1)) {
        const pos = resolveChild(node, idx2);
        if (pos < node.length) {
          node = tf.nodes[node[pos] >>> NodeChildRefShift];
        } else {
          const next = [0];
          const nodeIdx = tf.nodes.push(next) - 1;
          node[pos] = nodeIdx << NodeChildRefShift | idx2;
          node = next;
        }
      }
      const letterIdx = indexSeq[indexSeq.length - 1];
      const i = node.push(letterIdx) - 1;
      node[i] = walk3(n) << NodeChildRefShift | letterIdx;
    }
    walk3(root);
    return tf.build();
  }
};
_FastTrieBlobBuilder_instances = new WeakSet();
assertNotReadonly_fn = function() {
  (0, import_node_assert2.default)(!this.isReadonly(), "FastTrieBlobBuilder is readonly");
};
__publicField(_FastTrieBlobBuilder, "NodeMaskEOW", TrieBlob.NodeMaskEOW);
__publicField(_FastTrieBlobBuilder, "NodeChildRefShift", TrieBlob.NodeChildRefShift);
__publicField(_FastTrieBlobBuilder, "NodeMaskChildCharIndex", TrieBlob.NodeMaskChildCharIndex);
__publicField(_FastTrieBlobBuilder, "DefaultBitMaskInfo", {
  NodeMaskEOW: _FastTrieBlobBuilder.NodeMaskEOW,
  NodeMaskChildCharIndex: _FastTrieBlobBuilder.NodeMaskChildCharIndex,
  NodeChildRefShift: _FastTrieBlobBuilder.NodeChildRefShift
});
var FastTrieBlobBuilder = _FastTrieBlobBuilder;

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/clean.js
function clean2(t) {
  const copy = { ...t };
  for (const key of Object.keys(copy)) {
    if (copy[key] === void 0) {
      delete copy[key];
    }
  }
  return copy;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/ITrie.js
var defaultLegacyMinCompoundLength2 = 3;
var _optionsCompound;
var _ITrieImpl = class _ITrieImpl {
  constructor(data, numNodes) {
    __publicField(this, "data");
    __publicField(this, "numNodes");
    __publicField(this, "_info");
    __publicField(this, "root");
    __publicField(this, "count");
    __publicField(this, "weightMap");
    __privateAdd(this, _optionsCompound, this.createFindOptions({ compoundMode: "compound" }));
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    this.data = data;
    this.numNodes = numNodes;
    this.root = data.getRoot();
    this._info = mergeOptionalWithDefaults(data.info);
    this.hasForbiddenWords = data.hasForbiddenWords;
    this.hasCompoundWords = data.hasCompoundWords;
    this.hasNonStrictWords = data.hasNonStrictWords;
  }
  /**
   * Number of words in the Trie, the first call to this method might be expensive.
   * Use `size` to get the number of nodes.
   */
  numWords() {
    this.count ?? (this.count = countWords(this.root));
    return this.count;
  }
  isNumWordsKnown() {
    return this.count !== void 0;
  }
  get size() {
    return this.data.size;
  }
  get info() {
    return this._info;
  }
  get isCaseAware() {
    return this.info.isCaseAware ?? true;
  }
  /**
   * @param text - text to find in the Trie
   */
  find(text) {
    return findWordNode(this.data.getRoot(), text, __privateGet(this, _optionsCompound)).node;
  }
  has(word, minLegacyCompoundLength) {
    if (this.hasWord(word, false))
      return true;
    if (minLegacyCompoundLength) {
      const f = this.findWord(word, { useLegacyWordCompounds: minLegacyCompoundLength });
      return !!f.found;
    }
    return false;
  }
  /**
   * Determine if a word is in the dictionary.
   * @param word - the exact word to search for - must be normalized.
   * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
   * @returns true if the word was found and is not forbidden.
   */
  hasWord(word, caseSensitive) {
    const f = this.findWord(word, { caseSensitive, checkForbidden: false });
    return !!f.found;
  }
  findWord(word, options) {
    if (options == null ? void 0 : options.useLegacyWordCompounds) {
      const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength2;
      const findOptions = this.createFindOptions({
        legacyMinCompoundLength: len,
        matchCase: options.caseSensitive || false
      });
      return findLegacyCompound(this.root, word, findOptions);
    }
    return findWord(this.root, word, {
      matchCase: options == null ? void 0 : options.caseSensitive,
      checkForbidden: options == null ? void 0 : options.checkForbidden
    });
  }
  /**
   * Determine if a word is in the forbidden word list.
   * @param word the word to lookup.
   */
  isForbiddenWord(word) {
    return this.hasForbiddenWords && isForbiddenWord(this.root, word, this.info.forbiddenWordPrefix);
  }
  /**
   * Provides an ordered sequence of words with the prefix of text.
   */
  completeWord(text) {
    const n = this.find(text);
    const compoundChar = this.info.compoundCharacter;
    const subNodes = pipeSync(n ? iteratorTrieWords(n) : [], opFilterSync((w) => w[w.length - 1] !== compoundChar), opMapSync((suffix) => text + suffix));
    return pipeSync(n && n.eow ? [text] : [], opAppendSync(subNodes));
  }
  /**
   * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
   * @param text - the text to search for
   * @param maxNumSuggestions - the maximum number of suggestions to return.
   * @param compoundMethod - Use to control splitting words.
   * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
   *                      the lower the value, the faster results are returned. Values less than 4 are best.
   */
  suggest(text, options) {
    return this.suggestWithCost(text, options).map((a) => a.word);
  }
  /**
   * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
   * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
   */
  suggestWithCost(text, options) {
    const sep3 = options.compoundSeparator;
    const weightMap = options.weightMap || this.weightMap;
    const adjWord = sep3 ? replaceAllFactory(sep3, "") : (a) => a;
    const optFilter = options.filter;
    const filter3 = optFilter ? (word, cost) => {
      const w = adjWord(word);
      return !this.isForbiddenWord(w) && optFilter(w, cost);
    } : (word) => !this.isForbiddenWord(adjWord(word));
    const opts = { ...options, filter: filter3, weightMap };
    return suggestAStar(this.data, text, opts);
  }
  /**
   * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
   * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
   * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
   */
  genSuggestions(collector, compoundMethod) {
    const filter3 = (word) => !this.isForbiddenWord(word);
    const options = createSuggestionOptions(clean2({ compoundMethod, ...collector.genSuggestionOptions }));
    const suggestions = getSuggestionsAStar(this.data, collector.word, options);
    collector.collect(suggestions, void 0, filter3);
  }
  /**
   * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
   */
  words() {
    return iteratorTrieWords(this.root);
  }
  /**
   * Allows iteration over the entire tree.
   * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
   */
  iterate() {
    return walker(this.root);
  }
  static create(words, info) {
    const builder = new FastTrieBlobBuilder(info);
    builder.insert(words);
    const root = builder.build();
    return new _ITrieImpl(root, void 0);
  }
  createFindOptions(options) {
    const findOptions = createFindOptions(options);
    return findOptions;
  }
};
_optionsCompound = new WeakMap();
var ITrieImpl = _ITrieImpl;

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/buildITrie.js
function buildITrieFromWords(words, info = {}) {
  const builder = new FastTrieBlobBuilder(info);
  builder.insert(words);
  const ft = builder.build();
  return new ITrieImpl(ft.size > 1e3 ? ft.toTrieBlob() : ft);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieNode/TrieNode.js
var FLAG_WORD = 1;

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieNode/trie-util.js
function insert2(word, root = {}) {
  const text = [...word];
  let node = root;
  for (let i = 0; i < text.length; ++i) {
    const head = text[i];
    const c = node.c || /* @__PURE__ */ Object.create(null);
    node.c = c;
    node = c[head] || {};
    c[head] = node;
  }
  node.f = (node.f || 0) | FLAG_WORD;
  return root;
}
function iteratorTrieWords2(node) {
  return walkerWords2(node);
}
function createTrieRoot(options) {
  const fullOptions = mergeOptionalWithDefaults(options);
  return {
    ...fullOptions,
    c: /* @__PURE__ */ Object.create(null)
  };
}
function createTrieRootFromList(words, options) {
  const root = createTrieRoot(options);
  for (const word of words) {
    if (word.length) {
      insert2(word, root);
    }
  }
  return root;
}
function countNodes(root) {
  const seen = /* @__PURE__ */ new Set();
  function walk3(n) {
    if (seen.has(n))
      return;
    seen.add(n);
    if (n.c) {
      Object.values(n.c).forEach((n2) => walk3(n2));
    }
  }
  walk3(root);
  return seen.size;
}
function checkCircular(root) {
  const seen = /* @__PURE__ */ new Set();
  const inStack = /* @__PURE__ */ new Set();
  function walk3(n) {
    if (seen.has(n))
      return { isCircular: false, allSeen: true };
    if (inStack.has(n)) {
      const stack = [...inStack, n];
      const word = trieStackToWord(stack);
      const pos = stack.indexOf(n);
      return { isCircular: true, allSeen: false, ref: { stack, word, pos } };
    }
    inStack.add(n);
    let r = { isCircular: false, allSeen: true };
    if (n.c) {
      r = Object.values(n.c).reduce((acc, n2) => {
        if (acc.isCircular)
          return acc;
        const r2 = walk3(n2);
        r2.allSeen = r2.allSeen && acc.allSeen;
        return r2;
      }, r);
    }
    if (r.allSeen) {
      seen.add(n);
    }
    inStack.delete(n);
    return r;
  }
  return walk3(root);
}
function reverseMapTrieNode(node) {
  return node.c && new Map(Object.entries(node.c).map(([c, n]) => [n, c]));
}
function trieStackToWord(stack) {
  let word = "";
  let lastMap = reverseMapTrieNode(stack[0]);
  for (let i = 1; i < stack.length; ++i) {
    const n = stack[i];
    const char = lastMap == null ? void 0 : lastMap.get(n);
    if (char) {
      word += char;
    }
    lastMap = reverseMapTrieNode(n);
  }
  return word;
}
function isCircular(root) {
  return checkCircular(root).isCircular;
}
function trieNodeToRoot(node, options) {
  const newOptions = mergeOptionalWithDefaults(options);
  return {
    ...newOptions,
    c: node.c || /* @__PURE__ */ Object.create(null)
  };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/consolidate.js
function consolidate(root) {
  let count3 = 0;
  const signatures = /* @__PURE__ */ new Map();
  const cached = /* @__PURE__ */ new Map();
  const knownMap = /* @__PURE__ */ new Map();
  if (isCircular(root)) {
    throw new Error("Trie is circular.");
  }
  function signature(n) {
    const isWord = n.f ? "*" : "";
    const ref = n.c ? JSON.stringify(Object.entries(n.c).map(([k, n2]) => [k, cached.get(n2)])) : "";
    return isWord + ref;
  }
  function findEow(n) {
    if (n.f && !n.c)
      return n;
    let r;
    if (n.c) {
      for (const c of Object.values(n.c)) {
        r = findEow(c);
        if (r)
          break;
      }
    }
    return r;
  }
  function compareMaps(a, b) {
    for (const e of a) {
      if (b[e[0]] !== e[1])
        return false;
    }
    return a.length === b.size;
  }
  function deepCopy(n) {
    const k = knownMap.get(n);
    if (k) {
      return k;
    }
    const orig = n;
    if (n.c) {
      const children = Object.entries(n.c).map((c) => [c[0], deepCopy(c[1])]);
      if (!compareMaps(children, n.c)) {
        n = { f: n.f, c: Object.fromEntries(children) };
      }
    }
    const sig = signature(n);
    const ref = signatures.get(sig);
    if (ref) {
      knownMap.set(orig, ref);
      return ref;
    }
    Object.freeze(n);
    signatures.set(sig, n);
    cached.set(n, count3++);
    knownMap.set(orig, n);
    return n;
  }
  function process5(n) {
    if (cached.has(n)) {
      return n;
    }
    if (Object.isFrozen(n)) {
      return knownMap.get(n) || deepCopy(n);
    }
    if (n.c) {
      const children = Object.entries(n.c).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n2]) => [k, process5(n2)]);
      n.c = Object.fromEntries(children);
    }
    const sig = signature(n);
    const ref = signatures.get(sig);
    if (ref) {
      return ref;
    }
    signatures.set(sig, n);
    cached.set(n, count3++);
    return n;
  }
  const eow = findEow(root) || { f: FLAG_WORD, c: void 0 };
  signatures.set(signature(eow), eow);
  cached.set(eow, count3++);
  return trieNodeToRoot(process5(root), root);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieNode/find.js
var defaultLegacyMinCompoundLength3 = 3;
var _defaultFindOptions2 = {
  matchCase: false,
  compoundMode: "compound",
  forbidPrefix: FORBID_PREFIX,
  compoundFix: COMPOUND_FIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  legacyMinCompoundLength: defaultLegacyMinCompoundLength3
};
var arrayCompoundModes2 = ["none", "compound", "legacy"];
var knownCompoundModes2 = new Map(arrayCompoundModes2.map((a) => [a, a]));
function findWordExact2(root, word) {
  return isEndOfWordNode2(walk2(root, word));
}
function isEndOfWordNode2(n) {
  return (n == null ? void 0 : n.f) === FLAG_WORD;
}
function walk2(root, word) {
  var _a3;
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = (_a3 = n.c) == null ? void 0 : _a3[h];
  }
  return n;
}
var createFindOptions2 = memorizeLastCall(_createFindOptions2);
function _createFindOptions2(options) {
  return mergeDefaults(options, _defaultFindOptions2);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/TrieNode/TrieNodeTrie.js
var TrieNodeTrie = class _TrieNodeTrie {
  root;
  _iTrieRoot;
  info;
  _size;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(root) {
    this.root = root;
    this.info = mergeOptionalWithDefaults(root);
    this.hasForbiddenWords = !!root.c[root.forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[root.compoundCharacter];
    this.hasNonStrictWords = !!root.c[root.stripCaseAndAccentsPrefix];
  }
  wordToCharacters = (word) => [...word];
  get iTrieRoot() {
    return this._iTrieRoot || (this._iTrieRoot = trieRootToITrieRoot(this.root));
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  words() {
    return iteratorTrieWords2(this.root);
  }
  has(word) {
    return findWordExact2(this.root, word);
  }
  isForbiddenWord(word) {
    return findWordExact2(this.root.c[this.root.forbiddenWordPrefix], word);
  }
  get size() {
    return this._size ?? (this._size = countNodes(this.root));
  }
  static createFromWords(words, options) {
    const root = createTrieRootFromList(words, options);
    return new _TrieNodeTrie(root);
  }
  static createFromWordsAndConsolidate(words, options) {
    const root = createTrieRootFromList(words, options);
    return new _TrieNodeTrie(consolidate(root));
  }
};

// node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/util/util.js
function* toIterableIterator(i) {
  yield* i;
}

// node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/operators/operatorsBase.js
function* filter(i, fnFilter) {
  for (const v of i) {
    if (fnFilter(v)) {
      yield v;
    }
  }
}
function* skip(i, n) {
  let a = 0;
  for (const t of i) {
    if (a >= n) {
      yield t;
    }
    a += 1;
  }
}
function* take(i, n) {
  let a = 0;
  if (n) {
    for (const t of i) {
      if (a >= n) {
        break;
      }
      yield t;
      a += 1;
    }
  }
}
function* concat(i, j) {
  yield* i;
  yield* j;
}
function* concatMap(i, fn) {
  for (const t of i) {
    yield* fn(t);
  }
}
function* combine(i, j, fnMap) {
  const jit = j[Symbol.iterator]();
  for (const r of i) {
    const s = jit.next().value;
    yield fnMap(r, s);
  }
}
function map(i, fnMap) {
  function* fn(i2, fnMap2) {
    for (const v of i2) {
      yield fnMap2(v);
    }
  }
  return fn(i, fnMap);
}
function* scan(i, fnReduce, initValue) {
  let index = 0;
  if (initValue === void 0) {
    index = 1;
    const iter = i[Symbol.iterator]();
    let r = iter.next();
    if (!r.done)
      yield r.value;
    initValue = r.value;
    i = makeIterable(iter);
  }
  let prevValue = initValue;
  for (const t of i) {
    const nextValue = fnReduce(prevValue, t, index);
    yield nextValue;
    prevValue = nextValue;
    index += 1;
  }
}
function all(i, fn) {
  for (const t of i) {
    if (!fn(t)) {
      return false;
    }
  }
  return true;
}
function any(i, fn) {
  for (const t of i) {
    if (fn(t)) {
      return true;
    }
  }
  return false;
}
function count(i) {
  return reduce(i, (p) => p + 1, 0);
}
function first(i, fn, defaultValue) {
  fn = fn || (() => true);
  for (const t of i) {
    if (fn(t)) {
      return t;
    }
  }
  return defaultValue;
}
function forEach(i, fn) {
  let index = 0;
  for (const t of i) {
    fn(t, index);
    index += 1;
  }
}
function max(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) > selector(p) ? c : p, void 0);
}
function min(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) < selector(p) ? c : p, void 0);
}
function reduce(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let prevValue = initialValue;
  for (const t of iter) {
    const nextValue = fnReduce(prevValue, t, index);
    prevValue = nextValue;
    index += 1;
  }
  return prevValue;
}
async function reduceAsync(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let previousValue = await initialValue;
  for (const p of iter) {
    const t = await p;
    const nextValue = await fnReduce(previousValue, t, index);
    previousValue = nextValue;
    index += 1;
  }
  return previousValue;
}
function makeIterable(i) {
  function* fromIterator(i2) {
    for (let r = i2.next(); !r.done; r = i2.next()) {
      yield r.value;
    }
  }
  function* fromIterable(i2) {
    yield* i2;
  }
  return isIterable(i) ? isIterableIterator(i) ? i : fromIterable(i) : fromIterator(i);
}
function isIterable(i) {
  return !!i[Symbol.iterator];
}
function isIterableIterator(i) {
  return typeof i.next == "function";
}

// node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/operators/operators.js
function filter2(fnFilter) {
  return (i) => filter(i, fnFilter);
}
function skip2(n) {
  return (i) => skip(i, n);
}
function take2(n) {
  return (i) => take(i, n);
}
function concat2(j) {
  return (i) => concat(i, j);
}
function concatMap2(fn) {
  return (i) => concatMap(i, fn);
}
function combine2(fnMap, j) {
  return (i) => combine(i, j, fnMap);
}
function map2(fnMap) {
  return (i) => map(i, fnMap);
}
function scan2(fnReduce, initValue) {
  return (i) => scan(i, fnReduce, initValue);
}
function all2(fn) {
  return (i) => all(i, fn);
}
function any2(fn) {
  return (i) => any(i, fn);
}
function count2() {
  return (i) => count(i);
}
function first2(fn, defaultValue) {
  return (i) => first(i, fn, defaultValue);
}
function forEach2(fn) {
  return (i) => forEach(i, fn);
}
function max2(selector) {
  return (i) => max(i, selector);
}
function min2(selector) {
  return (i) => min(i, selector);
}
function reduce2(fnReduce, initialValue) {
  return (i) => reduce(i, fnReduce, initialValue);
}
function reduceAsync2(fnReduceAsync, initialValue) {
  return (i) => reduceAsync(i, fnReduceAsync, initialValue);
}
function pipe(...fns) {
  return (i) => {
    for (const fn of fns) {
      i = fn ? fn(i) : i;
    }
    return i;
  };
}

// node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/ImplSequence.js
var ImplSequence = class _ImplSequence {
  i;
  _iterator;
  constructor(i) {
    this.i = i;
  }
  get iter() {
    return typeof this.i === "function" ? this.i() : this.i;
  }
  get iterator() {
    if (!this._iterator) {
      this._iterator = this.iter[Symbol.iterator]();
    }
    return this._iterator;
  }
  inject(fn) {
    const iter = this.i;
    return () => fn(typeof iter === "function" ? iter() : iter);
  }
  chain(fn) {
    return new _ImplSequence(this.inject(fn));
  }
  [Symbol.iterator]() {
    return this.iter[Symbol.iterator]();
  }
  next() {
    return this.iterator.next();
  }
  //// Filters
  filter(fnFilter) {
    return this.chain(filter2(fnFilter));
  }
  skip(n) {
    return this.chain(skip2(n));
  }
  take(n) {
    return this.chain(take2(n));
  }
  //// Extenders
  concat(j) {
    return this.chain(concat2(j));
  }
  concatMap(fn) {
    return this.chain(concatMap2(fn));
  }
  //// Mappers
  combine(fn, j) {
    return this.chain(combine2(fn, j));
  }
  map(fn) {
    return this.chain(map2(fn));
  }
  scan(fnReduce, initValue) {
    return this.chain(scan2(fnReduce, initValue));
  }
  pipe(...fns) {
    if (!fns.length)
      return this;
    return this.chain(pipe.apply(null, fns));
  }
  // Reducers
  all(fnFilter) {
    return all2(fnFilter)(this.iter);
  }
  any(fnFilter) {
    return any2(fnFilter)(this.iter);
  }
  count() {
    return count2()(this.iter);
  }
  first(fnFilter, defaultValue) {
    return first2(fnFilter, defaultValue)(this.iter);
  }
  forEach(fn) {
    return forEach2(fn)(this.iter);
  }
  max(fnSelector) {
    return max2(fnSelector)(this.iter);
  }
  min(fnSelector) {
    return min2(fnSelector)(this.iter);
  }
  reduce(fnReduce, initValue) {
    return reduce2(fnReduce, initValue)(this.iter);
  }
  reduceAsync(fnReduceAsync, initialValue) {
    return reduceAsync2(fnReduceAsync, initialValue)(this.iter);
  }
  reduceToSequence(fnReduce, initialValue) {
    return this.chain(reduce2(fnReduce, initialValue));
  }
  //// Cast
  toArray() {
    return [...this.iter];
  }
  toIterable() {
    return toIterableIterator(this.iter);
  }
};

// node_modules/.pnpm/gensequence@7.0.0/node_modules/gensequence/dist/GenSequence.js
function genSequence(i) {
  return new ImplSequence(i);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/importExportV1.js
var EOW = "*";
var DATA = EOW;
function* toIterableIterator2(iter) {
  yield* iter;
}
function importTrie(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator2(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg2 = /^TrieXv1\nbase=(\d+)$/;
    if (!headerReg2.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg2, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) {
        break;
      }
      const line = next.value.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const regNotEscapedCommas = /(^|[^\\]),/g;
  const regUnescapeCommas = /__COMMA__/g;
  const regUnescape = /[\\](.)/g;
  const flagsWord = { f: FLAG_WORD };
  function splitLine2(line) {
    const pattern = "$1__COMMA__";
    return line.replaceAll(regNotEscapedCommas, pattern).split(regUnescapeCommas).map((a) => a.replaceAll(regUnescape, "$1"));
  }
  function decodeLine2(line, nodes) {
    const isWord = line[0] === EOW;
    line = isWord ? line.slice(1) : line;
    const flags = isWord ? flagsWord : {};
    const children = splitLine2(line).filter((a) => !!a).map((a) => [a[0], Number.parseInt(a.slice(1) || "0", radix)]).map(([k, i]) => [k, nodes[i]]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return { ...cNode, ...flags };
  }
  readHeader(iter);
  const n = genSequence([DATA]).concat(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { lines, nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes[lines] = root;
    return { lines: lines + 1, root, nodes };
  }, { lines: 0, nodes: [], root: {} });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/importExportV2.js
var EOW2 = "*";
var DATA2 = "__DATA__";
function* toIterableIterator3(iter) {
  yield* iter;
}
function importTrie2(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator3(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg2 = /^TrieXv2\nbase=(\d+)$/;
    if (!headerReg2.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg2, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) {
        break;
      }
      const line = next.value.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA2) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  function parseLine(line, base) {
    const isWord = line[1] === EOW2;
    const refOffset = isWord ? 2 : 1;
    const refs = line.slice(refOffset).split(",").filter((a) => !!a).map((r) => Number.parseInt(r, base));
    return {
      letter: line[0],
      isWord,
      refs
    };
  }
  const flagsWord = { f: FLAG_WORD };
  function decodeLine2(line, nodes) {
    const { letter, isWord, refs } = parseLine(line, radix);
    const flags = isWord ? flagsWord : {};
    const children = refs.map((r) => nodes[r]).sort((a, b) => a.s < b.s ? -1 : 1).map((n2) => [n2.s, n2]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return { s: letter, ...cNode, ...flags };
  }
  readHeader(iter);
  const n = genSequence(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes.push(root);
    return { root, nodes };
  }, { nodes: [], root: { s: "", c: /* @__PURE__ */ Object.create(null) } });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/constants.js
var EOW3 = "$";
var BACK = "<";
var EOL = "\n";
var LF = "\r";
var REF = "#";
var REF_REL = "@";
var EOR = ";";
var ESCAPE = "\\";

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/importExportV4.js
var REF_INDEX_BEGIN = "[";
var REF_INDEX_END = "]";
var INLINE_DATA_COMMENT_LINE = "/";
var specialCharacters = stringToCharSet([
  EOW3,
  BACK,
  EOL,
  REF,
  REF_REL,
  EOR,
  ESCAPE,
  LF,
  REF_INDEX_BEGIN,
  REF_INDEX_END,
  INLINE_DATA_COMMENT_LINE,
  ..."0123456789",
  ..."`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var SPECIAL_CHARACTERS_MAP = [
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
];
var specialCharacterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP);
var characterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP.map((a) => [a[1], a[0]]));
var specialPrefix = stringToCharSet("~!");
var DATA3 = "__DATA__";
function importTrie3(linesX) {
  linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
  let radix = 10;
  const comment = /^\s*#/;
  const iter = tapIterable(pipeSync(linesX, opConcatMapSync((a) => a.split(/^/m))));
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg2 = /^TrieXv[34]\nbase=(\d+)$/;
    if (!headerReg2.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg2, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    for (const value of iter2) {
      const line = value.trim();
      if (!line || comment.test(line))
        continue;
      if (line === DATA3)
        break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  readHeader(iter);
  const root = parseStream(radix, iter);
  return root;
}
var numbersSet = stringToCharSet("0123456789");
function parseStream(radix, iter) {
  const eow = Object.freeze({ f: 1 });
  let refIndex = [];
  const root = trieNodeToRoot({}, {});
  function parseReference(acc, s) {
    const isIndexRef = s === REF_REL;
    let ref = "";
    function parser2(acc2, s2) {
      if (s2 === EOR || radix === 10 && !(s2 in numbersSet)) {
        const { root: root2, nodes: nodes2, stack } = acc2;
        const r = Number.parseInt(ref, radix);
        const top = stack[stack.length - 1];
        const p = stack[stack.length - 2].node;
        const n = isIndexRef ? refIndex[r] : r;
        p.c && (p.c[top.s] = nodes2[n]);
        const rr = { root: root2, nodes: nodes2, stack, parser: void 0 };
        return s2 === EOR ? rr : parserMain(rr, s2);
      }
      ref = ref + s2;
      return acc2;
    }
    const { nodes } = acc;
    nodes.pop();
    return { ...acc, nodes, parser: parser2 };
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser2 = function(acc2, s) {
      if (prev) {
        s = characterMap[prev + s] || s;
        return parseCharacter({ ...acc2, parser: void 0 }, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      return parseCharacter({ ...acc2, parser: void 0 }, s);
    };
    return { ...acc, parser: parser2 };
  }
  function parseComment(acc, s) {
    const endOfComment = s;
    let isEscaped = false;
    function parser2(acc2, s2) {
      if (isEscaped) {
        isEscaped = false;
        return acc2;
      }
      if (s2 === ESCAPE) {
        isEscaped = true;
        return acc2;
      }
      if (s2 === endOfComment) {
        return { ...acc2, parser: void 0 };
      }
      return acc2;
    }
    return { ...acc, parser: parser2 };
  }
  function parseCharacter(acc, s) {
    const parser2 = void 0;
    const { root: root2, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    const c = node.c ?? /* @__PURE__ */ Object.create(null);
    const n = { f: void 0, c: void 0, n: nodes.length };
    c[s] = n;
    node.c = c;
    stack.push({ node: n, s });
    nodes.push(n);
    return { root: root2, nodes, stack, parser: parser2 };
  }
  function parseEOW(acc, _) {
    const parser2 = parseBack;
    const { root: root2, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    node.f = FLAG_WORD;
    if (!node.c) {
      top.node = eow;
      const p = stack[stack.length - 2].node;
      p.c && (p.c[top.s] = eow);
      nodes.pop();
    }
    stack.pop();
    return { root: root2, nodes, stack, parser: parser2 };
  }
  const charactersBack = stringToCharSet(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      return parserMain({ ...acc, parser: void 0 }, s);
    }
    let n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    const { stack } = acc;
    while (n-- > 0) {
      stack.pop();
    }
    return { ...acc, parser: parseBack };
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers3 = createStringLookupMap([
    [EOW3, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [REF_REL, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore],
    [INLINE_DATA_COMMENT_LINE, parseComment]
  ]);
  function parserMain(acc, s) {
    const parser2 = acc.parser ?? parsers3[s] ?? parseCharacter;
    return parser2(acc, s);
  }
  const charsetSpaces = stringToCharSet(" \r\n	");
  function parseReferenceIndex(acc, s) {
    let json = "";
    function parserStart(acc2, s2) {
      if (s2 === REF_INDEX_BEGIN) {
        json = json + s2;
        return { ...acc2, parser: parser2 };
      }
      if (s2 in charsetSpaces) {
        return acc2;
      }
      return parserMain({ ...acc2, parser: void 0 }, s2);
    }
    function parser2(acc2, s2) {
      json = json + s2;
      if (s2 === REF_INDEX_END) {
        refIndex = json.replaceAll(/[\s[\]]/g, "").split(",").map((n) => Number.parseInt(n, radix));
        return { ...acc2, parser: void 0 };
      }
      return acc2;
    }
    return parserStart({ ...acc, parser: parserStart }, s);
  }
  reduceSync(pipeSync(iter, opConcatMapSync((a) => [...a])), parserMain, {
    nodes: [root],
    root,
    stack: [{ node: root, s: "" }],
    parser: parseReferenceIndex
  });
  return root;
}
function stringToCharSet(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) {
    set[values[i]] = true;
  }
  return set;
}
function stringToCharMap(values) {
  return createStringLookupMap(values);
}
function createStringLookupMap(values) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) {
    map3[values[i][0]] = values[i][1];
  }
  return map3;
}
function tapIterable(iterable) {
  let lastValue;
  let iter;
  function getNext() {
    if (lastValue && lastValue.done) {
      return { ...lastValue };
    }
    iter = iter || iterable[Symbol.iterator]();
    lastValue = iter.next();
    return lastValue;
  }
  function* iterableFn() {
    let next;
    while (!(next = getNext()).done) {
      yield next.value;
    }
  }
  return {
    [Symbol.iterator]: iterableFn
  };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/importV3.js
var specialCharacterMap2 = /* @__PURE__ */ new Map([
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
]);
var characterMap2 = new Map([...specialCharacterMap2].map((a) => [a[1], a[0]]));
var DATA4 = "__DATA__";
function importTrieV3WithBuilder(builder, srcLines) {
  const timer = getGlobalPerfTimer();
  const timerStart = timer.start("importTrieV3");
  const dataLines = typeof srcLines === "string" ? srcLines.split("\n") : Array.isArray(srcLines) ? srcLines : [...srcLines];
  let radix = 16;
  const comment = /^\s*#/;
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg2 = /^TrieXv3\nbase=(\d+)$/;
    if (!headerReg2.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg2, "$1"), 10);
  }
  function findStartOfData(data) {
    for (let i = 0; i < data.length; ++i) {
      const line = data[i];
      if (line.includes(DATA4)) {
        return i;
      }
    }
    return -1;
  }
  function readHeader(data) {
    const headerRows = [];
    for (const hLine of data) {
      const line = hLine.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA4) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const startOfData = findStartOfData(dataLines);
  if (startOfData < 0) {
    throw new Error("Unknown file format");
  }
  readHeader(dataLines.slice(0, startOfData));
  const cursor = builder.getCursor();
  let node = {
    cursor,
    parser: void 0
  };
  const parser2 = parseStream2(radix);
  const timerParse = timer.start("importTrieV3.parse");
  for (let i = startOfData + 1; i < dataLines.length; ++i) {
    const line = dataLines[i];
    for (const c of line) {
      node = parser2(node, c);
    }
  }
  timerParse();
  timerStart();
  return builder.build();
}
function parseStream2(radix) {
  function parseReference(acc, _) {
    let ref = "";
    function parser2(acc2, s) {
      if (s === EOR) {
        const { cursor } = acc2;
        const r = Number.parseInt(ref, radix);
        cursor.reference(r + 1);
        acc2.parser = void 0;
        return acc2;
      }
      ref = ref + s;
      return acc2;
    }
    acc.parser = parser2;
    return acc;
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser2 = function(acc2, s) {
      if (prev) {
        s = characterMap2.get(prev + s) || s;
        acc2.parser = void 0;
        return parseCharacter(acc2, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      acc2.parser = void 0;
      return parseCharacter(acc2, s);
    };
    acc.parser = parser2;
    return acc;
  }
  function parseCharacter(acc, s) {
    acc.cursor.insertChar(s);
    acc.parser = void 0;
    return acc;
  }
  function parseEOW(acc, _) {
    acc.parser = parseBack;
    acc.cursor.markEOW();
    acc.cursor.backStep(1);
    return acc;
  }
  const charactersBack = stringToCharSet2(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      acc.parser = void 0;
      return parserMain(acc, s);
    }
    const n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    acc.cursor.backStep(n);
    acc.parser = parseBack;
    return acc;
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers3 = /* @__PURE__ */ new Map([
    [EOW3, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore]
  ]);
  function parserMain(acc, s) {
    const parser2 = acc.parser ?? parsers3.get(s) ?? parseCharacter;
    return parser2(acc, s);
  }
  return parserMain;
}
function stringToCharSet2(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) {
    set[values[i]] = true;
  }
  return set;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/importV3FastBlob.js
function importTrieV3AsFastTrieBlob(srcLines) {
  return importTrieV3WithBuilder(new FastTrieBlobBuilder(), srcLines);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/io/decode.js
function decodeTrieData(raw) {
  return decodeStringFormat(typeof raw === "string" ? raw : raw.toString("utf8"));
}
function decodeStringFormat(data) {
  return importTrie4(data);
}
var deserializers = [
  (data) => new TrieNodeTrie(importTrie(data)),
  (data) => new TrieNodeTrie(importTrie(data)),
  (data) => new TrieNodeTrie(importTrie2(data)),
  (data) => importTrieV3AsFastTrieBlob(data),
  (data) => new TrieNodeTrie(importTrie3(data))
];
var headerReg = /^\s*TrieXv(\d+)/m;
function importTrie4(input) {
  const lines = Array.isArray(input) ? input : typeof input === "string" ? input.split("\n") : [...input];
  function parseHeaderRows(headerRows) {
    for (let i = 0; i < headerRows.length; ++i) {
      const match2 = headerRows[i].match(headerReg);
      if (match2) {
        return Number.parseInt(match2[1], 10);
      }
    }
    throw new Error("Unknown file format");
  }
  function readHeader(iter) {
    const headerRows = [];
    for (const entry of iter) {
      const line = entry.trim();
      headerRows.push(line);
      if (line === DATA || line === DATA2) {
        break;
      }
    }
    return headerRows;
  }
  const headerLines = readHeader(lines);
  const version2 = parseHeaderRows(headerLines);
  const method = deserializers[version2];
  if (!method) {
    throw new Error(`Unsupported version: ${version2}`);
  }
  return method(lines);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/decodeTrie.js
function decodeTrie(raw) {
  const data = decodeTrieData(raw);
  return new ITrieImpl(data);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/models/locale/knownLocales.js
var codes = [
  // ['code', 'language'[', ''locale']],
  ["af", "Afrikaans"],
  ["af-NA", "Afrikaans", "Namibia"],
  ["af-ZA", "Afrikaans", "South Africa"],
  ["ak", "Akan"],
  ["ak-GH", "Akan", "Ghana"],
  ["am", "Amharic"],
  ["am-ET", "Amharic", "Ethiopia"],
  ["ar", "Arabic"],
  ["ar-1", "Arabic"],
  ["ar-AE", "Arabic", "United Arab Emirates"],
  ["ar-BH", "Arabic", "Bahrain"],
  ["ar-DJ", "Arabic", "Djibouti"],
  ["ar-DZ", "Arabic", "Algeria"],
  ["ar-EG", "Arabic", "Egypt"],
  ["ar-EH", "Arabic"],
  ["ar-ER", "Arabic", "Eritrea"],
  ["ar-IL", "Arabic", "Israel"],
  ["ar-IQ", "Arabic", "Iraq"],
  ["ar-JO", "Arabic", "Jordan"],
  ["ar-KM", "Arabic", "Comoros"],
  ["ar-KW", "Arabic", "Kuwait"],
  ["ar-LB", "Arabic", "Lebanon"],
  ["ar-LY", "Arabic", "Libya"],
  ["ar-MA", "Arabic", "Morocco"],
  ["ar-MR", "Arabic", "Mauritania"],
  ["ar-OM", "Arabic", "Oman"],
  ["ar-PS", "Arabic"],
  ["ar-QA", "Arabic", "Qatar"],
  ["ar-SA", "Arabic", "Saudi Arabia"],
  ["ar-SD", "Arabic", "Sudan"],
  ["ar-SO", "Arabic", "Somalia"],
  ["ar-SS", "Arabic"],
  ["ar-SY", "Arabic", "Syria"],
  ["ar-TD", "Arabic", "Chad"],
  ["ar-TN", "Arabic", "Tunisia"],
  ["ar-YE", "Arabic", "Yemen"],
  ["as", "Assamese"],
  ["as-IN", "Assamese", "India"],
  ["az", "Azerbaijani"],
  ["az-AZ", "Azerbaijani", "Azerbaijan"],
  ["be", "Belarusian"],
  ["be-BY", "Belarusian", "Belarus"],
  ["bg", "Bulgarian"],
  ["bg-BG", "Bulgarian", "Bulgaria"],
  ["bm", "Bambara"],
  ["bm-ML", "Bambara", "Mali"],
  ["bn", "Bengali"],
  ["bn-BD", "Bengali", "Bangladesh"],
  ["bn-IN", "Bengali", "India"],
  ["bo", "Tibetan"],
  ["bo-CN", "Tibetan", "China"],
  ["bo-IN", "Tibetan", "India"],
  ["br", "Breton"],
  ["br-FR", "Breton", "France"],
  ["bs", "Bosnian"],
  ["bs-BA", "Bosnian", "Bosnia and Herzegovina"],
  ["ca", "Catalan"],
  ["ca-AD", "Catalan", "Andorra"],
  ["ca-ES", "Catalan", "Spain"],
  ["ca-FR", "Catalan", "France"],
  ["ca-IT", "Catalan", "Italy"],
  ["ce", "Chechen"],
  ["ce-RU", "Chechen", "Russia"],
  ["cs", "Czech"],
  ["cs-CZ", "Czech", "Czech Republic"],
  ["cu", "Old Slavonic"],
  ["cu-RU", "Old Slavonic", "Russia"],
  ["cy", "Welsh"],
  ["cy-GB", "Welsh", "United Kingdom"],
  ["da", "Danish"],
  ["da-DK", "Danish", "Denmark"],
  ["da-GL", "Danish", "Greenland"],
  ["de", "German"],
  ["de-AT", "German", "Austria"],
  ["de-BE", "German", "Belgium"],
  ["de-CH", "German", "Switzerland"],
  ["de-DE", "German", "Germany"],
  ["de-IT", "German", "Italy"],
  ["de-LI", "German", "Liechtenstein"],
  ["de-LU", "German", "Luxembourg"],
  ["dz", "Dzongkha"],
  // cspell:ignore Dzongkha
  ["dz-BT", "Dzongkha", "Bhutan"],
  ["ee", "Ewe"],
  ["ee-GH", "Ewe", "Ghana"],
  ["ee-TG", "Ewe", "Togo"],
  ["el", "Greek", "Modern (1453-)"],
  ["el-CY", "Greek", "Cyprus"],
  ["el-GR", "Greek", "Greece"],
  ["en", "English"],
  ["en-AG", "English", "Antigua and Barbuda"],
  ["en-AI", "English", "Anguilla"],
  ["en-AS", "English", "American Samoa"],
  ["en-AT", "English", "Austria"],
  ["en-AU", "English", "Australia"],
  ["en-BB", "English", "Barbados"],
  ["en-BE", "English", "Belgium"],
  ["en-BI", "English", "Burundi"],
  ["en-BM", "English", "Bermuda"],
  ["en-BS", "English", "Bahamas"],
  ["en-BW", "English", "Botswana"],
  ["en-BZ", "English", "Belize"],
  ["en-CA", "English", "Canada"],
  ["en-CC", "English", "Cocos (Keeling) Islands"],
  ["en-CH", "English", "Switzerland"],
  ["en-CK", "English", "Cook Islands"],
  ["en-CM", "English", "Cameroon"],
  ["en-CX", "English", "Christmas Island"],
  ["en-CY", "English", "Cyprus"],
  ["en-DE", "English", "Germany"],
  ["en-DG", "English"],
  ["en-DK", "English", "Denmark"],
  ["en-DM", "English", "Dominica"],
  ["en-ER", "English", "Eritrea"],
  ["en-FI", "English", "Finland"],
  ["en-FJ", "English", "Fiji"],
  ["en-FK", "English", "Falkland Islands (Islas Malvinas)"],
  // cspell:ignore Islas
  ["en-FM", "English", "Micronesia"],
  ["en-GB", "English", "United Kingdom"],
  ["en-GD", "English", "Grenada"],
  ["en-GG", "English", "Guernsey"],
  ["en-GH", "English", "Ghana"],
  ["en-GI", "English", "Gibraltar"],
  ["en-GM", "English", "Gambia"],
  ["en-GU", "English", "Guam"],
  ["en-GY", "English", "Guyana"],
  ["en-HK", "English", "Hong Kong"],
  ["en-IE", "English", "Ireland"],
  ["en-IL", "English", "Israel"],
  ["en-IM", "English", "Isle of Man"],
  ["en-IN", "English", "India"],
  ["en-IO", "English", "British Indian Ocean Territory"],
  ["en-JE", "English", "Jersey"],
  ["en-JM", "English", "Jamaica"],
  ["en-KE", "English", "Kenya"],
  ["en-KI", "English", "Kiribati"],
  ["en-KN", "English", "Saint Kitts and Nevis"],
  // cspell:ignore Kitts
  ["en-KY", "English", "Cayman Islands"],
  ["en-LC", "English", "Saint Lucia"],
  ["en-LR", "English", "Liberia"],
  ["en-LS", "English", "Lesotho"],
  ["en-MG", "English", "Madagascar"],
  ["en-MH", "English", "Marshall Islands"],
  ["en-MO", "English", "Macau"],
  ["en-MP", "English", "Northern Mariana Islands"],
  ["en-MS", "English", "Montserrat"],
  ["en-MT", "English", "Malta"],
  ["en-MU", "English", "Mauritius"],
  ["en-MW", "English", "Malawi"],
  ["en-MY", "English", "Malaysia"],
  ["en-NA", "English", "Namibia"],
  ["en-NF", "English", "Norfolk Island"],
  ["en-NG", "English", "Nigeria"],
  ["en-NL", "English", "Netherlands"],
  ["en-NR", "English", "Nauru"],
  ["en-NU", "English", "Niue"],
  ["en-NZ", "English", "New Zealand"],
  ["en-PG", "English", "Papua New Guinea"],
  ["en-PH", "English", "Philippines"],
  ["en-PK", "English", "Pakistan"],
  ["en-PN", "English", "Pitcairn Islands"],
  ["en-PR", "English", "Puerto Rico"],
  ["en-PW", "English", "Palau"],
  ["en-RW", "English", "Rwanda"],
  ["en-SB", "English", "Solomon Islands"],
  ["en-SC", "English", "Seychelles"],
  ["en-SD", "English", "Sudan"],
  ["en-SE", "English", "Sweden"],
  ["en-SG", "English", "Singapore"],
  ["en-SH", "English", "Saint Helena"],
  ["en-SI", "English", "Slovenia"],
  ["en-SL", "English", "Sierra Leone"],
  ["en-SS", "English"],
  ["en-SX", "English"],
  ["en-SZ", "English", "Swaziland"],
  ["en-TC", "English", "Turks and Caicos Islands"],
  // cspell:ignore Caicos
  ["en-TK", "English", "Tokelau"],
  // cspell:ignore Tokelau
  ["en-TO", "English", "Tonga"],
  ["en-TT", "English", "Trinidad and Tobago"],
  ["en-TV", "English", "Tuvalu"],
  ["en-TZ", "English", "Tanzania"],
  ["en-UG", "English", "Uganda"],
  ["en-UM", "English", "Baker Island"],
  ["en-US", "English", "United States"],
  ["en-VC", "English", "Saint Vincent and the Grenadines"],
  ["en-VG", "English", "British Virgin Islands"],
  ["en-VI", "English", "U.S. Virgin Islands"],
  ["en-VU", "English", "Vanuatu"],
  ["en-WS", "English", "Samoa"],
  ["en-ZA", "English", "South Africa"],
  ["en-ZM", "English", "Zambia"],
  ["en-ZW", "English", "Zimbabwe"],
  ["eo", "Esperanto"],
  ["es", "Spanish"],
  ["es-AR", "Spanish", "Argentina"],
  ["es-BO", "Spanish", "Bolivia"],
  ["es-BR", "Spanish", "Brazil"],
  ["es-BZ", "Spanish", "Belize"],
  ["es-CL", "Spanish", "Chile"],
  ["es-CO", "Spanish", "Colombia"],
  ["es-CR", "Spanish", "Costa Rica"],
  // cspell:ignore Rica
  ["es-CU", "Spanish", "Cuba"],
  ["es-DO", "Spanish", "Dominican Republic"],
  ["es-EA", "Spanish"],
  ["es-EC", "Spanish", "Ecuador"],
  ["es-ES", "Spanish", "Spain"],
  ["es-GQ", "Spanish", "Equatorial Guinea"],
  ["es-GT", "Spanish", "Guatemala"],
  ["es-HN", "Spanish", "Honduras"],
  ["es-IC", "Spanish"],
  ["es-MX", "Spanish", "Mexico"],
  ["es-NI", "Spanish", "Nicaragua"],
  ["es-PA", "Spanish", "Panama"],
  ["es-PE", "Spanish", "Peru"],
  ["es-PH", "Spanish", "Philippines"],
  ["es-PR", "Spanish", "Puerto Rico"],
  ["es-PY", "Spanish", "Paraguay"],
  ["es-SV", "Spanish", "El Salvador"],
  ["es-US", "Spanish", "United States"],
  ["es-UY", "Spanish", "Uruguay"],
  ["es-VE", "Spanish", "Venezuela"],
  ["et", "Estonian"],
  ["et-EE", "Estonian", "Estonia"],
  ["eu", "Basque"],
  ["eu-ES", "Basque", "Spain"],
  ["fa", "Persian"],
  ["fa-AF", "Persian", "Afghanistan"],
  ["fa-IR", "Persian", "Iran"],
  ["ff", "Fulah"],
  // cspell:ignore Fulah
  ["ff-CM", "Fulah", "Cameroon"],
  ["ff-GN", "Fulah", "Guinea"],
  ["ff-MR", "Fulah", "Mauritania"],
  ["ff-SN", "Fulah", "Senegal"],
  ["fi", "Finnish"],
  ["fi-FI", "Finnish", "Finland"],
  ["fo", "Faroese"],
  // cspell:ignore Faroese
  ["fo-DK", "Faroese", "Denmark"],
  ["fo-FO", "Faroese", "Faroe Islands"],
  ["fr", "French"],
  ["fr-BE", "French", "Belgium"],
  ["fr-BF", "French", "Burkina Faso"],
  // cspell:ignore Burkina Faso
  ["fr-BI", "French", "Burundi"],
  ["fr-BJ", "French", "Benin"],
  ["fr-BL", "French"],
  ["fr-CA", "French", "Canada"],
  ["fr-CD", "French", "Congo"],
  ["fr-CF", "French", "Central African Republic"],
  ["fr-CG", "French", "Congo"],
  ["fr-CH", "French", "Switzerland"],
  ["fr-CI", "French, Cote d'Ivoire (Ivory Coast)"],
  // cspell:ignore d'Ivoire
  ["fr-CM", "French", "Cameroon"],
  ["fr-DJ", "French", "Djibouti"],
  ["fr-DZ", "French", "Algeria"],
  ["fr-FR", "French", "France"],
  ["fr-GA", "French", "Gabon"],
  ["fr-GF", "French", "French Guiana"],
  ["fr-GN", "French", "Guinea"],
  ["fr-GP", "French", "Saint Barthelemy"],
  // cspell:ignore Barthelemy
  ["fr-GQ", "French", "Equatorial Guinea"],
  ["fr-HT", "French", "Haiti"],
  ["fr-KM", "French", "Comoros"],
  ["fr-LU", "French", "Luxembourg"],
  ["fr-MA", "French", "Morocco"],
  ["fr-MC", "French", "Monaco"],
  ["fr-MF", "French"],
  ["fr-MG", "French", "Madagascar"],
  ["fr-ML", "French", "Mali"],
  ["fr-MQ", "French", "Martinique"],
  ["fr-MR", "French", "Mauritania"],
  ["fr-MU", "French", "Mauritius"],
  ["fr-NC", "French", "New Caledonia"],
  ["fr-NE", "French", "Niger"],
  ["fr-PF", "French", "French Polynesia"],
  ["fr-PM", "French", "Saint Pierre and Miquelon"],
  ["fr-RE", "French", "Reunion"],
  ["fr-RW", "French", "Rwanda"],
  ["fr-SC", "French", "Seychelles"],
  ["fr-SN", "French", "Senegal"],
  ["fr-SY", "French", "Syria"],
  ["fr-TD", "French", "Chad"],
  ["fr-TG", "French", "Togo"],
  ["fr-TN", "French", "Tunisia"],
  ["fr-VU", "French", "Vanuatu"],
  ["fr-WF", "French", "Wallis and Futuna"],
  // cspell:ignore Futuna
  ["fr-YT", "French", "Mayotte"],
  ["fy", "Western Frisian"],
  ["fy-NL", "Western Frisian", "Netherlands"],
  ["ga", "Irish"],
  ["ga-IE", "Irish", "Ireland"],
  ["gd", "Gaelic"],
  ["gd-GB", "Gaelic", "United Kingdom"],
  ["gl", "Galician"],
  ["gl-ES", "Galician", "Spain"],
  ["gu", "Gujarati"],
  ["gu-IN", "Gujarati", "India"],
  ["gv", "Manx"],
  ["gv-IM", "Manx", "Isle of Man"],
  ["ha", "Hausa"],
  ["ha-GH", "Hausa", "Ghana"],
  ["ha-NE", "Hausa", "Niger"],
  ["ha-NG", "Hausa", "Nigeria"],
  ["he", "Hebrew"],
  ["he-IL", "Hebrew", "Israel"],
  ["hi", "Hindi"],
  ["hi-IN", "Hindi", "India"],
  ["hr", "Croatian"],
  ["hr-BA", "Croatian", "Bosnia and Herzegovina"],
  ["hr-HR", "Croatian", "Croatia"],
  ["hu", "Hungarian"],
  ["hu-HU", "Hungarian", "Hungary"],
  ["hy", "Armenian"],
  ["hy-AM", "Armenian", "Armenia"],
  ["id", "Indonesian"],
  ["id-ID", "Indonesian", "Indonesia"],
  ["ig", "Igbo"],
  ["ig-NG", "Igbo", "Nigeria"],
  ["ii", "Sichuan Yi"],
  ["ii-CN", "Sichuan Yi", "China"],
  ["is", "Icelandic"],
  ["is-IS", "Icelandic", "Iceland"],
  ["it", "Italian"],
  ["it-CH", "Italian", "Switzerland"],
  ["it-IT", "Italian", "Italy"],
  ["it-SM", "Italian", "San Marino"],
  // cspell:ignore Marino
  ["it-VA", "Italian", "Vatican City"],
  ["ja", "Japanese"],
  ["ja-JP", "Japanese", "Japan"],
  ["ka", "Georgian"],
  ["ka-GE", "Georgian", "Georgia"],
  ["ki", "Kikuyu"],
  ["ki-KE", "Kikuyu", "Kenya"],
  ["kk", "Kazakh"],
  ["kk-KZ", "Kazakh", "Kazakhstan"],
  ["kl", "Kalaallisut"],
  // cspell:ignore Kalaallisut
  ["kl-GL", "Kalaallisut", "Greenland"],
  ["km", "Central Khmer"],
  ["km-KH", "Central Khmer", "Cambodia"],
  ["kn", "Kannada"],
  ["kn-IN", "Kannada", "India"],
  ["ko", "Korean"],
  ["ko-KP", "Korean", "Korea"],
  ["ko-KR", "Korean", "Korea"],
  ["ks", "Kashmiri"],
  ["ks-IN", "Kashmiri", "India"],
  ["kw", "Cornish"],
  ["kw-GB", "Cornish", "United Kingdom"],
  ["ky", "Kirghiz"],
  ["ky-KG", "Kirghiz", "Kyrgyzstan"],
  ["lb", "Luxembourgish"],
  // cspell:ignore Luxembourgish
  ["lb-LU", "Luxembourgish", "Luxembourg"],
  ["lg", "Ganda"],
  ["lg-UG", "Ganda", "Uganda"],
  ["ln", "Lingala"],
  // cspell:ignore Lingala
  ["ln-AO", "Lingala", "Angola"],
  ["ln-CD", "Lingala", "Congo"],
  ["ln-CF", "Lingala", "Central African Republic"],
  ["ln-CG", "Lingala", "Congo"],
  ["lo", "Lao"],
  ["lo-LA", "Lao", "Laos"],
  ["lt", "Lithuanian"],
  ["lt-LT", "Lithuanian", "Lithuania"],
  ["lu", "Luba-Katanga"],
  // cspell:ignore Luba
  ["lu-CD", "Luba-Katanga", "Congo"],
  ["lv", "Latvian"],
  ["lv-LV", "Latvian", "Latvia"],
  ["mg", "Malagasy"],
  ["mg-MG", "Malagasy", "Madagascar"],
  ["mk", "Macedonian"],
  ["mk-MK", "Macedonian", "Macedonia"],
  ["ml", "Malayalam"],
  ["ml-IN", "Malayalam", "India"],
  ["mn", "Mongolian"],
  ["mn-MN", "Mongolian", "Mongolia"],
  ["mr", "Marathi"],
  ["mr-IN", "Marathi", "India"],
  ["ms", "Malay"],
  ["ms-BN", "Malay", "Brunei"],
  ["ms-MY", "Malay", "Malaysia"],
  ["ms-SG", "Malay", "Singapore"],
  ["mt", "Maltese"],
  ["mt-MT", "Maltese", "Malta"],
  ["my", "Burmese"],
  ["my-MM", "Burmese", "Myanmar (Burma)"],
  ["nb", "Bokm\xE5l Norwegian"],
  // cspell:ignore Bokml
  ["nb-NO", "Bokm\xE5l Norwegian", "Norway"],
  ["nb-SJ", "Bokm\xE5l Norwegian", "Svalbard"],
  ["nd", "Ndebele, North"],
  // cspell:ignore Ndebele
  ["nd-ZW", "Ndebele, North", "Zimbabwe"],
  ["ne", "Nepali"],
  ["ne-IN", "Nepali", "India"],
  ["ne-NP", "Nepali", "Nepal"],
  ["nl", "Dutch"],
  ["nl-AW", "Dutch", "Aruba"],
  ["nl-BE", "Dutch", "Belgium"],
  ["nl-BQ", "Dutch"],
  ["nl-CW", "Dutch"],
  ["nl-NL", "Dutch", "Netherlands"],
  ["nl-SR", "Dutch", "Suriname"],
  ["nl-SX", "Dutch"],
  ["nn", "Norwegian Nynorsk"],
  ["nn-NO", "Norwegian Nynorsk", "Norway"],
  ["om", "Oromo"],
  // cspell:ignore Oromo
  ["om-ET", "Oromo", "Ethiopia"],
  ["om-KE", "Oromo", "Kenya"],
  ["or", "Oriya"],
  ["or-IN", "Oriya", "India"],
  ["os", "Ossetian"],
  // cspell:ignore Ossetian
  ["os-GE", "Ossetian", "Georgia"],
  ["os-RU", "Ossetian", "Russia"],
  ["pa", "Panjabi"],
  ["pa-IN", "Panjabi", "India"],
  ["pa-PK", "Panjabi", "Pakistan"],
  ["pl", "Polish"],
  ["pl-PL", "Polish", "Poland"],
  ["ps", "Pushto"],
  // cspell:ignore Pushto
  ["ps-AF", "Pushto", "Afghanistan"],
  ["pt", "Portuguese"],
  ["pt-AO", "Portuguese", "Angola"],
  ["pt-BR", "Portuguese", "Brazil"],
  ["pt-CH", "Portuguese", "Switzerland"],
  ["pt-CV", "Portuguese", "Cape Verde"],
  ["pt-GQ", "Portuguese", "Equatorial Guinea"],
  ["pt-GW", "Portuguese", "Guinea-Bissau"],
  ["pt-LU", "Portuguese", "Luxembourg"],
  ["pt-MO", "Portuguese", "Macau"],
  ["pt-MZ", "Portuguese", "Mozambique"],
  ["pt-PT", "Portuguese", "Portugal"],
  ["pt-ST", "Portuguese", "Sao Tome and Principe"],
  ["pt-TL", "Portuguese", "Timor-Leste (East Timor)"],
  // cspell:ignore Leste
  ["qu", "Quechua"],
  ["qu-BO", "Quechua", "Bolivia"],
  ["qu-EC", "Quechua", "Ecuador"],
  ["qu-PE", "Quechua", "Peru"],
  ["rm", "Romansh"],
  ["rm-CH", "Romansh", "Switzerland"],
  ["rn", "Rundi"],
  // cspell:ignore Rundi
  ["rn-BI", "Rundi", "Burundi"],
  ["ro", "Romanian"],
  ["ro-MD", "Romanian", "Moldova"],
  ["ro-RO", "Romanian", "Romania"],
  ["ru", "Russian"],
  ["ru-BY", "Russian", "Belarus"],
  ["ru-KG", "Russian", "Kyrgyzstan"],
  ["ru-KZ", "Russian", "Kazakhstan"],
  ["ru-MD", "Russian", "Moldova"],
  ["ru-RU", "Russian", "Russia"],
  ["ru-UA", "Russian", "Ukraine"],
  ["rw", "Kinyarwanda"],
  // cspell:ignore Kinyarwanda
  ["rw-RW", "Kinyarwanda", "Rwanda"],
  ["se", "Northern Sami"],
  // cspell:ignore Sami
  ["se-FI", "Northern Sami", "Finland"],
  ["se-NO", "Northern Sami", "Norway"],
  ["se-SE", "Northern Sami", "Sweden"],
  ["sg", "Sango"],
  // cspell:ignore Sango
  ["sg-CF", "Sango", "Central African Republic"],
  ["si", "Sinhala"],
  // cspell:ignore Sinhala
  ["si-LK", "Sinhala", "Sri Lanka"],
  ["sk", "Slovak"],
  ["sk-SK", "Slovak", "Slovakia"],
  ["sl", "Slovenian"],
  ["sl-SI", "Slovenian", "Slovenia"],
  ["sn", "Shona"],
  // cspell:ignore Shona
  ["sn-ZW", "Shona", "Zimbabwe"],
  ["so", "Somali"],
  ["so-DJ", "Somali", "Djibouti"],
  ["so-ET", "Somali", "Ethiopia"],
  ["so-KE", "Somali", "Kenya"],
  ["so-SO", "Somali", "Somalia"],
  ["sq", "Albanian"],
  ["sq-AL", "Albanian", "Albania"],
  ["sq-MK", "Albanian", "Macedonia"],
  ["sq-XK", "Albanian"],
  ["sr", "Serbian"],
  ["sr-BA", "Serbian", "Bosnia and Herzegovina"],
  ["sr-ME", "Serbian", "Montenegro"],
  ["sr-RS", "Serbian", "Serbia"],
  ["sr-XK", "Serbian"],
  ["sv", "Swedish"],
  ["sv-AX", "Swedish", "Aland"],
  // cspell:ignore Aland
  ["sv-FI", "Swedish", "Finland"],
  ["sv-SE", "Swedish", "Sweden"],
  ["sw", "Swahili"],
  ["sw-CD", "Swahili", "Congo"],
  ["sw-KE", "Swahili", "Kenya"],
  ["sw-TZ", "Swahili", "Tanzania"],
  ["sw-UG", "Swahili", "Uganda"],
  ["ta", "Tamil"],
  ["ta-IN", "Tamil", "India"],
  ["ta-LK", "Tamil", "Sri Lanka"],
  ["ta-MY", "Tamil", "Malaysia"],
  ["ta-SG", "Tamil", "Singapore"],
  ["te", "Telugu"],
  ["te-IN", "Telugu", "India"],
  ["th", "Thai"],
  ["th-TH", "Thai", "Thailand"],
  ["ti", "Tigrinya"],
  ["ti-ER", "Tigrinya", "Eritrea"],
  ["ti-ET", "Tigrinya", "Ethiopia"],
  ["tk", "Turkmen"],
  ["tk-TM", "Turkmen", "Turkmenistan"],
  ["to", "Tonga (Tonga Islands)"],
  ["to-TO", "Tonga (Tonga Islands)", "Tonga"],
  ["tr", "Turkish"],
  ["tr-CY", "Turkish", "Cyprus"],
  ["tr-TR", "Turkish", "Turkey"],
  ["ug", "Uighur"],
  ["ug-CN", "Uighur", "China"],
  ["uk", "Ukrainian"],
  ["uk-UA", "Ukrainian", "Ukraine"],
  ["ur", "Urdu"],
  ["ur-IN", "Urdu", "India"],
  ["ur-PK", "Urdu", "Pakistan"],
  ["uz", "Uzbek"],
  ["uz-AF", "Uzbek", "Afghanistan"],
  ["uz-UZ", "Uzbek", "Uzbekistan"],
  ["vi", "Vietnamese"],
  ["vi-VN", "Vietnamese", "Vietnam"],
  ["vo", "Volap\xFCk"],
  // cspell:ignore Volapk
  ["yi", "Yiddish"],
  ["yi-1", "Yiddish"],
  ["yo", "Yoruba"],
  ["yo-BJ", "Yoruba", "Benin"],
  ["yo-NG", "Yoruba", "Nigeria"],
  ["zh", "Chinese"],
  ["zh-CN", "Chinese", "China"],
  ["zh-HK", "Chinese", "Hong Kong"],
  ["zh-MO", "Chinese", "Macau"],
  ["zh-SG", "Chinese", "Singapore"],
  ["zh-TW", "Chinese", "China"],
  ["zu", "Zulu"],
  ["zu-ZA", "Zulu", "South Africa"]
];

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/models/locale/locale.js
var codesByLocale;
var Locale = class {
  _raw;
  _locale;
  constructor(locale) {
    this._raw = locale;
    this._locale = normalizeLocale(locale);
  }
  get locale() {
    return this._locale;
  }
  localInfo() {
    return lookupLocaleInfo(this._locale);
  }
  isValid() {
    return isStandardLocale(this._locale);
  }
  toJSON() {
    return this.locale;
  }
  toString() {
    return this.locale;
  }
};
var regExTwoLetter = /^[a-z]{2}$/i;
var regExLocaleWithCountry = /^([a-z]{2})[_-]?([a-z]{2,3})$/i;
var regExValidLocale = /^([a-z]{2})(?:-([A-Z]{2,3}))?$/;
function normalizeLocale(locale) {
  locale = locale.trim();
  if (regExTwoLetter.test(locale))
    return locale.toLowerCase();
  const m = locale.match(regExLocaleWithCountry);
  if (!m)
    return locale;
  const lang = m[1].toLowerCase();
  const variant = m[2].toUpperCase();
  return `${lang}-${variant}`;
}
function isStandardLocale(locale) {
  return regExValidLocale.test(locale);
}
function lookupLocaleInfo(locale) {
  codesByLocale = codesByLocale || buildLocaleLookup();
  return codesByLocale.get(locale);
}
function buildLocaleLookup() {
  const info = codes.map(([locale, language, country]) => ({ locale, language, country }));
  return new Map(info.map((i) => [i.locale, i]));
}
function createLocale(locale) {
  return new Locale(locale);
}
function parseLocale(locales) {
  locales = typeof locales === "string" ? locales.split(",") : locales;
  return locales.map(createLocale);
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/mapCosts.js
var defaultEditCosts = {
  accentCosts: 1,
  baseCost: 100,
  capsCosts: 1,
  firstLetterPenalty: 4,
  nonAlphabetCosts: 110
};
var defaultHunspellCosts = {
  ...defaultEditCosts,
  ioConvertCost: 30,
  keyboardCost: 99,
  mapCost: 25,
  replaceCosts: 75,
  tryCharCost: 100
};
function mapHunspellCosts(costs = {}) {
  return { ...defaultHunspellCosts, ...cleanCopy(costs) };
}
function mapEditCosts(costs = {}) {
  return { ...defaultEditCosts, ...cleanCopy(costs) };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/joinLetters.js
function joinLetters(letters) {
  const v = [...letters];
  return v.map((a) => a.length > 1 || !a.length ? `(${a})` : a).join("");
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/mapToSuggestionCostDef.js
function parseAlphabet(cs, locale, editCost) {
  const { cost, penalty } = cs;
  const characters = expandCharacterSet(cs.characters);
  const charForms = [
    ...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))
  ];
  const alphabet = joinLetters([
    ...pipeSync(charForms, opFlattenSync(), opMapSync((letter) => accentForms(letter)), opFlattenSync(), opUniqueSync())
  ].sort());
  const sugAlpha = clean({
    map: alphabet,
    replace: cost,
    insDel: cost,
    swap: cost,
    penalty
  });
  return [
    sugAlpha,
    parseAlphabetCaps(cs.characters, locale, editCost),
    ...calcCostsForAccentedLetters(alphabet, locale, editCost)
  ];
}
function parseAlphabetCaps(alphabet, locale, editCost) {
  const characters = expandCharacterSet(alphabet);
  const charForms = [
    ...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))
  ];
  const caps = charForms.map((a) => joinLetters(a)).join("|");
  const sugCaps = {
    map: caps,
    replace: editCost.capsCosts
  };
  return sugCaps;
}
function calcFirstCharacterReplaceDefs(alphabets, editCost) {
  return alphabets.map((cs) => calcFirstCharacterReplace(cs, editCost));
}
function calcFirstCharacterReplace(cs, editCost) {
  const mapOfFirstLetters = [
    ...pipeSync(expandCharacterSet(cs.characters), opUniqueSync(), opMapSync((letter) => `(^${letter})`))
  ].sort().join("") + "(^)";
  const penalty = editCost.firstLetterPenalty;
  const cost = cs.cost - penalty;
  return {
    map: mapOfFirstLetters,
    replace: cost,
    penalty: penalty * 2
  };
}
function parseAccents(cs, _editCost) {
  const { cost, penalty } = cs;
  const accents = joinLetters([
    ...pipeSync(expandCharacterSet(cs.characters), opMapSync((char) => stripNonAccents(char)))
  ]);
  if (!accents)
    return void 0;
  return clean({
    map: accents,
    replace: cost,
    insDel: cost,
    penalty
  });
}
function calcCostsForAccentedLetters(simpleMap, locale, costs) {
  const charactersWithAccents = [
    ...pipeSync(splitMap2(simpleMap), opMapSync((char) => caseForms(char, locale)), opFlattenSync(), opMapSync((char) => [...accentForms(char)]), opFilterSync((forms2) => forms2.length > 1))
  ];
  const characters = pipeSync(charactersWithAccents, opMapSync((forms2) => /* @__PURE__ */ new Set([...forms2, ...forms2.map((char) => stripAccents(char))])), opMapSync((forms2) => [...forms2].sort()), opFilterSync((forms2) => forms2.length > 1), opMapSync(joinLetters), opUniqueSync());
  const replaceAccentMap = [...characters].join("|");
  const cost = costs.accentCosts;
  const costToReplaceAccent = !replaceAccentMap ? [] : [{ map: replaceAccentMap, replace: cost }];
  const normalizeMap2 = charactersWithAccents.map((a) => a.sort()).map(joinLetters).join("|");
  const costToNormalizeAccent = !normalizeMap2 ? [] : [{ map: normalizeMap2, replace: 0 }];
  return [...costToReplaceAccent, ...costToNormalizeAccent];
}
function* splitMap2(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield seq;
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield char;
  }
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/mapHunspellInformation.js
function hunspellInformationToSuggestionCostDef(hunInfo, locales) {
  const costs = calcCosts(hunInfo.costs, locales);
  const operations = [
    affKey,
    affKeyCaps,
    affMap,
    affMapAccents,
    affMapCaps,
    affNoTry,
    affRepConv,
    affTry,
    affTryAccents,
    affTryFirstCharacterReplace
  ];
  function parseAff(aff, costs2) {
    const regSupportedAff = /^(?:MAP|KEY|TRY|NO-TRY|ICONV|OCONV|REP)\s/;
    const rejectAff = /^(?:MAP|KEY|TRY|ICONV|OCONV|REP)\s+\d+$/;
    const lines = aff.split("\n").map((a) => a.replace(/#.*/, "")).map((a) => a.trim()).filter((a) => regSupportedAff.test(a)).filter((a) => !rejectAff.test(a));
    const defs = pipeSync(lines, opMapSync((line) => pipeSync(operations, opMapSync((fn) => fn(line, costs2)), opMapSync(asArrayOf), opFlattenSync())), opFlattenSync(), opFilterSync(isDefined));
    return [...defs];
  }
  return parseAff(hunInfo.aff, costs);
}
function calcCosts(costs = {}, locale) {
  const useLocale = (locale == null ? void 0 : locale.length) ? locale.map((loc) => loc.locale) : void 0;
  const hunCosts = mapHunspellCosts(costs);
  const c = {
    ...hunCosts,
    locale: useLocale
  };
  return c;
}
var regExpMap = /^(?:MAP)\s+(\S+)$/;
function affMap(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return void 0;
  const map3 = m[1];
  const cost = costs.mapCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
var regExpTry = /^(?:TRY)\s+(\S+)$/;
function affTry(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return void 0;
  const cost = costs.tryCharCost;
  const tryChars = m[1];
  const characters = tryChars;
  return parseAlphabet({
    characters,
    cost
  }, costs.locale, costs);
}
function affTryFirstCharacterReplace(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return void 0;
  const characters = m[1];
  const cost = costs.tryCharCost;
  return calcFirstCharacterReplace({
    characters,
    cost
  }, costs);
}
var regExpNoTry = /^NO-TRY\s+(\S+)$/;
function affNoTry(line, costs) {
  const m = line.match(regExpNoTry);
  if (!m)
    return void 0;
  const map3 = m[1];
  return {
    map: map3,
    insDel: Math.max(costs.nonAlphabetCosts - costs.tryCharCost, 0),
    penalty: costs.nonAlphabetCosts + costs.tryCharCost
  };
}
var regExpRepConv = /^(?:REP|(?:I|O)CONV)\s+(\S+)\s+(\S+)$/;
function affRepConv(line, costs) {
  const m = line.match(regExpRepConv);
  if (!m)
    return void 0;
  const cost = line.startsWith("REP") ? costs.replaceCosts : costs.ioConvertCost;
  const from2 = m[1];
  let into = m[2];
  into = into.replace(/^0$/, "");
  if (from2.startsWith("^") && !into.startsWith("^")) {
    into = "^" + into;
  }
  if (from2.endsWith("$") && !into.endsWith("$")) {
    into = into + "$";
  }
  return {
    map: joinLetters([from2, into]),
    replace: cost
  };
}
var regExpKey = /^(?:KEY)\s+(\S+)$/;
function affKey(line, costs) {
  const m = line.match(regExpKey);
  if (!m)
    return void 0;
  const kbd = m[1];
  const pairs = [...splitMap2(kbd)].map(reducer((p, v) => ({ a: p.b, b: v }), { a: "|", b: "|" })).filter((ab) => ab.a !== "|" && ab.b !== "|").map(({ a, b }) => joinLetters([a, b]));
  const pairsUpper = pairs.map((p) => p.toLocaleUpperCase(costs.locale));
  const map3 = unique([...pairs, ...pairsUpper]).join("|");
  const cost = costs.keyboardCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
function affKeyCaps(line, costs) {
  const m = line.match(regExpKey);
  if (!m)
    return void 0;
  return parseCaps(m[1], costs);
}
function affMapCaps(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return void 0;
  return parseCaps(m[1], costs);
}
function affTryAccents(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function affMapAccents(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function parseCaps(value, costs) {
  const locale = costs.locale;
  const letters = [...splitMap2(value)].filter((a) => a !== "|");
  const withCases = letters.map((s) => caseForms(s, locale)).filter((forms2) => forms2.length > 1).map(joinLetters);
  const map3 = unique(withCases).join("|");
  const cost = costs.capsCosts;
  if (!map3)
    return void 0;
  return {
    map: map3,
    replace: cost
  };
}
function reducer(fn, initialVal) {
  let acc = initialVal;
  return (val, i) => acc = fn(acc, val, i);
}
function asArrayOf(v) {
  return Array.isArray(v) ? v : [v];
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/mapDictionaryInfo.js
function mapDictionaryInformation(dictInfo) {
  const _locale = dictInfo.locale;
  const locale = _locale ? parseLocale(_locale).filter((loc) => loc.isValid()) : void 0;
  const locales = locale == null ? void 0 : locale.map((loc) => loc.locale);
  const costs = mapEditCosts(dictInfo.costs);
  const defsEC = dictInfo.suggestionEditCosts || [];
  const defsHI = dictInfo.hunspellInformation ? hunspellInformationToSuggestionCostDef(dictInfo.hunspellInformation, locale) : [];
  return [
    ...defsEC,
    ...processAlphabet(dictInfo.alphabet, locales, costs),
    ...processAccents(dictInfo.accents, costs),
    ...defsHI
  ];
}
function processAlphabet(alphabet, locale, editCost) {
  const csAlphabet = toCharSets(alphabet, "a-zA-Z", editCost.baseCost);
  return [
    ...pipeSync(csAlphabet, opMapSync((cs) => parseAlphabet(cs, locale, editCost)), opFlattenSync()),
    ...calcFirstCharacterReplaceDefs(csAlphabet, editCost)
  ];
}
function toCharSets(cs, defaultValue, cost, penalty) {
  cs = cs ?? defaultValue;
  if (!cs)
    return [];
  if (typeof cs === "string") {
    cs = [
      {
        characters: cs,
        cost
      }
    ];
  }
  if (penalty !== void 0) {
    cs.forEach((cs2) => cs2.penalty = penalty);
  }
  return cs;
}
function processAccents(accents, editCost) {
  const cs = toCharSets(accents, "\u0300-\u0341", editCost.accentCosts);
  return cs.map((cs2) => parseAccents(cs2, editCost)).filter(isDefined);
}
function mapDictionaryInformationToAdjustment(dictInfo) {
  if (!dictInfo.adjustments)
    return [];
  return dictInfo.adjustments.map(mapAdjustment);
}
function mapAdjustment(adj) {
  const { id, regexp, penalty } = adj;
  return {
    id,
    regexp: new RegExp(regexp),
    penalty
  };
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/mappers/mapDictionaryInfoToWeightMap.js
var defaultDefs = [
  {
    map: "1234567890-.",
    insDel: 1,
    penalty: 200
  }
];
var defaultAdjustments = [
  {
    id: "compound-case-change",
    regexp: new RegExp("\\p{Ll}\u2219\\p{Lu}", "gu"),
    penalty: 1e3
  },
  {
    id: "short-compounds-1",
    regexp: /^[^]{0,2}(?=)|[^]{0,2}(?=|$)/gm,
    penalty: 100
  },
  {
    id: "short-compounds-3",
    regexp: /^[^]{3}(?=)|[^]{3}(?=|$)/gm,
    penalty: 50
  }
];
function mapDictionaryInformationToWeightMap(dictInfo) {
  const defs = [...mapDictionaryInformation(dictInfo), ...defaultDefs];
  const adjustments = mapDictionaryInformationToAdjustment(dictInfo);
  const map3 = createWeightMap(...defs);
  addAdjustment(map3, ...defaultAdjustments, ...adjustments);
  return map3;
}

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/utils/normalizeWord.js
var normalizeWord = (text) => text.normalize();
var normalizeWordForCaseInsensitive = (text) => {
  const t = text.toLowerCase();
  return [t, t.normalize("NFD").replaceAll(new RegExp("\\p{M}", "gu"), "")];
};

// node_modules/.pnpm/cspell-trie-lib@8.14.2/node_modules/cspell-trie-lib/dist/lib/SimpleDictionaryParser.js
var RegExpSplit = /[\s,;]/g;
var _defaultOptions = {
  commentCharacter: LINE_COMMENT,
  optionalCompoundCharacter: OPTIONAL_COMPOUND_FIX,
  compoundCharacter: COMPOUND_FIX,
  forbiddenPrefix: FORBID_PREFIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  keepExactPrefix: IDENTITY_PREFIX,
  stripCaseAndAccents: true,
  stripCaseAndAccentsKeepDuplicate: false,
  stripCaseAndAccentsOnForbidden: false,
  split: false,
  splitKeepBoth: false,
  splitSeparator: RegExpSplit
};
var defaultParseDictionaryOptions = Object.freeze(_defaultOptions);
var cSpellToolDirective = "cspell-dictionary:";
function createDictionaryLineParserMapper(options) {
  const _options = options || _defaultOptions;
  const { commentCharacter = _defaultOptions.commentCharacter, optionalCompoundCharacter: optionalCompound = _defaultOptions.optionalCompoundCharacter, compoundCharacter: compound = _defaultOptions.compoundCharacter, caseInsensitivePrefix: ignoreCase2 = _defaultOptions.caseInsensitivePrefix, forbiddenPrefix: forbidden = _defaultOptions.forbiddenPrefix, keepExactPrefix: keepCase = _defaultOptions.keepExactPrefix, splitSeparator = _defaultOptions.splitSeparator, splitKeepBoth = _defaultOptions.splitKeepBoth, stripCaseAndAccentsKeepDuplicate = _defaultOptions.stripCaseAndAccentsKeepDuplicate, stripCaseAndAccentsOnForbidden = _defaultOptions.stripCaseAndAccentsOnForbidden } = _options;
  let { stripCaseAndAccents = _defaultOptions.stripCaseAndAccents, split: split2 = _defaultOptions.split } = _options;
  function isString3(line) {
    return typeof line === "string";
  }
  function trim(line) {
    return line.trim();
  }
  function removeComments(line) {
    const idx2 = line.indexOf(commentCharacter);
    if (idx2 < 0)
      return line;
    const idxDirective = line.indexOf(cSpellToolDirective, idx2);
    if (idxDirective >= 0) {
      const flags = line.slice(idxDirective).split(/[\s,;]/g).map((s) => s.trim()).filter((a) => !!a);
      for (const flag of flags) {
        switch (flag) {
          case "split": {
            split2 = true;
            break;
          }
          case "no-split": {
            split2 = false;
            break;
          }
          case "no-generate-alternatives": {
            stripCaseAndAccents = false;
            break;
          }
          case "generate-alternatives": {
            stripCaseAndAccents = true;
            break;
          }
        }
      }
    }
    return line.slice(0, idx2).trim();
  }
  function filterEmptyLines(line) {
    return !!line;
  }
  function* mapOptionalPrefix(line) {
    if (line[0] === optionalCompound) {
      const t = line.slice(1);
      yield t;
      yield compound + t;
    } else {
      yield line;
    }
  }
  function* mapOptionalSuffix(line) {
    if (line.slice(-1) === optionalCompound) {
      const t = line.slice(0, -1);
      yield t;
      yield t + compound;
    } else {
      yield line;
    }
  }
  const doNotNormalizePrefix = /* @__PURE__ */ Object.create(null);
  [ignoreCase2, keepCase, '"'].forEach((prefix) => doNotNormalizePrefix[prefix] = true);
  if (!stripCaseAndAccentsOnForbidden) {
    doNotNormalizePrefix[forbidden] = true;
  }
  function removeDoublePrefix(w) {
    return w.startsWith(ignoreCase2 + ignoreCase2) ? w.slice(1) : w;
  }
  function stripKeepCasePrefixAndQuotes(word) {
    word = word.replaceAll(/"(.*?)"/g, "$1");
    return word[0] === keepCase ? word.slice(1) : word;
  }
  function _normalize(word) {
    return normalizeWord(stripKeepCasePrefixAndQuotes(word));
  }
  function* mapNormalize(word) {
    const nWord = _normalize(word);
    const forms2 = /* @__PURE__ */ new Set();
    forms2.add(nWord);
    if (stripCaseAndAccents && !(word[0] in doNotNormalizePrefix)) {
      for (const n of normalizeWordForCaseInsensitive(nWord)) {
        (stripCaseAndAccentsKeepDuplicate || n !== nWord) && forms2.add(ignoreCase2 + n);
      }
    }
    yield* forms2;
  }
  function* splitWords(lines) {
    for (const line of lines) {
      if (split2) {
        const lineEscaped = line.includes('"') ? line.replaceAll(/".*?"/g, (quoted) => " " + quoted.replaceAll(/(\s)/g, "\\$1") + " ") : line;
        const words = splitLine(lineEscaped, splitSeparator);
        yield* words.map((escaped) => escaped.replaceAll("\\", ""));
        if (!splitKeepBoth)
          continue;
      }
      yield line;
    }
  }
  function* splitLines(paragraphs) {
    for (const paragraph of paragraphs) {
      yield* paragraph.split("\n");
    }
  }
  const processLines = opCombineSync(opFilterSync(isString3), splitLines, opMapSync(removeComments), splitWords, opMapSync(trim), opFilterSync(filterEmptyLines), opConcatMapSync(mapOptionalPrefix), opConcatMapSync(mapOptionalSuffix), opConcatMapSync(mapNormalize), opMapSync(removeDoublePrefix));
  return processLines;
}
function parseDictionaryLines(lines, options) {
  return createDictionaryLineParserMapper(options)(typeof lines === "string" ? [lines] : lines);
}
var RegExpToEncode = /\\([\s,;])/g;
var RegExpDecode = /<<(%[\da-f]{2})>>/gi;
function encodeLine(line) {
  return line.replaceAll(RegExpToEncode, (_, v) => "<<" + encodeURIComponent(v) + ">>");
}
function decodeLine(line) {
  return line.replaceAll(RegExpDecode, (_, v) => "\\" + decodeURIComponent(v));
}
function splitLine(line, regExp) {
  return encodeLine(line).split(regExp).map((line2) => decodeLine(line2));
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/text.js
var regExFirstUpper = new RegExp("^\\p{Lu}\\p{M}?\\p{Ll}+$", "u");
var regExAllUpper = new RegExp("^(?:\\p{Lu}\\p{M}?)+$", "u");
var regExAllLower = new RegExp("^(?:\\p{Ll}\\p{M}?)+$", "u");
var regExAccents = new RegExp("\\p{M}", "gu");
function isUpperCase(word) {
  return !!regExAllUpper.test(word);
}
function ucFirst(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function removeAccents(text) {
  return text.normalize("NFD").replaceAll(regExAccents, "");
}
function removeUnboundAccents(text) {
  return text.replaceAll(regExAccents, "");
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryMethods.js
var defaultNumSuggestions = 10;
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase2) {
  const forms2 = /* @__PURE__ */ new Set();
  word = word.normalize("NFC");
  const wordLc = word.toLowerCase();
  if (ignoreCase2) {
    if (isDictionaryCaseSensitive) {
      forms2.add(wordLc);
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  } else {
    if (isDictionaryCaseSensitive) {
      forms2.add(word);
      forms2.add(wordLc);
      if (isUpperCase(word)) {
        forms2.add(ucFirst(wordLc));
      }
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  }
  return forms2;
}
function wordSuggestFormsArray(word) {
  return [...wordSuggestForms(word)];
}
function wordSuggestForms(word) {
  word = word.normalize("NFC");
  const forms2 = /* @__PURE__ */ new Set([word]);
  const wordLc = word.toLowerCase();
  forms2.add(wordLc);
  return forms2;
}
var DEFAULT_HAS_OPTIONS = Object.freeze({});
function hasOptionToSearchOption(opt) {
  return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
}
var canonicalSearchOptionsMap = /* @__PURE__ */ new Map();
var knownCanonicalOptions = /* @__PURE__ */ new WeakMap();
function canonicalSearchOptions(opt) {
  const known = knownCanonicalOptions.get(opt);
  if (known)
    return known;
  const { ignoreCase: ignoreCase2, useCompounds } = opt;
  const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase2);
  const useLevel1Map = foundLevel1Map || /* @__PURE__ */ new Map();
  if (!foundLevel1Map) {
    canonicalSearchOptionsMap.set(ignoreCase2, useLevel1Map);
  }
  const foundCanOpts = useLevel1Map.get(useCompounds);
  const canOpts = foundCanOpts || Object.freeze({ ignoreCase: ignoreCase2, useCompounds });
  if (!foundCanOpts) {
    useLevel1Map.set(useCompounds, canOpts);
  }
  knownCanonicalOptions.set(opt, canOpts);
  return canOpts;
}
function createWeightMapFromDictionaryInformation(di) {
  return di ? mapDictionaryInformationToWeightMap(di) : void 0;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/CachingDictionary.js
var dictionaryCounter = 0;
var DefaultAutoCacheSize = 1e3;
var logRequests = false;
var log = [];
var startTime = performance.now();
var _has;
var CachedDict = class {
  constructor(dict, options) {
    __publicField(this, "dict");
    __publicField(this, "options");
    __publicField(this, "name");
    __publicField(this, "id", ++dictionaryCounter);
    __privateAdd(this, _has, autoCache((word) => this.dict.has(word, this.options), DefaultAutoCacheSize));
    __publicField(this, "has", logRequests ? (word) => {
      const time = performance.now() - startTime;
      const value = __privateGet(this, _has).call(this, word);
      log.push({ time, method: "has", word, value });
      return value;
    } : __privateGet(this, _has));
    __publicField(this, "isNoSuggestWord", autoCache((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize));
    __publicField(this, "isForbidden", autoCache((word) => this.dict.isForbidden(word), DefaultAutoCacheSize));
    __publicField(this, "getPreferredSuggestions", autoCache((word) => {
      var _a3, _b;
      return (_b = (_a3 = this.dict).getPreferredSuggestions) == null ? void 0 : _b.call(_a3, word);
    }, DefaultAutoCacheSize));
    this.dict = dict;
    this.options = options;
    this.name = dict.name;
  }
  stats() {
    return {
      name: this.name,
      id: this.id,
      has: extractStats(__privateGet(this, _has)),
      isNoSuggestWord: extractStats(this.isNoSuggestWord),
      isForbidden: extractStats(this.isForbidden),
      getPreferredSuggestions: extractStats(this.getPreferredSuggestions)
    };
  }
};
_has = new WeakMap();
var knownDicts = /* @__PURE__ */ new Map();
function createCachingDictionary(dict, options) {
  options = canonicalSearchOptions(options);
  let knownOptions = knownDicts.get(options);
  if (!knownOptions) {
    knownOptions = /* @__PURE__ */ new WeakMap();
    knownDicts.set(options, knownOptions);
  }
  const known = knownOptions.get(dict);
  if (known)
    return known;
  const cached = new CachedDict(dict, options);
  knownOptions.set(dict, cached);
  return cached;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/AutoResolve.js
function autoResolveWeak(map3, key, resolve3) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve3(key);
  map3.set(key, value);
  return value;
}
var AutoResolveWeakCache = class {
  map = /* @__PURE__ */ new WeakMap();
  get(k, resolve3) {
    return resolve3 ? autoResolveWeak(this.map, k, resolve3) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
};
function createAutoResolveWeakCache() {
  return new AutoResolveWeakCache();
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/util.js
function isDefined2(v) {
  return v !== void 0;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var import_node_url = require("url");

// node_modules/.pnpm/fast-equals@5.0.1/node_modules/fast-equals/dist/esm/index.mjs
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular2(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache4 = state.cache;
    var cachedA = cache4.get(a);
    var cachedB = cache4.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache4.set(a, b);
    cache4.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache4.delete(a);
    cache4.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || function(object, property) {
  return hasOwnProperty.call(object, property);
};
function sameValueZeroEqual(a, b) {
  return a || b ? a === b : a === b || a !== a && b !== b;
}
var OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areMapsEqual(a, b, state) {
  if (a.size !== b.size) {
    return false;
  }
  var matchedIndices = {};
  var aIterable = a.entries();
  var index = 0;
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      var _a3 = aResult.value, aKey = _a3[0], aValue = _a3[1];
      var _b = bResult.value, bKey = _b[0], bValue = _b[1];
      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index, matchIndex, a, b, state) && state.equals(aValue, bValue, aKey, bKey, a, b, state))) {
        matchedIndices[matchIndex] = true;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  var property;
  while (index-- > 0) {
    property = properties[index];
    if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {
      return false;
    }
    if (!hasOwn(b, property) || !state.equals(a[property], b[property], property, property, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {
      return false;
    }
    if (!hasOwn(b, property)) {
      return false;
    }
    if (!state.equals(a[property], b[property], property, property, a, b, state)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  if (a.size !== b.size) {
    return false;
  }
  var matchedIndices = {};
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {
        matchedIndices[matchIndex] = true;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var isArray = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign2 = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a3) {
  var areArraysEqual2 = _a3.areArraysEqual, areDatesEqual2 = _a3.areDatesEqual, areMapsEqual2 = _a3.areMapsEqual, areObjectsEqual2 = _a3.areObjectsEqual, arePrimitiveWrappersEqual2 = _a3.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a3.areRegExpsEqual, areSetsEqual2 = _a3.areSetsEqual, areTypedArraysEqual2 = _a3.areTypedArraysEqual;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null || typeof a !== "object" || typeof b !== "object") {
      return a !== a && b !== b;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a3) {
  var circular = _a3.circular, createCustomConfig = _a3.createCustomConfig, strict = _a3.strict;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual
  };
  if (createCustomConfig) {
    config = assign2({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign2({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare3) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare3(a, b, state);
  };
}
function createIsEqual(_a3) {
  var circular = _a3.circular, comparator = _a3.comparator, createState = _a3.createState, equals = _a3.equals, strict = _a3.strict;
  if (createState) {
    return function isEqual(a, b) {
      var _a4 = createState(), _b = _a4.cache, cache4 = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a4.meta;
      return comparator(a, b, {
        cache: cache4,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === void 0) {
    options = {};
  }
  var _a3 = options.circular, circular = _a3 === void 0 ? false : _a3, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
  var config = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/simpleCache.js
var SimpleWeakCache = class {
  size;
  L0 = /* @__PURE__ */ new WeakMap();
  L1 = /* @__PURE__ */ new WeakMap();
  L2 = /* @__PURE__ */ new WeakMap();
  sizeL0 = 0;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.sizeL0 >= this.size) {
      this.rotate();
    }
    this.sizeL0 += 1;
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new WeakMap();
    this.sizeL0 = 0;
  }
};
var AutoWeakCache = class extends SimpleWeakCache {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};
var SimpleCache = class {
  size;
  L0 = /* @__PURE__ */ new Map();
  L1 = /* @__PURE__ */ new Map();
  L2 = /* @__PURE__ */ new Map();
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new Map();
  }
};

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionary.js
var defaultOptions = Object.freeze({
  weightMap: void 0
});

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/clean.js
function clean3(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0) {
      delete r[key];
    }
  }
  return r;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/regexHelper.js
function escapeRegEx(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/repMap.js
function createMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (a) => a;
  repMap = repMap || [];
  const charsetMap = charsetToRepMapRegEx(ignoreCharset);
  if (charsetMap) {
    repMap = [...repMap, ...charsetMap];
  }
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return (a) => a;
  }
  const regEx = createMapperRegExp(repMap);
  const values = repMap.filter(([match2, _]) => !!match2).map(([_, into]) => into);
  function resolve3(m, ...matches) {
    const index = matches.findIndex((a) => !!a);
    return 0 <= index && index < values.length ? values[index] : m;
  }
  return function(s) {
    return s.replace(regEx, resolve3);
  };
}
function charsetToRepMapRegEx(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").map((chars) => `[${chars.replaceAll(/[\][\\]/g, "\\$&")}]`).map((map3) => [map3, replaceWith]);
}
function charsetToRepMap(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").flatMap((chars) => [...expandCharacterSet(chars)]).map((char) => [char, replaceWith]);
}
function expandReplaceMap(repMap) {
  return repMap.flatMap(([from2, replaceWith]) => from2.split("|").map((w) => [w, replaceWith]));
}
function createMapperRegExp(repMap) {
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return /$^/;
  }
  const regExStr = filteredMap.map(([from2, _]) => from2).map((s) => {
    try {
      const r = /\(/.test(s) ? s.replaceAll(/\((?=.*\))/g, "(?:").replaceAll("(?:?", "(?") : s;
      new RegExp(r);
      s = r;
    } catch {
      return escapeRegEx(s);
    }
    return s;
  }).map((s) => `(${s})`).join("|");
  const regEx = new RegExp(regExStr, "g");
  return regEx;
}
function createRepMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (word) => [word];
  const trie = createTrie(repMap, ignoreCharset);
  return (word) => {
    const edits = calcAllEdits(trie, word);
    return applyEdits(word, edits);
  };
}
function applyEdits(word, edits) {
  if (!edits.length)
    return [word];
  const letterEdits = [];
  for (let i = 0; i < word.length; ++i) {
    letterEdits[i] = { edits: [{ b: i, e: i + 1, r: word[i] }], suffixes: [] };
  }
  letterEdits[word.length] = { edits: [], suffixes: [""] };
  for (const edit of edits) {
    const le = letterEdits[edit.b];
    le.edits.push(edit);
  }
  for (let i = word.length - 1; i >= 0; --i) {
    const le = letterEdits[i];
    const sfx = le.suffixes;
    for (const edit of le.edits) {
      const pfx = edit.r;
      const nSfx = letterEdits[edit.e].suffixes;
      for (const s of nSfx) {
        sfx.push(pfx + s);
      }
    }
  }
  const results = new Set(letterEdits[0].suffixes);
  return [...results];
}
function calcAllEdits(root, word) {
  const edits = [];
  function walk3(node, b, e) {
    if (node.rep) {
      node.rep.forEach((r) => edits.push({ b, e, r }));
    }
    if (e === word.length || !node.children)
      return;
    const n = node.children[word[e]];
    if (!n)
      return;
    walk3(n, b, e + 1);
  }
  for (let i = 0; i < word.length; ++i) {
    walk3(root, i, i);
  }
  return edits;
}
function createTrie(repMap, ignoreCharset) {
  const combined = [repMap, charsetToRepMap(ignoreCharset)].filter(isDefined2).flat();
  const expanded = expandReplaceMap(combined);
  const trieRoot = /* @__PURE__ */ Object.create(null);
  expanded.forEach(([match2, replaceWith]) => addToTrie(trieRoot, match2, replaceWith));
  return trieRoot;
}
function addToTrie(node, match2, replaceWith) {
  while (match2) {
    const children = node.children || (node.children = /* @__PURE__ */ Object.create(null));
    const k = match2[0];
    const childNode = children[k] || (children[k] = /* @__PURE__ */ Object.create(null));
    node = childNode;
    match2 = match2.slice(1);
  }
  const s = new Set(node.rep || []);
  s.add(replaceWith);
  node.rep = [...s];
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/defaults.js
var ignoreCase = true;
var isForbiddenIgnoreCaseAndAccents = false;

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryFromTrie.js
var findWordOptionsCaseSensitive = Object.freeze({ caseSensitive: true });
var findWordOptionsNotCaseSensitive = Object.freeze({ caseSensitive: false });
var SpellingDictionaryFromTrie = class {
  trie;
  name;
  options;
  source;
  _size = 0;
  knownWords = /* @__PURE__ */ new Set();
  unknownWords = /* @__PURE__ */ new Set();
  mapWord;
  remapWord;
  type = "SpellingDictionaryFromTrie";
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  weightMap;
  constructor(trie, name, options, source = "from trie", size) {
    var _a3, _b;
    this.trie = trie;
    this.name = name;
    this.options = options;
    this.source = source;
    this.mapWord = createMapper(options.repMap, (_a3 = options.dictionaryInformation) == null ? void 0 : _a3.ignore);
    this.remapWord = createRepMapper(options.repMap, (_b = options.dictionaryInformation) == null ? void 0 : _b.ignore);
    this.isDictionaryCaseSensitive = options.caseSensitive ?? trie.isCaseAware;
    this.containsNoSuggestWords = options.noSuggest || false;
    this._size = size || 0;
    this.weightMap = options.weightMap || createWeightMapFromDictionaryInformation(options.dictionaryInformation);
  }
  get size() {
    if (!this._size) {
      const i = this.trie.iterate();
      let deeper = true;
      let size = 0;
      for (let r = i.next(); !r.done; r = i.next(deeper)) {
        size += 1;
        deeper = r.value.text.length < 5;
      }
      this._size = size;
    }
    return this._size;
  }
  has(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    return !!r && !r.forbidden && !!r.found;
  }
  find(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    const { forbidden = this.isForbidden(word) } = r || {};
    if (!r && !forbidden)
      return void 0;
    const { found = forbidden ? word : false } = r || {};
    const noSuggest = found !== false && this.containsNoSuggestWords;
    return { found, forbidden, noSuggest };
  }
  resolveOptions(hasOptions) {
    const { useCompounds = this.options.useCompounds, ignoreCase: ignoreCase2 = ignoreCase } = hasOptionToSearchOption(hasOptions);
    return { useCompounds, ignoreCase: ignoreCase2 };
  }
  _find = (word, useCompounds, ignoreCase2) => this.findAnyForm(word, useCompounds, ignoreCase2);
  findAnyForm(word, useCompounds, ignoreCase2) {
    const outerForms = outerWordForms(word, this.remapWord || ((word2) => [this.mapWord(word2)]));
    for (const form of outerForms) {
      const r = this._findAnyForm(form, useCompounds, ignoreCase2);
      if (r)
        return r;
    }
    return void 0;
  }
  _findAnyForm(mWord, useCompounds, ignoreCase2) {
    const opts = ignoreCase2 ? findWordOptionsNotCaseSensitive : findWordOptionsCaseSensitive;
    const findResult = this.trie.findWord(mWord, opts);
    if (findResult.found !== false) {
      return findResult;
    }
    const forms2 = wordSearchForms(mWord, this.isDictionaryCaseSensitive, ignoreCase2);
    for (const w of forms2) {
      const findResult2 = this.trie.findWord(w, opts);
      if (findResult2.found !== false) {
        return findResult2;
      }
    }
    if (useCompounds) {
      const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
      for (const w of forms2) {
        const findResult2 = this.trie.findWord(w, optsUseCompounds);
        if (findResult2.found !== false) {
          return findResult2;
        }
      }
    }
    return void 0;
  }
  isNoSuggestWord(word, options) {
    return this.containsNoSuggestWords ? this.has(word, options) : false;
  }
  isForbidden(word, _ignoreCaseAndAccents) {
    return this.trie.isForbiddenWord(word);
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, includeTies, ignoreCase: ignoreCase2, timeout } = suggestOptions;
    function filter3(_word) {
      return true;
    }
    const collector = suggestionCollector(word, clean3({
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout,
      weightMap: this.weightMap
    }));
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions.map((r) => ({ ...r, word: r.word }));
  }
  genSuggestions(collector, suggestOptions) {
    if (this.options.noSuggest)
      return;
    const _compoundMethod = suggestOptions.compoundMethod ?? (this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : CompoundWordsMethod.NONE);
    wordSuggestFormsArray(collector.word).forEach((w) => this.trie.genSuggestions(impersonateCollector(collector, w), _compoundMethod));
  }
  getErrors() {
    return [];
  }
};
function createSpellingDictionaryFromTrieFile(data, name, source, options) {
  const trie = decodeTrie(data);
  return new SpellingDictionaryFromTrie(trie, name, options, source);
}
function* outerWordForms(word, mapWord) {
  const sent = /* @__PURE__ */ new Set();
  let w = word;
  const ww = w;
  yield w;
  sent.add(w);
  w = word.normalize("NFC");
  if (w !== ww) {
    yield w;
    sent.add(w);
  }
  w = word.normalize("NFD");
  if (w !== ww && !sent.has(w)) {
    yield w;
    sent.add(w);
  }
  for (const f of sent) {
    for (const m of mapWord(f)) {
      if (m !== ww && !sent.has(m)) {
        yield m;
        sent.add(m);
      }
    }
  }
  return;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var cachedDictionaries = new AutoWeakCache(_createSpellingDictionary, 64);
var maxSetSize = 3;
var cachedParamsByWordList = new SimpleCache(64);
function createSpellingDictionary(wordList, name, source, options) {
  const params = [wordList, name, source.toString(), options];
  if (!Array.isArray(wordList)) {
    return _createSpellingDictionary(params);
  }
  const cached = cachedParamsByWordList.get(name) || /* @__PURE__ */ new Set();
  for (const cachedParams of cached) {
    if (deepEqual(params, cachedParams)) {
      return cachedDictionaries.get(cachedParams);
    }
  }
  if (cached.size > maxSetSize)
    cached.clear();
  cached.add(params);
  cachedParamsByWordList.set(name, cached);
  return cachedDictionaries.get(params);
}
function _createSpellingDictionary(params) {
  const [wordList, name, source, options] = params;
  const parseOptions = { stripCaseAndAccents: (options == null ? void 0 : options.supportNonStrictSearches) ?? true };
  const words = parseDictionaryLines(wordList, parseOptions);
  const trie = buildITrieFromWords(words);
  const opts = { ...options || defaultOptions };
  if (opts.weightMap === void 0 && opts.dictionaryInformation) {
    opts.weightMap = createWeightMapFromDictionaryInformation(opts.dictionaryInformation);
  }
  return new SpellingDictionaryFromTrie(trie, name, opts, source);
}
function createFailedToLoadDictionary(name, sourceUrl, error, options) {
  const sourceHref = typeof sourceUrl === "string" ? sourceUrl : sourceUrl.href;
  const source = sourceHref.startsWith("file:") ? (0, import_node_url.fileURLToPath)(sourceUrl) : sourceHref;
  options = options || {};
  return {
    name,
    source,
    type: "error",
    containsNoSuggestWords: false,
    has: () => false,
    find: () => void 0,
    isNoSuggestWord: () => false,
    isForbidden: () => false,
    suggest: () => [],
    mapWord: (a) => a,
    genSuggestions: () => {
      return;
    },
    size: 0,
    options,
    isDictionaryCaseSensitive: false,
    getErrors: () => [error]
  };
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/util/textMappers.js
function* mapperRemoveCaseAndAccents(words) {
  for (const word of words) {
    const lc = word.toLowerCase();
    yield lc;
    const woAccents = removeAccents(lc);
    if (lc !== woAccents)
      yield woAccents;
  }
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
var import_node_assert3 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/util.js
function normalizeTyposDefValue(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return value;
  const unique2 = [...new Set(value)];
  return unique2.length > 1 ? unique2 : unique2.length === 1 ? unique2[0] : false;
}
function mergeDefEntry(targetDef, key, value) {
  const curValue = targetDef[key];
  if (!curValue) {
    targetDef[key] = normalizeTyposDefValue(value);
    return targetDef;
  }
  if (!value)
    return targetDef;
  const newValue = Array.isArray(curValue) ? curValue : [curValue];
  if (Array.isArray(value)) {
    newValue.push(...value);
  } else {
    newValue.push(value);
  }
  targetDef[key] = normalizeTyposDefValue(newValue);
  return targetDef;
}
function mergeDef(targetDef, fromDef) {
  for (const key of Object.keys(fromDef)) {
    mergeDefEntry(targetDef, key, fromDef[key]);
  }
  return targetDef;
}
function appendToDef(def, entry) {
  if (!entry)
    return def;
  if (typeof entry === "string") {
    if (!def[entry]) {
      def[entry] = false;
    }
    return def;
  }
  if (Array.isArray(entry)) {
    const [key, ...sugs] = entry.map((s2) => s2.trim());
    if (!key)
      return def;
    const s = sugs.map((s2) => s2.trim()).filter((s2) => !!s2);
    return mergeDefEntry(def, key, s);
  }
  return mergeDef(def, entry);
}
function createTyposDef(entries) {
  const def = /* @__PURE__ */ Object.create(null);
  if (!entries)
    return def;
  for (const [key, value] of entries) {
    def[key] = isDefined3(value) ? value : false;
  }
  return def;
}
function extractAllSuggestions(typosDef) {
  const allSugs = pipeSync(Object.values(typosDef), opFilterSync(hasSuggestions), opConcatMapSync((v) => Array.isArray(v) ? v : [v]));
  return new Set(allSugs);
}
function extractIgnoreValues(typosDef, ignorePrefix) {
  const pfxLen = ignorePrefix.length;
  return new Set(Object.keys(typosDef).filter((k) => k.startsWith(ignorePrefix)).map((k) => k.slice(pfxLen)));
}
function isDefined3(v) {
  return v !== void 0 && v !== null;
}
function isString(v) {
  return typeof v === "string";
}
function isArray2(v) {
  return Array.isArray(v);
}
function hasSuggestions(v) {
  return isString(v) || isArray2(v);
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
function assertString(v) {
  (0, import_node_assert3.default)(typeof v === "string", "A string was expected.");
  return true;
}
var suggestionsSeparator = /[,]/;
var typoSuggestionsSeparator = /:|->/;
var typoEntrySeparator = /[\n;]/;
function normalize2(s) {
  return s.normalize();
}
function trimAndFilter(lines) {
  return lines.map((s) => s.trim()).filter((s) => !!s).map(normalize2);
}
function cleanSugs(rawSugs) {
  const sugs = trimAndFilter(rawSugs);
  return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
  return cleanSugs(value.split(suggestionsSeparator));
}
function sanitizeIntoTypoDef(dirtyDef) {
  if (!dirtyDef || typeof dirtyDef !== "object")
    return void 0;
  const def = createTyposDef();
  for (const [rawKey, value] of Object.entries(dirtyDef)) {
    const key = normalize2(rawKey.trim());
    if (!key)
      continue;
    if (typeof value === "string") {
      def[key] = splitSuggestionsValue(value);
      continue;
    }
    if (Array.isArray(value)) {
      const sugs = cleanSugs(value.filter(assertString));
      def[key] = sugs;
      continue;
    }
    (0, import_node_assert3.default)(value === false, "Unexpected suggestion type.");
    def[key] = false;
  }
  return def;
}
function processEntriesToTyposDef(entries) {
  const def = isIterable2(entries) ? reduceToTyposDef(entries) : entries;
  const result = sanitizeIntoTypoDef(def);
  (0, import_node_assert3.default)(result);
  return result;
}
function reduceToTyposDef(entries) {
  const def = createTyposDef();
  for (const entry of entries) {
    appendToDef(def, parseTyposLine(entry));
  }
  return def;
}
function parseTyposLine(line) {
  if (!line)
    return void 0;
  if (typeof line === "string") {
    const def = createTyposDef();
    for (const subEntry of splitIntoLines(line)) {
      const [left, right] = splitEntry(subEntry);
      const typo = left.trim();
      if (!right)
        return typo;
      const sugs = splitSuggestionsValue(right);
      def[typo] = sugs;
    }
    return def;
  }
  if (Array.isArray(line)) {
    const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
    if (!key)
      return void 0;
    return [key, ...sugs];
  }
  return sanitizeIntoTypoDef(line);
}
function splitIntoLines(content) {
  return trimAndFilter(normalize2(content).split(typoEntrySeparator));
}
function splitEntry(line) {
  return line.split(typoSuggestionsSeparator, 2);
}
function isIterable2(v) {
  return Symbol.iterator in v;
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/TyposDictionary.js
var TyposDictionaryImpl = class {
  name;
  source;
  typosDef;
  containsNoSuggestWords;
  options = {};
  type = "typos";
  size;
  ignoreWords;
  /**
   * Note: ignoreWordsLower is only suggestions with the case and accents removed.
   * The logic is that if someone explicity ignored an upper case version, it does not
   * mean that the lower case version is ok.
   */
  suggestions;
  suggestionsLower;
  explicitIgnoreWords;
  constructor(name, source, typosDef, ignoreList) {
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.explicitIgnoreWords = extractIgnoreValues(typosDef, "!");
    this.suggestions = extractAllSuggestions(typosDef);
    this.ignoreWords = new Set(pipeSync(this.explicitIgnoreWords, opAppendSync(ignoreList || [])));
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
    this.containsNoSuggestWords = this.ignoreWords.size > 0;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    const result = this._findForms(word, (options == null ? void 0 : options.ignoreCase) ?? ignoreCase);
    if (result === false)
      return void 0;
    const { found, ignore } = result;
    return { found, forbidden: !ignore, noSuggest: ignore };
  }
  _findForms(word, ignoreCaseAndAccents) {
    const lcWord = word.toLowerCase();
    if (this.ignoreWords.has(word)) {
      return { found: word, ignore: true };
    }
    if (this.suggestions.has(word)) {
      return false;
    }
    if (ignoreCaseAndAccents) {
      if (this.suggestionsLower.has(lcWord)) {
        return false;
      }
      if (this.ignoreWords.has(lcWord)) {
        return { found: lcWord, ignore: true };
      }
    }
    if (word in this.typosDef)
      return { found: word, ignore: false };
    if (lcWord in this.typosDef)
      return { found: lcWord, ignore: false };
    return false;
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const found = this._findForms(word, ignoreCaseAndAccents);
    return found !== false && !found.ignore;
  }
  isNoSuggestWord(word, options) {
    const result = this.find(word, options);
    return (result == null ? void 0 : result.noSuggest) ?? false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (this.ignoreWords.has(word))
      return [];
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache = createAutoResolveWeakCache();
function createTyposDictionary(entries, name, source) {
  return createCache.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new TyposDictionaryImpl(name, source, def);
  });
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/FlagWordsDictionary.js
var FlagWordsDictionaryTrie = class extends SpellingDictionaryFromTrie {
  name;
  source;
  containsNoSuggestWords = false;
  options = {};
  constructor(trie, name, source) {
    super(trie, name, defaultOptions, source);
    this.name = name;
    this.source = source;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  find(word, hasOptions) {
    const f = super.find(word, hasOptions);
    if (!f || !f.forbidden)
      return void 0;
    return f;
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  isDictionaryCaseSensitive = true;
};
var FlagWordsDictionary = class {
  name;
  source;
  dictTypos;
  dictTrie;
  containsNoSuggestWords = false;
  options = {};
  type = "flag-words";
  constructor(name, source, dictTypos, dictTrie) {
    this.name = name;
    this.source = source;
    this.dictTypos = dictTypos;
    this.dictTrie = dictTrie;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param word - the word
   * @param options - options
   * @returns always false
   */
  has(word, options) {
    var _a3;
    return this.dictTypos.has(word, options) || ((_a3 = this.dictTrie) == null ? void 0 : _a3.has(word, options)) || false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    var _a3;
    const findTypos = this.dictTypos.find(word, options);
    if (findTypos)
      return findTypos;
    const ignoreCase2 = (options == null ? void 0 : options.ignoreCase) ?? ignoreCase;
    if (this.dictTypos.isSuggestedWord(word, ignoreCase2))
      return void 0;
    return (_a3 = this.dictTrie) == null ? void 0 : _a3.find(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
    return (findResult == null ? void 0 : findResult.forbidden) || false;
  }
  isNoSuggestWord(word, options) {
    var _a3;
    return ((_a3 = this.dictTrie) == null ? void 0 : _a3.isNoSuggestWord(word, options)) || this.dictTypos.isNoSuggestWord(word, options);
  }
  suggest(word, suggestOptions = {}) {
    return this.dictTypos.suggest(word, suggestOptions);
  }
  getPreferredSuggestions(word) {
    return this.dictTypos.getPreferredSuggestions(word);
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    var _a3;
    return this.dictTypos.size + (((_a3 = this.dictTrie) == null ? void 0 : _a3.size) || 0);
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache2 = createAutoResolveWeakCache();
function createFlagWordsDictionary(wordList, name, source) {
  return createCache2.get(wordList, () => {
    const testSpecialCharacters = /[~*+]/;
    const { t: specialWords, f: typoWords } = bisect(parseDictionaryLines(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
    const trieDict = specialWords.size ? buildTrieDict(specialWords, name, source) : void 0;
    const typosDict = createTyposDictionary(typoWords, name, source);
    if (!trieDict)
      return typosDict;
    return new FlagWordsDictionary(name, source, typosDict, trieDict);
  });
}
var regExpCleanIgnore = /^(!!)+/;
function buildTrieDict(words, name, source) {
  const trie = buildITrieFromWords(pipeSync(words, opMapSync((w) => "!" + w), opMapSync((w) => w.replace(regExpCleanIgnore, ""))));
  return new FlagWordsDictionaryTrie(trie, name, source);
}
function bisect(values, predicate) {
  const t = /* @__PURE__ */ new Set();
  const f = /* @__PURE__ */ new Set();
  for (const v of values) {
    if (predicate(v)) {
      t.add(v);
    } else {
      f.add(v);
    }
  }
  return { t, f };
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/IgnoreWordsDictionary.js
var NormalizeForm = "NFC";
var IgnoreWordsDictionary = class {
  name;
  source;
  dict;
  dictNonStrict;
  containsNoSuggestWords = true;
  options = {};
  type = "ignore";
  constructor(name, source, words) {
    this.name = name;
    this.source = source;
    this.dict = new Set(words);
    this.dictNonStrict = new Set(pipeSync(this.dict, opFilterSync((w) => w.startsWith("~")), opMapSync((w) => w.slice(1))));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return true;
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return true;
    const ignoreCase2 = (options == null ? void 0 : options.ignoreCase) ?? ignoreCase;
    return ignoreCase2 && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return { found: lcWord, forbidden: false, noSuggest: true };
    const ignoreCase2 = (options == null ? void 0 : options.ignoreCase) ?? ignoreCase;
    if (!ignoreCase2)
      return void 0;
    if (this.dictNonStrict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    return this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true } || void 0;
  }
  isForbidden(_word, _ignoreCase) {
    return false;
  }
  isNoSuggestWord(word, options) {
    return this.has(word, options);
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    return this.dict.size;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache3 = createAutoResolveWeakCache();
function createIgnoreWordsDictionary(wordList, name, source) {
  return createCache3.get(wordList, () => {
    const testSpecialCharacters = /[*+]/;
    const words = [...parseDictionaryLines(wordList, { stripCaseAndAccents: true })].map((w) => w.normalize(NormalizeForm));
    const hasSpecial = words.some((word) => testSpecialCharacters.test(word));
    if (hasSpecial) {
      return createSpellingDictionary(words, name, source, {
        caseSensitive: true,
        noSuggest: true,
        weightMap: void 0,
        supportNonStrictSearches: true
      });
    }
    return new IgnoreWordsDictionary(name, source, words);
  });
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryCollection.js
function identityString(w) {
  return w;
}
var SpellingDictionaryCollectionImpl = class {
  dictionaries;
  name;
  options = { weightMap: void 0 };
  mapWord = identityString;
  type = "SpellingDictionaryCollection";
  source;
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  constructor(dictionaries, name, source) {
    this.dictionaries = dictionaries;
    this.name = name;
    this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
    this.source = source || dictionaries.map((d) => d.name).join(", ");
    this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
    this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
  }
  has(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
  }
  find(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return findInAnyDictionary(this.dictionaries, word, options);
  }
  isNoSuggestWord(word, options) {
    return this._isNoSuggestWord(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents) {
    const ignoreCase2 = ignoreCaseAndAccents ?? isForbiddenIgnoreCaseAndAccents;
    return !!this._isForbiddenInDict(word, ignoreCase2) && !this.isNoSuggestWord(word, { ignoreCase: ignoreCase2 });
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, ignoreCase: ignoreCase2, includeTies, timeout } = suggestOptions;
    const prefixNoCase = CASE_INSENSITIVE_PREFIX;
    const filter3 = (word2, _cost) => {
      return (ignoreCase2 || word2[0] !== prefixNoCase) && !this.isForbidden(word2) && !this.isNoSuggestWord(word2, suggestOptions);
    };
    const collectorOptions = {
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout
    };
    const collector = suggestionCollector(word, collectorOptions);
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions;
  }
  get size() {
    return this.dictionaries.reduce((a, b) => a + b.size, 0);
  }
  getPreferredSuggestions(word) {
    const sugs = this.dictionaries.flatMap((dict) => {
      var _a3;
      return (_a3 = dict.getPreferredSuggestions) == null ? void 0 : _a3.call(dict, word);
    }).filter(isDefined2);
    if (sugs.length <= 1)
      return sugs;
    const unique2 = /* @__PURE__ */ new Set();
    return sugs.filter((sug) => {
      if (unique2.has(sug.word))
        return false;
      unique2.add(sug.word);
      return true;
    });
  }
  genSuggestions(collector, suggestOptions) {
    const _suggestOptions = { ...suggestOptions };
    const { compoundMethod = CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
    _suggestOptions.compoundMethod = this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : compoundMethod;
    this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
  }
  getErrors() {
    return this.dictionaries.reduce((errors, dict) => {
      var _a3;
      return [...errors, ...((_a3 = dict.getErrors) == null ? void 0 : _a3.call(dict)) || []];
    }, []);
  }
  _isForbiddenInDict(word, ignoreCase2) {
    return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase2);
  }
  _isNoSuggestWord = (word, options) => {
    if (!this.containsNoSuggestWords)
      return false;
    return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
  };
};
function createCollection(dictionaries, name, source) {
  return new SpellingDictionaryCollectionImpl(dictionaries, name, source);
}
function isWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.has(word, options));
}
function findInAnyDictionary(dicts, word, options) {
  const found = dicts.map((dict) => dict.find(word, options)).filter(isDefined2);
  if (!found.length)
    return void 0;
  return found.reduce((a, b) => ({
    found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
    forbidden: a.forbidden || b.forbidden,
    noSuggest: a.noSuggest || b.noSuggest
  }));
}
function isNoSuggestWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.isNoSuggestWord(word, options));
}
function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase2) {
  return dicts.find((dict) => dict.isForbidden(word, ignoreCase2));
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/SuggestDictionary.js
var SuggestDictionaryImpl = class {
  name;
  source;
  typosDef;
  containsNoSuggestWords = false;
  options = {};
  type = "suggest";
  size;
  /**
   * Note: ignoreWordsLower is only suggestions with the case and accents removed.
   * The logic is that if someone explicity ignored an upper case version, it does not
   * mean that the lower case version is ok.
   */
  suggestions;
  suggestionsLower;
  constructor(name, source, typosDef) {
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.suggestions = extractAllSuggestions(typosDef);
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(_word, _options) {
    return void 0;
  }
  isForbidden(_word, _ignoreCaseAndAccents) {
    return false;
  }
  isNoSuggestWord(_word, _options) {
    return false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
};
var createCache4 = createAutoResolveWeakCache();
function createSuggestDictionary(entries, name, source) {
  return createCache4.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new SuggestDictionaryImpl(name, source, def);
  });
}

// node_modules/.pnpm/cspell-dictionary@8.14.2/node_modules/cspell-dictionary/dist/SpellingDictionary/createInlineSpellingDictionary.js
var cache = createAutoResolveWeakCache();
function createInlineSpellingDictionary(inlineDict, source) {
  return cache.get(inlineDict, () => {
    const { words, flagWords, ignoreWords, suggestWords, name } = inlineDict;
    const dictSources = [
      words && createSpellingDictionary(words, name + "-words", source, inlineDict),
      flagWords && createFlagWordsDictionary(flagWords, name + "-flag-words", source),
      ignoreWords && createIgnoreWordsDictionary(ignoreWords, name + "-ignore-words", source),
      suggestWords && createSuggestDictionary(suggestWords, name + "-suggest", source)
    ].filter(isDefined2);
    return createCollection(dictSources, name, source);
  });
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
var path6 = __toESM(require("path"), 1);

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/util.js
var uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
  const values = /* @__PURE__ */ new Set();
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean4(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0 || r[key] === null) {
      delete r[key];
    }
  }
  return r;
}
function scanMap(accFn, init) {
  let acc = init;
  let first3 = true;
  return function(value) {
    if (first3 && acc === void 0) {
      first3 = false;
      acc = value;
      return acc;
    }
    acc = accFn(acc, value);
    return acc;
  };
}
function isDefined4(v) {
  return v !== void 0;
}
async function asyncIterableToArray(iter) {
  const acc = [];
  for await (const t of iter) {
    acc.push(t);
  }
  return acc;
}
function isArrayEqual(a, b) {
  if (a === b)
    return true;
  let isMatch = a.length === b.length;
  for (let i = 0; i < a.length && isMatch; ++i) {
    isMatch = a[i] === b[i];
  }
  return isMatch;
}
function doSetsIntersect(a, b) {
  function compare3(a2, b2) {
    for (const item of a2) {
      if (b2.has(item))
        return true;
    }
    return false;
  }
  return a.size <= b.size ? compare3(a, b) : compare3(b, a);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Models/CSpellSettingsInternalDef.js
var SymbolCSpellSettingsInternal = Symbol("CSpellSettingsInternal");
function cleanCSpellSettingsInternal(parts = {}) {
  const csi = clean4(parts);
  Object.assign(csi, { [SymbolCSpellSettingsInternal]: true });
  return csi;
}
function createCSpellSettingsInternal(parts = {}) {
  return clean4({
    ...parts,
    [SymbolCSpellSettingsInternal]: true
  });
}
function isCSpellSettingsInternal(cs) {
  return !!cs[SymbolCSpellSettingsInternal];
}
function isDictionaryDefinitionInlineInternal(def) {
  if (def.path)
    return false;
  const defInline = def;
  return !!(defInline.words || defInline.flagWords || defInline.ignoreWords || defInline.suggestWords);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/AutoResolve.js
function autoResolve(map3, key, resolve3) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve3(key);
  map3.set(key, value);
  return value;
}
var CacheStatsTracker = class {
  hits = 0;
  misses = 0;
  resolved = 0;
  deletes = 0;
  sets = 0;
  clears = 0;
  disposals = 0;
  stats() {
    return {
      hits: this.hits,
      misses: this.misses,
      resolved: this.resolved,
      deletes: this.deletes,
      sets: this.sets,
      clears: this.clears,
      disposals: this.disposals
    };
  }
  clear() {
    this.hits = 0;
    this.misses = 0;
    this.resolved = 0;
    this.deletes = 0;
    this.sets = 0;
    ++this.clears;
  }
};
var AutoResolveCache = class {
  map = /* @__PURE__ */ new Map();
  get(k, resolve3) {
    return resolve3 ? autoResolve(this.map, k, resolve3) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
  delete(k) {
    return this.map.delete(k);
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.clear();
  }
};
function createAutoResolveCache() {
  return new AutoResolveCache();
}
function autoResolveWeak2(map3, key, resolve3) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve3(key);
  map3.set(key, value);
  return value;
}
var AutoResolveWeakCache2 = class {
  _map = /* @__PURE__ */ new WeakMap();
  _stats = new CacheStatsTracker();
  get(k, resolve3) {
    const map3 = this._map;
    const found = map3.get(k);
    if (found !== void 0 || map3.has(k)) {
      ++this._stats.hits;
      return found;
    }
    ++this._stats.misses;
    if (!resolve3) {
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve3(k);
    map3.set(k, value);
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return this._map.has(k);
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, v);
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakCache2() {
  return new AutoResolveWeakCache2();
}
var AutoResolveWeakWeakCache = class {
  _map = /* @__PURE__ */ new WeakMap();
  _stats = new CacheStatsTracker();
  get(k, resolve3) {
    const map3 = this._map;
    const found = map3.get(k);
    const foundValue = found == null ? void 0 : found.deref();
    if (found !== void 0 && foundValue) {
      ++this._stats.hits;
      return foundValue;
    }
    ++this._stats.misses;
    if (!resolve3) {
      if (found) {
        map3.delete(k);
      }
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve3(k);
    map3.set(k, new WeakRef(value));
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    var _a3;
    return !!((_a3 = this._map.get(k)) == null ? void 0 : _a3.deref());
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, new WeakRef(v));
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakWeakCache() {
  return new AutoResolveWeakWeakCache();
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var import_node_module2 = require("module");
var os2 = __toESM(require("os"), 1);
var path5 = __toESM(require("path"), 1);
var import_node_url11 = require("url");
var import_node_url12 = require("url");

// node_modules/.pnpm/global-directory@4.0.1/node_modules/global-directory/index.js
var import_node_process = __toESM(require("process"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_node_os2 = __toESM(require("os"), 1);
var import_node_fs = __toESM(require("fs"), 1);
var import_ini = __toESM(require_ini(), 1);
var isWindows = import_node_process.default.platform === "win32";
var readRc = (filePath) => {
  try {
    return import_ini.default.parse(import_node_fs.default.readFileSync(filePath, "utf8")).prefix;
  } catch {
  }
};
var getEnvNpmPrefix = () => Object.keys(import_node_process.default.env).reduce((prefix, name) => /^npm_config_prefix$/i.test(name) ? import_node_process.default.env[name] : prefix, void 0);
var getGlobalNpmrc = () => {
  if (isWindows && import_node_process.default.env.APPDATA) {
    return import_node_path.default.join(import_node_process.default.env.APPDATA, "/npm/etc/npmrc");
  }
  if (import_node_process.default.execPath.includes("/Cellar/node")) {
    const homebrewPrefix = import_node_process.default.execPath.slice(0, import_node_process.default.execPath.indexOf("/Cellar/node"));
    return import_node_path.default.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
  }
  if (import_node_process.default.execPath.endsWith("/bin/node")) {
    const installDir = import_node_path.default.dirname(import_node_path.default.dirname(import_node_process.default.execPath));
    return import_node_path.default.join(installDir, "/etc/npmrc");
  }
};
var getDefaultNpmPrefix = () => {
  if (isWindows) {
    const { APPDATA } = import_node_process.default.env;
    return APPDATA ? import_node_path.default.join(APPDATA, "npm") : import_node_path.default.dirname(import_node_process.default.execPath);
  }
  return import_node_path.default.dirname(import_node_path.default.dirname(import_node_process.default.execPath));
};
var getNpmPrefix = () => {
  const envPrefix = getEnvNpmPrefix();
  if (envPrefix) {
    return envPrefix;
  }
  const homePrefix = readRc(import_node_path.default.join(import_node_os2.default.homedir(), ".npmrc"));
  if (homePrefix) {
    return homePrefix;
  }
  if (import_node_process.default.env.PREFIX) {
    return import_node_process.default.env.PREFIX;
  }
  const globalPrefix = readRc(getGlobalNpmrc());
  if (globalPrefix) {
    return globalPrefix;
  }
  return getDefaultNpmPrefix();
};
var npmPrefix = import_node_path.default.resolve(getNpmPrefix());
var getYarnWindowsDirectory = () => {
  if (isWindows && import_node_process.default.env.LOCALAPPDATA) {
    const dir = import_node_path.default.join(import_node_process.default.env.LOCALAPPDATA, "Yarn");
    if (import_node_fs.default.existsSync(dir)) {
      return dir;
    }
  }
  return false;
};
var getYarnPrefix = () => {
  if (import_node_process.default.env.PREFIX) {
    return import_node_process.default.env.PREFIX;
  }
  const windowsPrefix = getYarnWindowsDirectory();
  if (windowsPrefix) {
    return windowsPrefix;
  }
  const configPrefix = import_node_path.default.join(import_node_os2.default.homedir(), ".config/yarn");
  if (import_node_fs.default.existsSync(configPrefix)) {
    return configPrefix;
  }
  const homePrefix = import_node_path.default.join(import_node_os2.default.homedir(), ".yarn-config");
  if (import_node_fs.default.existsSync(homePrefix)) {
    return homePrefix;
  }
  return npmPrefix;
};
var globalDirectory = {};
globalDirectory.npm = {};
globalDirectory.npm.prefix = npmPrefix;
globalDirectory.npm.packages = import_node_path.default.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
globalDirectory.npm.binaries = isWindows ? npmPrefix : import_node_path.default.join(npmPrefix, "bin");
var yarnPrefix = import_node_path.default.resolve(getYarnPrefix());
globalDirectory.yarn = {};
globalDirectory.yarn.prefix = yarnPrefix;
globalDirectory.yarn.packages = import_node_path.default.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
globalDirectory.yarn.binaries = import_node_path.default.join(globalDirectory.yarn.packages, ".bin");
var global_directory_default = globalDirectory;

// node_modules/.pnpm/@cspell+cspell-resolver@8.14.2/node_modules/@cspell/cspell-resolver/dist/resolveGlobal.mjs
var import_requireResolve = __toESM(require_requireResolve(), 1);
function resolveGlobal(modulesName) {
  const paths = [global_directory_default.npm.packages, global_directory_default.yarn.packages];
  return (0, import_requireResolve.requireResolve)(modulesName, paths);
}

// node_modules/.pnpm/@cspell+dynamic-import@8.14.2/node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var import_node_fs4 = require("fs");
var import_node_path4 = require("path");
var import_node_url5 = require("url");

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/resolve.js
var import_node_assert5 = __toESM(require("assert"), 1);
var import_node_fs3 = require("fs");
var import_node_process2 = __toESM(require("process"), 1);
var import_node_url4 = require("url");
var import_node_path3 = __toESM(require("path"), 1);
var import_node_module = require("module");

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/get-format.js
var import_node_url3 = require("url");

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/package-json-reader.js
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path2 = __toESM(require("path"), 1);
var import_node_url2 = require("url");

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/errors.js
var import_node_v8 = __toESM(require("v8"), 1);
var import_node_assert4 = __toESM(require("assert"), 1);
var import_node_util2 = require("util");
var own = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var codes2 = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes2.ERR_INVALID_ARG_TYPE = createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    (0, import_node_assert4.default)(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      (0, import_node_assert4.default)(
        typeof value === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        (0, import_node_assert4.default)(
          value !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
        types,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
codes2.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
codes2.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path13, base, message) => {
    return `Invalid package config ${path13}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
codes2.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (packagePath, key, target, isImport = false, base = void 0) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      (0, import_node_assert4.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes2.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path13, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path13}' imported from ${base}`;
  },
  Error
);
codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes2.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
codes2.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} extension
   * @param {string} path
   */
  (extension, path13) => {
    return `Unknown file extension "${extension}" for ${path13}`;
  },
  TypeError
);
codes2.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value, reason = "is invalid") => {
    let inspected = (0, import_node_util2.inspect)(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
    return error;
  }
);
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  (0, import_node_assert4.default)(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert4.default)(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  (0, import_node_assert4.default)(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(import_node_util2.format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${(0, import_node_util2.inspect)(value, { depth: -1 })}`;
  }
  let inspected = (0, import_node_util2.inspect)(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/package-json-reader.js
var hasOwnProperty2 = {}.hasOwnProperty;
var { ERR_INVALID_PACKAGE_CONFIG } = codes2;
var cache2 = /* @__PURE__ */ new Map();
function read(jsonPath, { base, specifier }) {
  const existing = cache2.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = import_node_fs2.default.readFileSync(import_node_path2.default.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      );
      const error = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + (0, import_node_url2.fileURLToPath)(base || specifier),
        cause.message
      );
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty2.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty2.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty2.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty2.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty2.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache2.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read((0, import_node_url2.fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = (0, import_node_url2.fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url2) {
  return getPackageScopeConfig(url2).type;
}

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/get-format.js
var { ERR_UNKNOWN_FILE_EXTENSION } = codes2;
var hasOwnProperty3 = {}.hasOwnProperty;
var extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json") return "json";
  return null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url2) {
  const pathname = url2.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url2, _context, ignoreErrors) {
  const value = extname(url2);
  if (value === ".js") {
    const packageType = getPackageType(url2);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url2);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format3 = extensionFormatMap[value];
  if (format3) return format3;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = (0, import_node_url3.fileURLToPath)(url2);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url2, context) {
  const protocol = url2.protocol;
  if (!hasOwnProperty3.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url2, context, true) || null;
}

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/utils.js
var { ERR_INVALID_ARG_VALUE } = codes2;
var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/lib/resolve.js
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST
} = codes2;
var own2 = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSeparatorRegEx = /%2f|%5c/i;
var emittedPackageWarnings = /* @__PURE__ */ new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match2, packageJsonUrl, internal, base, isTarget) {
  if (import_node_process2.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url4.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process2.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match2 ? "" : `matched to "${match2}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url4.fileURLToPath)(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url2, packageJsonUrl, base, main) {
  if (import_node_process2.default.noDeprecation) {
    return;
  }
  const format3 = defaultGetFormatWithoutErrors(url2, { parentURL: base.href });
  if (format3 !== "module") return;
  const urlPath = (0, import_node_url4.fileURLToPath)(url2.href);
  const packagePath = (0, import_node_url4.fileURLToPath)(new import_node_url4.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url4.fileURLToPath)(base);
  if (!main) {
    import_node_process2.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (import_node_path3.default.resolve(packagePath, main) !== urlPath) {
    import_node_process2.default.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path13) {
  try {
    return (0, import_node_fs3.statSync)(path13);
  } catch {
  }
}
function fileExists(url2) {
  const stats2 = (0, import_node_fs3.statSync)(url2, { throwIfNoEntry: false });
  const isFile = stats2 ? stats2.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url4.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new import_node_url4.URL(tries2[i2], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new import_node_url4.URL(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url4.fileURLToPath)(new import_node_url4.URL(".", packageJsonUrl)),
    (0, import_node_url4.fileURLToPath)(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url4.fileURLToPath)(base)
    );
  }
  let filePath;
  try {
    filePath = (0, import_node_url4.fileURLToPath)(resolved);
  } catch (error) {
    const cause = (
      /** @type {ErrnoException} */
      error
    );
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base) });
    throw cause;
  }
  const stats2 = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats2 && stats2.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url4.fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats2 || !stats2.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && (0, import_node_url4.fileURLToPath)(base),
      true
    );
    error.url = String(resolved);
    throw error;
  }
  if (!preserveSymlinks) {
    const real = (0, import_node_fs3.realpathSync)(filePath);
    const { search, hash } = resolved;
    resolved = (0, import_node_url4.pathToFileURL)(real + (filePath.endsWith(import_node_path3.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url4.fileURLToPath)(new import_node_url4.URL(".", packageJsonUrl)),
    (0, import_node_url4.fileURLToPath)(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url4.fileURLToPath)(new import_node_url4.URL(".", packageJsonUrl)),
    subpath,
    base && (0, import_node_url4.fileURLToPath)(base)
  );
}
function throwInvalidSubpath(request, match2, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match2}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, import_node_url4.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && (0, import_node_url4.fileURLToPath)(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url4.fileURLToPath)(new import_node_url4.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && (0, import_node_url4.fileURLToPath)(base)
  );
}
function resolvePackageTargetString(target, subpath, match2, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL3 = false;
      try {
        new import_node_url4.URL(target);
        isURL3 = true;
      } catch {
      }
      if (!isURL3) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new import_node_url4.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url4.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match2, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new import_node_url4.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url4.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys3 = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys3.length) {
      const key = keys3[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          (0, import_node_url4.fileURLToPath)(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys3.length) {
      const key = keys3[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
  if (typeof exports2 === "string" || Array.isArray(exports2)) return true;
  if (typeof exports2 !== "object" || exports2 === null) return false;
  const keys3 = Object.getOwnPropertyNames(exports2);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys3.length) {
    const key = keys3[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        (0, import_node_url4.fileURLToPath)(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match2, pjsonUrl, base) {
  if (import_node_process2.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url4.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match2)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match2);
  import_node_process2.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match2}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url4.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports2 = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
    exports2 = { ".": exports2 };
  }
  if (own2.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports2[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys3 = Object.getOwnPropertyNames(exports2);
  let i = -1;
  while (++i < keys3.length) {
    const key = keys3[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports2[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, import_node_url4.fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url4.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys3 = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys3.length) {
          const key = keys3[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName2 = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName2) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url4.fileURLToPath)(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName: packageName2, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (import_node_module.builtinModules.includes(specifier)) {
    return new import_node_url4.URL("node:" + specifier);
  }
  const { packageName: packageName2, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url4.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName2 && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url4.URL(
    "./node_modules/" + packageName2 + "/package.json",
    base
  );
  let packageJsonPath = (0, import_node_url4.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat2 = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat2 || !stat2.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url4.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName2 + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url4.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new import_node_url4.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName2, (0, import_node_url4.fileURLToPath)(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new import_node_url4.URL(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new import_node_url4.URL(specifier);
    } catch (error_) {
      if (isRemote && !import_node_module.builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  (0, import_node_assert5.default)(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === "http:" || parentProtocol === "https:") {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed == null ? void 0 : parsed.protocol;
        if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:") {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(
            specifier,
            parsedParentURL,
            "remote imports cannot import from a local location."
          );
        }
        return { url: (parsed == null ? void 0 : parsed.href) || "" };
      }
      if (import_node_module.builtinModules.includes(specifier)) {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(
          specifier,
          parsedParentURL,
          "remote imports cannot import from a local location."
        );
      }
      throw new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "only relative and absolute specifiers are supported."
      );
    }
  }
}
function isURL(self) {
  return Boolean(
    self && typeof self === "object" && "href" in self && typeof self.href === "string" && "protocol" in self && typeof self.protocol === "string" && self.href && self.protocol
  );
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL === void 0) {
    return;
  }
  if (typeof parentURL !== "string" && !isURL(parentURL)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(
      "parentURL",
      ["string", "URL"],
      parentURL
    );
  }
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  (0, import_node_assert5.default)(parentURL !== void 0, "expected `parentURL` to be defined");
  throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new import_node_url4.URL(parentURL);
    } catch {
    }
  }
  let parsed;
  let protocol;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new import_node_url4.URL(specifier, parsedParentURL) : new import_node_url4.URL(specifier);
    protocol = parsed.protocol;
    if (protocol === "data:") {
      return { url: parsed.href, format: null };
    }
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn) return maybeReturn;
  if (protocol === void 0 && parsed) {
    protocol = parsed.protocol;
  }
  if (protocol === "node:") {
    return { url: specifier };
  }
  if (parsed && parsed.protocol === "node:") return { url: specifier };
  const conditions = getConditionsSet(context.conditions);
  const url2 = moduleResolve(specifier, new import_node_url4.URL(parentURL), conditions, false);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url2.href,
    format: defaultGetFormatWithoutErrors(url2, { parentURL })
  };
}

// node_modules/.pnpm/import-meta-resolve@4.1.0/node_modules/import-meta-resolve/index.js
function resolve(specifier, parent) {
  if (!parent) {
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  }
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url === "string") {
      return exception.url;
    }
    throw error;
  }
}

// node_modules/.pnpm/@cspell+dynamic-import@8.14.2/node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var isWindowsPath = /^[a-z]:\\/i;
function importResolveModuleName(moduleName, paths) {
  const modulesNameToImport = normalizeModuleName(moduleName);
  let lastError = void 0;
  for (const parent of paths) {
    try {
      const url2 = typeof parent === "string" ? parent.startsWith("file://") ? new URL(parent) : (0, import_node_url5.pathToFileURL)(parent + import_node_path4.sep) : parent;
      const resolvedURL = new URL(resolve(modulesNameToImport.toString(), url2.toString()));
      try {
        const s = (0, import_node_fs4.statSync)(resolvedURL);
        if (s.isFile()) {
          return resolvedURL;
        }
      } catch {
        const error = new Error(`Cannot find module ${moduleName}`);
        error.code = "ERR_MODULE_NOT_FOUND";
        lastError = error;
      }
    } catch (err) {
      lastError = err;
    }
  }
  throw lastError;
}
function normalizeModuleName(moduleName) {
  return typeof moduleName === "string" && isWindowsPath.test(moduleName) ? (0, import_node_url5.pathToFileURL)(moduleName) : moduleName;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var import_resolve_from = __toESM(require_resolve_from(), 1);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/async/asyncIterable.js
async function toArray(asyncIterable) {
  const data = [];
  for await (const item of asyncIterable) {
    data.push(item);
  }
  return data;
}

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/url.mjs
var isURLRegEx = /^(\w[\w-]{1,63}:\/|data:|stdin:)/i;
function toURL(url2, relativeTo) {
  return normalizeWindowsUrl(url2 instanceof URL ? url2 : new URL(url2, relativeTo));
}
function urlParent(url2) {
  url2 = toURL(url2);
  if (url2.protocol === "data:") {
    return url2;
  }
  const hasTrailingSlash = url2.pathname.endsWith("/");
  if (!url2.pathname.startsWith("/")) {
    const parts = url2.pathname.split("/").slice(0, hasTrailingSlash ? -2 : -1);
    let pathname = parts.join("/");
    pathname = pathname && pathname + "/" || "";
    return new URL(url2.protocol + (url2.host ? "//" + url2.host : "") + pathname + url2.search + url2.hash);
  }
  return new URL(hasTrailingSlash ? ".." : ".", url2);
}
function basenameOfUrlPathname(path13) {
  const adj = path13.endsWith("/") ? 2 : 0;
  const idx2 = path13.lastIndexOf("/", path13.length - adj);
  return idx2 >= 0 ? path13.slice(idx2 + 1) : path13;
}
function isUrlLike(filename) {
  return filename instanceof URL || isURLRegEx.test(filename);
}
function hasProtocol(url2, protocol) {
  protocol = protocol.endsWith(":") ? protocol : protocol + ":";
  return typeof url2 === "string" ? url2.startsWith(protocol) : url2.protocol === protocol;
}
function addTrailingSlash(url2) {
  if (url2.pathname.endsWith("/"))
    return url2;
  const urlWithSlash = new URL(url2.href);
  urlWithSlash.pathname += "/";
  return urlWithSlash;
}
function urlToUrlRelative(urlFrom, urlTo) {
  let pFrom = urlFrom.pathname;
  const pTo = urlTo.pathname;
  if (pFrom === pTo)
    return "";
  pFrom = pFrom.endsWith("/") ? pFrom : new URL("./", urlFrom).pathname;
  if (pTo.startsWith(pFrom))
    return decodeURIComponent(pTo.slice(pFrom.length));
  const p0 = pFrom;
  const p1 = pTo;
  if (p1.startsWith(p0)) {
    return decodeURIComponent(p0 === p1 ? "" : p1.slice(p0.lastIndexOf("/") + 1));
  }
  const p0Parts = p0.split("/").slice(0, -1);
  const p1Parts = p1.split("/");
  let i = 0;
  for (i = 0; i < p0Parts.length && i < p1Parts.length - 1 && p0Parts[i] === p1Parts[i]; ++i) {
  }
  const rel = "../".repeat(p0Parts.length - i) + p1Parts.slice(i).join("/");
  return decodeURIComponent(rel.length < p1.length ? rel : p1);
}
var regExpWindowsPath = /^[\\/]([a-zA-Z]:[\\/])/;
var regExpEncodedColon = /%3[aA]/g;
function normalizeWindowsUrl(url2) {
  url2 = typeof url2 === "string" ? new URL(url2) : url2;
  if (url2.protocol === "file:") {
    const pathname = url2.pathname.replaceAll(regExpEncodedColon, ":").replace(regExpWindowsPath, (d) => d.toUpperCase());
    if (pathname !== url2.pathname) {
      url2 = new URL(url2);
      url2.pathname = pathname;
      return url2;
    }
  }
  return url2;
}

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/dataUrl.mjs
var regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url2) {
  function guessDataUrlName(header) {
    const filenameMatch = header.match(regMatchFilename);
    if (filenameMatch)
      return filenameMatch[1];
    const mime = header.split(";", 1)[0];
    return mime.replaceAll(/\W/g, ".");
  }
  url2 = toURL(url2);
  if (url2.protocol === "data:") {
    return guessDataUrlName(url2.pathname.split(",", 1)[0]);
  }
  return basenameOfUrlPathname(url2.pathname);
}
function isDataURL(url2) {
  return hasProtocol(url2, "data:");
}

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/FileUrlBuilder.mjs
var import_node_assert6 = __toESM(require("assert"), 1);
var import_node_path5 = __toESM(require("path"), 1);
var import_node_url7 = require("url");

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/fileUrl.mjs
var import_node_url6 = require("url");
function isFileURL(url2) {
  return hasProtocol(url2, "file:");
}
function toFilePathOrHref(url2) {
  return isFileURL(url2) ? toFilePath(url2) : url2.toString();
}
function toFilePath(url2) {
  return pathWindowsDriveLetterToUpper((0, import_node_url6.fileURLToPath)(url2));
}
var regExpWindowsPathDriveLetter = /^([a-zA-Z]):[\\/]/;
function pathWindowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter, (s) => s.toUpperCase());
}

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/FileUrlBuilder.mjs
var isWindows2 = process.platform === "win32";
var isWindowsPathRegEx = regExpWindowsPathDriveLetter;
var isWindowsPathname = regExpWindowsPath;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
var questionRegex = /\?/g;
var hashRegex = /#/g;
var ProtocolFile = "file:";
var _FileUrlBuilder_instances, toFileURL_fn, urlToFilePathOrHref_fn, getFsRootURL_fn;
var FileUrlBuilder = class {
  constructor(options = {}) {
    __privateAdd(this, _FileUrlBuilder_instances);
    __publicField(this, "windows");
    __publicField(this, "path");
    __publicField(this, "cwd");
    var _a3, _b, _c, _d;
    const sep3 = (_a3 = options.path) == null ? void 0 : _a3.sep;
    this.windows = options.windows ?? (sep3 ? sep3 === "\\" : void 0) ?? isWindows2;
    this.path = options.path ?? (this.windows ? import_node_path5.default.win32 : import_node_path5.default.posix);
    this.cwd = options.cwd ?? this.pathToFileURL(this.path.resolve() + "/", this.rootFileURL());
    (0, import_node_assert6.default)(this.path.sep === (this.windows ? "\\" : "/"), `Path separator should match OS type Windows: ${this.windows === true ? "true" : (this.windows ?? "undefined") || "false"}, sep: ${this.path.sep}, options: ` + JSON.stringify({
      isWindows: isWindows2,
      sep: `${sep3}`,
      windows: options.windows,
      pathSep: (_b = options.path) == null ? void 0 : _b.sep,
      n: (_c = options.path) == null ? void 0 : _c.normalize("path/file.txt"),
      cwd: (_d = options.cwd) == null ? void 0 : _d.href,
      win32: this.path === import_node_path5.default.win32,
      posix: this.path === import_node_path5.default.posix,
      "win32.normalize": this.path.normalize === import_node_path5.default.win32.normalize,
      "posix.normalize": this.path.normalize === import_node_path5.default.posix.normalize
    }));
  }
  /**
   * Encode special characters in a file path to use in a URL.
   * @param filepath
   * @returns
   */
  encodePathChars(filepath) {
    filepath = filepath.replaceAll(percentRegEx, "%25");
    if (!this.windows && !isWindows2 && filepath.includes("\\")) {
      filepath = filepath.replaceAll(backslashRegEx, "%5C");
    }
    filepath = filepath.replaceAll(newlineRegEx, "%0A");
    filepath = filepath.replaceAll(carriageReturnRegEx, "%0D");
    filepath = filepath.replaceAll(tabRegEx, "%09");
    return filepath;
  }
  /**
   * Normalize a file path for use in a URL.
   * ```js
   * const url = new URL(normalizeFilePathForUrl('path\\to\\file.txt'), 'file:///Users/user/');
   * // Result: file:///Users/user/path/to/file.txt
   * ```
   * @param filePath
   * @returns a normalized file path for use as a relative path in a URL.
   */
  normalizeFilePathForUrl(filePath) {
    filePath = this.encodePathChars(filePath);
    filePath = filePath.replaceAll(questionRegex, "%3F");
    filePath = filePath.replaceAll(hashRegex, "%23");
    const pathname = filePath.replaceAll("\\", "/");
    return pathname.replace(isWindowsPathRegEx, (drive) => `/${drive}`.toUpperCase());
  }
  /**
   * Try to make a file URL.
   * - if filenameOrUrl is already a URL, it is returned as is.
   * @param filenameOrUrl
   * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
   * @returns a URL
   */
  toFileURL(filenameOrUrl, relativeTo) {
    return normalizeWindowsUrl(__privateMethod(this, _FileUrlBuilder_instances, toFileURL_fn).call(this, filenameOrUrl, relativeTo));
  }
  /**
   * Try to make a URL for a directory.
   * - if dirOrUrl is already a URL, a slash is appended to the pathname.
   * @param dirOrUrl - directory path to convert to a file URL.
   * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
   * @returns a URL
   */
  toFileDirURL(dirOrUrl, relativeTo) {
    return addTrailingSlash(this.toFileURL(dirOrUrl, relativeTo));
  }
  urlToFilePathOrHref(url2) {
    url2 = this.toFileURL(url2);
    return __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, url2);
  }
  /**
   * Calculate the relative path to go from `urlFrom` to `urlTo`.
   * The protocol is not evaluated. Only the `url.pathname` is used.
   * The result: `new URL(relative(urlFrom, urlTo), urlFrom).pathname === urlTo.pathname`
   * @param urlFrom
   * @param urlTo
   * @returns the relative path
   */
  relative(urlFrom, urlTo) {
    if (urlFrom.protocol === urlTo.protocol && urlFrom.protocol === ProtocolFile) {
      if (urlFrom.href === urlTo.href)
        return "";
      urlFrom = urlFrom.pathname.endsWith("/") ? urlFrom : new URL("./", urlFrom);
      const fromPath = urlFrom.pathname;
      const toPath = urlTo.pathname;
      if (toPath.startsWith(fromPath))
        return decodeURIComponent(toPath.slice(fromPath.length));
      const pFrom = __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, urlFrom);
      const pTo = __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, urlTo);
      const toIsDir = urlTo.pathname.endsWith("/");
      let pathname = this.normalizeFilePathForUrl(this.path.relative(pFrom, pTo));
      if (toIsDir && !pathname.endsWith("/"))
        pathname += "/";
      return decodeURIComponent(pathname);
    }
    return decodeURIComponent(urlToUrlRelative(urlFrom, urlTo));
  }
  /**
   * Get the parent directory of a URL.
   * @param url
   */
  urlDirname(url2) {
    return urlParent(this.toFileURL(url2));
  }
  pathToFileURL(pathname, relativeToURL) {
    return new URL(this.normalizeFilePathForUrl(pathname), relativeToURL || this.cwd);
  }
  rootFileURL(filePath) {
    const path13 = this.path;
    const p = path13.parse(path13.normalize(path13.resolve(filePath ?? ".")));
    return new URL(this.normalizeFilePathForUrl(p.root), __privateMethod(this, _FileUrlBuilder_instances, getFsRootURL_fn).call(this));
  }
  /**
   * Determine if a filePath is absolute.
   *
   * @param filePath
   * @returns true if `URL` or `path.isAbsolute(filePath)`
   */
  isAbsolute(filePath) {
    return isUrlLike(filePath) || this.path.isAbsolute(filePath);
  }
  isUrlLike(url2) {
    return isUrlLike(url2);
  }
};
_FileUrlBuilder_instances = new WeakSet();
/**
 * Try to make a file URL.
 * - if filenameOrUrl is already a URL, it is returned as is.
 * @param filenameOrUrl
 * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
 * @returns a URL
 */
toFileURL_fn = function(filenameOrUrl, relativeTo) {
  if (typeof filenameOrUrl !== "string")
    return filenameOrUrl;
  if (isUrlLike(filenameOrUrl))
    return new URL(filenameOrUrl);
  relativeTo ?? (relativeTo = this.cwd);
  isWindows2 && (filenameOrUrl = filenameOrUrl.replaceAll("\\", "/"));
  if (isUrlLike(relativeTo)) {
    const pathname2 = this.normalizeFilePathForUrl(filenameOrUrl);
    return new URL(pathname2, relativeTo);
  }
  const appendSlash = filenameOrUrl.endsWith("/") ? "/" : "";
  const pathname = this.normalizeFilePathForUrl(this.path.resolve(relativeTo.toString(), filenameOrUrl)) + appendSlash;
  return this.pathToFileURL(pathname, this.cwd);
};
urlToFilePathOrHref_fn = function(url2) {
  if (url2.protocol !== ProtocolFile)
    return url2.href;
  const p = this.path === import_node_path5.default ? toFilePathOrHref(url2) : decodeURIComponent(url2.pathname.split("/").join(this.path.sep));
  return pathWindowsDriveLetterToUpper(p.replace(isWindowsPathname, "$1"));
};
getFsRootURL_fn = function() {
  if (this.path === import_node_path5.default)
    return (0, import_node_url7.pathToFileURL)("/");
  const p = this.path.resolve("/");
  return new URL(this.normalizeFilePathForUrl(p), "file:///");
};

// node_modules/.pnpm/@cspell+url@8.14.2/node_modules/@cspell/url/dist/defaultFileUrlBuilder.mjs
var fileUrlBuilder = new FileUrlBuilder();
function toFileURL(filenameOrUrl, relativeTo) {
  return fileUrlBuilder.toFileURL(filenameOrUrl, relativeTo);
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/CFileReference.js
var CFileReference = class _CFileReference {
  url;
  encoding;
  baseFilename;
  /**
   * Use to ensure the nominal type separation between CFileReference and FileReference
   * See: https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal
   */
  _;
  gz;
  constructor(url2, encoding, baseFilename, gz) {
    this.url = url2;
    this.encoding = encoding;
    this.baseFilename = baseFilename;
    this.gz = gz ?? ((baseFilename == null ? void 0 : baseFilename.endsWith(".gz")) || void 0) ?? (url2.pathname.endsWith(".gz") || void 0);
  }
  static isCFileReference(obj) {
    return obj instanceof _CFileReference;
  }
  static from(fileReference, encoding, baseFilename, gz) {
    if (_CFileReference.isCFileReference(fileReference))
      return fileReference;
    if (fileReference instanceof URL)
      return new _CFileReference(fileReference, encoding, baseFilename, gz);
    return new _CFileReference(fileReference.url, fileReference.encoding, fileReference.baseFilename, fileReference.gz);
  }
  toJson() {
    return {
      url: this.url.href,
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
};
function toFileReference(file, encoding, baseFilename, gz) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL)
    return new CFileReference(fileReference, encoding, baseFilename, gz);
  return CFileReference.from(fileReference);
}
function isFileReference(ref) {
  return CFileReference.isCFileReference(ref) || !(ref instanceof URL) && typeof ref !== "string";
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/errors/errors.js
var ErrorNotImplemented = class extends Error {
  method;
  constructor(method, options) {
    super(`Method ${method} is not supported.`, options);
    this.method = method;
  }
};
var AssertionError = class extends Error {
  message;
  constructor(message, options) {
    super(message, options);
    this.message = message;
  }
};

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/errors/assert.js
function assert7(value, message) {
  if (!value) {
    throw new AssertionError(message ?? "Assertion failed");
  }
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/encode-decode.js
var import_node_zlib = require("zlib");

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/arrayBuffers.js
function asUint8Array(data) {
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
function arrayBufferViewToBuffer(data) {
  if (data instanceof Buffer) {
    return data;
  }
  const buf = Buffer.from(data.buffer);
  if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
    return buf;
  }
  return buf.subarray(data.byteOffset, data.byteOffset + data.byteLength);
}
function copyArrayBufferView(data) {
  return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
}
function swap16Poly(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  for (let i = 0; i < view.byteLength; i += 2) {
    view.setUint16(i, view.getUint16(i, false), true);
  }
  return data;
}
function swap16(data) {
  if (typeof Buffer !== "undefined") {
    return arrayBufferViewToBuffer(data).swap16();
  }
  return swap16Poly(data);
}
function swapBytes(data) {
  const buf = copyArrayBufferView(data);
  return swap16(buf);
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/encode-decode.js
var BOM_BE = 65279;
var BOM_LE = 65534;
var decoderUTF8 = new TextDecoder("utf8");
var decoderUTF16LE = new TextDecoder("utf-16le");
var decoderUTF16BE = createTextDecoderUtf16BE();
function decodeUtf16LE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16LE.decode(bom === BOM_LE ? buf.subarray(2) : buf);
}
function decodeUtf16BE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16BE.decode(bom === BOM_BE ? buf.subarray(2) : buf);
}
function decodeToString(data, encoding) {
  if (isGZipped(data)) {
    return decodeToString(decompressBuffer(data), encoding);
  }
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  if (bom === BOM_BE || buf[0] === 0 && buf[1] !== 0)
    return decodeUtf16BE(buf);
  if (bom === BOM_LE || buf[0] !== 0 && buf[1] === 0)
    return decodeUtf16LE(buf);
  if (!encoding)
    return decoderUTF8.decode(buf);
  switch (encoding) {
    case "utf-16be":
    case "utf16be": {
      return decodeUtf16BE(buf);
    }
    case "utf-16le":
    case "utf16le": {
      return decodeUtf16LE(buf);
    }
    case "utf-8":
    case "utf8": {
      return decoderUTF8.decode(buf);
    }
  }
  throw new UnsupportedEncodingError(encoding);
}
function decode(data, encoding) {
  switch (encoding) {
    case "base64":
    case "base64url":
    case "hex": {
      return arrayBufferViewToBuffer(data).toString(encoding);
    }
  }
  const result = decodeToString(data, encoding);
  return result;
}
function encodeString(str, encoding, bom) {
  switch (encoding) {
    case "utf-16be":
    case "utf16be": {
      return encodeUtf16BE(str, bom);
    }
    case "utf-16le":
    case "utf16le": {
      return encodeUtf16LE(str, bom);
    }
  }
  return Buffer.from(str, encoding);
}
function encodeUtf16LE(str, bom = true) {
  const buf = Buffer.from(str, "utf16le");
  if (bom) {
    const target = Buffer.alloc(buf.length + 2);
    target.writeUint16LE(BOM_BE);
    buf.copy(target, 2);
    return target;
  }
  return buf;
}
function encodeUtf16BE(str, bom = true) {
  return swap16(encodeUtf16LE(str, bom));
}
function createTextDecoderUtf16BE() {
  try {
    const decoder = new TextDecoder("utf-16be");
    return decoder;
  } catch {
    return {
      encoding: "utf-16be",
      fatal: false,
      ignoreBOM: false,
      decode: (input) => decoderUTF16LE.decode(swapBytes(input))
    };
  }
}
var UnsupportedEncodingError = class extends Error {
  constructor(encoding) {
    super(`Unsupported encoding: ${encoding}`);
  }
};
function isGZipped(data) {
  if (typeof data === "string")
    return false;
  const buf = asUint8Array(data);
  return buf[0] === 31 && buf[1] === 139;
}
function decompressBuffer(data) {
  if (!isGZipped(data))
    return data;
  const buf = arrayBufferViewToBuffer(data);
  return (0, import_node_zlib.gunzipSync)(buf);
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/CFileResource.js
var CFileResource = class _CFileResource {
  url;
  content;
  encoding;
  _text;
  baseFilename;
  _gz;
  constructor(url2, content, encoding, baseFilename, gz) {
    this.url = url2;
    this.content = content;
    this.encoding = encoding;
    this.baseFilename = baseFilename ?? (url2.protocol !== "data:" && url2.pathname.split("/").pop() || void 0);
    this._gz = gz;
  }
  get gz() {
    if (this._gz !== void 0)
      return this._gz;
    if (this.url.pathname.endsWith(".gz"))
      return true;
    if (typeof this.content === "string")
      return false;
    return isGZipped(this.content);
  }
  getText(encoding) {
    if (this._text !== void 0)
      return this._text;
    const text = typeof this.content === "string" ? this.content : decode(this.content, encoding ?? this.encoding);
    this._text = text;
    return text;
  }
  toJson() {
    return {
      url: this.url.href,
      content: this.getText(),
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
  static isCFileResource(obj) {
    return obj instanceof _CFileResource;
  }
  static from(urlOrFileResource, content, encoding, baseFilename, gz) {
    if (_CFileResource.isCFileResource(urlOrFileResource)) {
      if (content) {
        const { url: url2, encoding: encoding2, baseFilename: baseFilename2, gz: gz2 } = urlOrFileResource;
        return new _CFileResource(url2, content, encoding2, baseFilename2, gz2);
      }
      return urlOrFileResource;
    }
    if (urlOrFileResource instanceof URL) {
      assert7(content !== void 0);
      return new _CFileResource(urlOrFileResource, content, encoding, baseFilename, gz);
    }
    if (content !== void 0) {
      const fileRef = urlOrFileResource;
      return new _CFileResource(fileRef.url, content, fileRef.encoding, fileRef.baseFilename, fileRef.gz);
    }
    assert7("content" in urlOrFileResource && urlOrFileResource.content !== void 0);
    const fileResource = urlOrFileResource;
    return new _CFileResource(fileResource.url, fileResource.content, fileResource.encoding, fileResource.baseFilename, fileResource.gz);
  }
};
function fromFileResource(fileResource, encoding) {
  return CFileResource.from(encoding ? { ...fileResource, encoding } : fileResource);
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/stat.js
function compareStats(left, right) {
  if (left === right)
    return 0;
  if (left.eTag || right.eTag)
    return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
  const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/urlOrReferenceToUrl.js
function urlOrReferenceToUrl(urlOrReference) {
  return urlOrReference instanceof URL ? urlOrReference : urlOrReference.url;
}

// node_modules/.pnpm/@cspell+cspell-service-bus@8.14.2/node_modules/@cspell/cspell-service-bus/dist/esm/errors.js
var ErrorUnhandledRequest = class extends Error {
  request;
  constructor(request) {
    super(`Unhandled Request: ${request.type}`);
    this.request = request;
  }
};
var ErrorServiceRequestDepthExceeded = class extends Error {
  request;
  depth;
  constructor(request, depth) {
    super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
    this.request = request;
    this.depth = depth;
  }
};
var UnhandledHandlerError = class extends Error {
  handlerName;
  handlerDescription;
  cause;
  constructor(handlerName, handlerDescription, cause) {
    super(`Unhandled Error in Handler: ${handlerName}`);
    this.handlerName = handlerName;
    this.handlerDescription = handlerDescription;
    this.cause = cause;
  }
};

// node_modules/.pnpm/@cspell+cspell-service-bus@8.14.2/node_modules/@cspell/cspell-service-bus/dist/esm/request.js
var BaseServiceRequest = class {
  type;
  params;
  __r;
  constructor(type, params) {
    this.type = type;
    this.params = params;
  }
};
var ServiceRequestCls = class extends BaseServiceRequest {
  constructor(type, params) {
    super(type, params);
  }
};
function createResponse(value, _req) {
  return { value };
}
function createResponseFail(_request, error) {
  return { error };
}
function isServiceResponseSuccess(res) {
  return "value" in res && res.error === void 0;
}

// node_modules/.pnpm/@cspell+cspell-service-bus@8.14.2/node_modules/@cspell/cspell-service-bus/dist/esm/bus.js
var MAX_DEPTH = 10;
var ServiceBus = class {
  handlers = [];
  constructor(handlers = []) {
    handlers.forEach((h) => this.addHandler(h));
  }
  addHandler(handler, name = "anonymous", description) {
    const h = typeof handler === "function" ? { fn: handler, name, description } : handler;
    const { fn, name: _name, description: _description } = h;
    this.handlers.push({ fn, name: _name, description: _description });
    return this;
  }
  dispatch(request) {
    let depth = 0;
    const dispatcher = { dispatch };
    const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
    function dispatch(request2) {
      ++depth;
      if (depth >= MAX_DEPTH) {
        return createResponseFail(request2, new ErrorServiceRequestDepthExceeded(request2, depth));
      }
      const response = handler(request2);
      --depth;
      return response;
    }
    return dispatch(request);
  }
  defaultHandler(request) {
    return createResponseFail(request, new ErrorUnhandledRequest(request));
  }
  reduceHandlers(handlers, request, dispatcher, defaultHandler) {
    const _handlers = handlers.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
    const handler = _handlers.reduce((next, h) => {
      const fn = h.fn(next);
      return (req) => {
        try {
          return fn(req);
        } catch (e) {
          return createResponseFail(request, new UnhandledHandlerError(h.name, h.description, e));
        }
      };
    }, defaultHandler);
    return handler;
  }
};

// node_modules/.pnpm/@cspell+cspell-service-bus@8.14.2/node_modules/@cspell/cspell-service-bus/dist/esm/createRequestHandler.js
function createRequestHandler(requestDef, fn, name, description) {
  return createIsRequestHandler(requestDef.is, fn, name ?? requestDef.type, description);
}
function createIsRequestHandlerFn(isA, fn) {
  return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
}
function createIsRequestHandler(isA, fn, name, description) {
  return {
    fn: createIsRequestHandlerFn(isA, fn),
    name,
    description
  };
}

// node_modules/.pnpm/@cspell+cspell-service-bus@8.14.2/node_modules/@cspell/cspell-service-bus/dist/esm/requestFactory.js
function requestFactory(requestType) {
  class RequestClass extends ServiceRequestCls {
    static type = requestType;
    constructor(params) {
      super(requestType, params);
    }
    static is(req) {
      return req instanceof RequestClass && req.type === requestType;
    }
    static create(params) {
      return new RequestClass(params);
    }
    static createRequestHandler(fn, name, description) {
      return createRequestHandler(RequestClass, fn, name, description);
    }
    static __request;
  }
  return RequestClass;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/handlers/node/file.js
var import_node_fs5 = require("fs");
var import_node_url8 = require("url");
var import_node_util3 = require("util");
var import_node_zlib2 = require("zlib");

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/errors/error.js
function toError2(e) {
  if (e instanceof Error)
    return e;
  if (typeof e === "object" && e && "message" in e && typeof e.message === "string") {
    return new Error(e.message, { cause: e });
  }
  return new Error(e && e.toString());
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/models/Stats.js
var FileType;
(function(FileType2) {
  FileType2[FileType2["Unknown"] = 0] = "Unknown";
  FileType2[FileType2["File"] = 1] = "File";
  FileType2[FileType2["Directory"] = 2] = "Directory";
  FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}));

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/dataUrl.js
function encodeDataUrl(data, mediaType, attributes) {
  if (typeof data === "string")
    return encodeString2(data, mediaType, attributes);
  const attribs = encodeAttributes(attributes || []);
  const buf = arrayBufferViewToBuffer(data);
  return `data:${mediaType}${attribs};base64,${buf.toString("base64url")}`;
}
function toDataUrl(data, mediaType, attributes) {
  return new URL(encodeDataUrl(data, mediaType, attributes));
}
function encodeString2(data, mediaType, attributes) {
  mediaType = mediaType || "text/plain";
  attributes = attributes || [];
  const asUrlComp = encodeURIComponent(data);
  const asBase64 = Buffer.from(data).toString("base64url");
  const useBase64 = asBase64.length < asUrlComp.length - 7;
  const encoded = useBase64 ? asBase64 : asUrlComp;
  const attribMap = new Map([["charset", "utf-8"], ...attributes]);
  attribMap.set("charset", "utf-8");
  const attribs = encodeAttributes(attribMap);
  return `data:${mediaType}${attribs}${useBase64 ? ";base64" : ""},${encoded}`;
}
function encodeAttributes(attributes) {
  return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join("");
}
var dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url2) {
  url2 = url2.toString();
  const [head, encodedData] = url2.split(",", 2);
  if (!head || encodedData === void 0)
    throw new Error("Not a data url");
  const match2 = head.match(dataUrlRegExHead);
  if (!match2 || !match2.groups)
    throw new Error("Not a data url");
  const mediaType = match2.groups["mediaType"] || "";
  const rawAttributes = (match2.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
  const attributes = new Map(rawAttributes);
  const encoding = attributes.get("charset");
  const isBase64 = !!match2.groups["base64"];
  const data = isBase64 ? Buffer.from(encodedData, "base64url") : Buffer.from(decodeURIComponent(encodedData));
  return { mediaType, data, encoding, attributes };
}
function guessMimeType(filename) {
  if (filename.endsWith(".trie"))
    return { mimeType: "application/vnd.cspell.dictionary+trie", encoding: "utf-8" };
  if (filename.endsWith(".trie.gz"))
    return { mimeType: "application/vnd.cspell.dictionary+trie.gz" };
  if (filename.endsWith(".txt"))
    return { mimeType: "text/plain", encoding: "utf-8" };
  if (filename.endsWith(".txt.gz"))
    return { mimeType: "application/gzip" };
  if (filename.endsWith(".gz"))
    return { mimeType: "application/gzip" };
  if (filename.endsWith(".json"))
    return { mimeType: "application/json", encoding: "utf-8" };
  if (filename.endsWith(".yaml") || filename.endsWith(".yml"))
    return { mimeType: "application/x-yaml", encoding: "utf-8" };
  return void 0;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/_fetch.js
var _fetch = global.fetch;

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/FetchError.js
var FetchUrlError = class _FetchUrlError extends Error {
  code;
  status;
  url;
  constructor(message, code, status, url2) {
    super(message);
    this.code = code;
    this.status = status;
    this.url = url2;
    this.name = "FetchUrlError";
  }
  static create(url2, status, message) {
    if (status === 404)
      return new _FetchUrlError(message || "URL not found.", "ENOENT", status, url2);
    if (status >= 400 && status < 500)
      return new _FetchUrlError(message || "Permission denied.", "EACCES", status, url2);
    return new _FetchUrlError(message || "Fatal Error", "ECONNREFUSED", status, url2);
  }
  static fromError(url2, e) {
    const cause = getCause(e);
    if (cause) {
      return new _FetchUrlError(cause.message, cause.code, void 0, url2);
    }
    if (isNodeError(e)) {
      return new _FetchUrlError(e.message, e.code, void 0, url2);
    }
    return new _FetchUrlError(e.message, void 0, void 0, url2);
  }
};
function isNodeError(e) {
  if (e instanceof Error && "code" in e && typeof e.code === "string")
    return true;
  if (e && typeof e === "object" && "code" in e && typeof e.code === "string")
    return true;
  return false;
}
function isError2(e) {
  return e instanceof Error;
}
function isErrorWithOptionalCause(e) {
  return isError2(e) && (!("cause" in e) || isNodeError(e.cause) || isNodeError(e));
}
function getCause(e) {
  return isErrorWithOptionalCause(e) ? e.cause : void 0;
}
function toFetchUrlError(err, url2) {
  return err instanceof FetchUrlError ? err : FetchUrlError.fromError(url2, toError3(err));
}
function toError3(err) {
  return err instanceof Error ? err : new Error("Unknown Error", { cause: err });
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/fetch.js
async function fetchHead(request) {
  const url2 = toURL2(request);
  try {
    const r = await _fetch(url2, { method: "HEAD" });
    if (!r.ok) {
      throw FetchUrlError.create(url2, r.status);
    }
    return r.headers;
  } catch (e) {
    throw toFetchUrlError(e, url2);
  }
}
async function fetchURL(url2) {
  try {
    const response = await _fetch(url2);
    if (!response.ok) {
      throw FetchUrlError.create(url2, response.status);
    }
    return Buffer.from(await response.arrayBuffer());
  } catch (e) {
    throw toFetchUrlError(e, url2);
  }
}
function toURL2(url2) {
  return typeof url2 === "string" ? new URL(url2) : url2;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/stat.js
async function getStatHttp(url2) {
  const headers = await fetchHead(url2);
  const eTag = headers.get("etag") || void 0;
  const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
  return {
    size: eTag ? -1 : guessSize,
    mtimeMs: 0,
    eTag
  };
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestFsReadFile.js
var RequestType = "fs:readFile";
var RequestFsReadFile = requestFactory(RequestType);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestFsReadFileSync.js
var RequestType2 = "fs:readFileSync";
var RequestFsReadFileTextSync = requestFactory(RequestType2);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestFsStat.js
var RequestTypeStat = "fs:stat";
var RequestFsStat = requestFactory(RequestTypeStat);
var RequestTypeStatSync = "fs:statSync";
var RequestFsStatSync = requestFactory(RequestTypeStatSync);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestFsWriteFile.js
var RequestType3 = "fs:writeFile";
var RequestFsWriteFile = requestFactory(RequestType3);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestZlibInflate.js
var RequestType4 = "zlib:inflate";
var RequestZlibInflate = requestFactory(RequestType4);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/requests/RequestFsReadDirectory.js
var RequestType5 = "fs:readDir";
var RequestFsReadDirectory = requestFactory(RequestType5);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/handlers/node/file.js
var isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url2) {
  return isGzFileRegExp.test(typeof url2 === "string" ? url2 : url2.pathname);
}
var pGzip = (0, import_node_util3.promisify)(import_node_zlib2.gzip);
var handleRequestFsReadFile = RequestFsReadFile.createRequestHandler(({ params }) => {
  const baseFilename = urlBasename(params.url);
  return createResponse(import_node_fs5.promises.readFile((0, import_node_url8.fileURLToPath)(params.url)).then((content) => CFileResource.from(params.url, content, params.encoding, baseFilename)));
}, void 0, "Node: Read Binary File.");
var handleRequestFsReadFileSync = RequestFsReadFileTextSync.createRequestHandler(({ params }) => createResponse(CFileResource.from({ ...params, content: (0, import_node_fs5.readFileSync)((0, import_node_url8.fileURLToPath)(params.url)) })), void 0, "Node: Sync Read Binary File.");
var handleRequestFsReadDirectory = RequestFsReadDirectory.createRequestHandler(({ params }) => {
  return createResponse(import_node_fs5.promises.readdir((0, import_node_url8.fileURLToPath)(params.url), { withFileTypes: true }).then((entries) => direntToDirEntries(params.url, entries)));
}, void 0, "Node: Read Directory.");
var handleRequestZlibInflate = RequestZlibInflate.createRequestHandler(({ params }) => createResponse((0, import_node_zlib2.gunzipSync)(arrayBufferViewToBuffer(params.data))), void 0, "Node: gz deflate.");
var supportedFetchProtocols = { "http:": true, "https:": true };
var handleRequestFsReadFileHttp = RequestFsReadFile.createRequestHandler((req, next) => {
  const { url: url2 } = req.params;
  if (!(url2.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(fetchURL(url2).then((content) => CFileResource.from({ ...req.params, content })));
}, void 0, "Node: Read Http(s) file.");
var handleRequestFsReadFileSyncData = RequestFsReadFileTextSync.createRequestHandler((req, next) => {
  const { url: url2, encoding } = req.params;
  if (url2.protocol !== "data:")
    return next(req);
  const data = decodeDataUrl(url2);
  return createResponse(CFileResource.from({ url: url2, content: data.data, encoding, baseFilename: data.attributes.get("filename") }));
}, void 0, "Node: Read data: urls.");
var handleRequestFsReadFileData = RequestFsReadFile.createRequestHandler((req, next, dispatcher) => {
  const { url: url2 } = req.params;
  if (url2.protocol !== "data:")
    return next(req);
  const res = dispatcher.dispatch(RequestFsReadFileTextSync.create(req.params));
  if (!isServiceResponseSuccess(res))
    return res;
  return createResponse(Promise.resolve(res.value));
}, void 0, "Node: Read data: urls.");
var handleRequestFsStat = RequestFsStat.createRequestHandler(({ params }) => createResponse(toPromiseStats(import_node_fs5.promises.stat((0, import_node_url8.fileURLToPath)(params.url)))), void 0, "Node: fs.stat.");
function toStats(stat2) {
  return {
    size: stat2.size,
    mtimeMs: stat2.mtimeMs,
    fileType: toFileType(stat2)
  };
}
function toPromiseStats(pStat) {
  return pStat.then(toStats);
}
var handleRequestFsStatSync = RequestFsStatSync.createRequestHandler((req) => {
  const { params } = req;
  try {
    return createResponse((0, import_node_fs5.statSync)((0, import_node_url8.fileURLToPath)(params.url)));
  } catch (e) {
    return createResponseFail(req, toError2(e));
  }
}, void 0, "Node: fs.stat.");
var handleRequestFsStatHttp = RequestFsStat.createRequestHandler((req, next) => {
  const { url: url2 } = req.params;
  if (!(url2.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(getStatHttp(url2));
}, void 0, "Node: http get stat");
var handleRequestFsWriteFile = RequestFsWriteFile.createRequestHandler(({ params }) => createResponse(writeFile(params, params.content)), void 0, "Node: fs.writeFile");
async function writeFile(fileRef, content) {
  const gz = isGZipped(content);
  const { url: url2, encoding, baseFilename } = fileRef;
  const resultRef = { url: url2, encoding, baseFilename, gz };
  await import_node_fs5.promises.writeFile((0, import_node_url8.fileURLToPath)(fileRef.url), encodeContent(fileRef, content));
  return resultRef;
}
var handleRequestFsWriteFileDataUrl = RequestFsWriteFile.createRequestHandler((req, next) => {
  const fileResource = req.params;
  const { url: url2 } = req.params;
  if (url2.protocol !== "data:")
    return next(req);
  const gz = isGZipped(fileResource.content);
  const baseFilename = fileResource.baseFilename || "file.txt" + (gz ? ".gz" : "");
  const mt = guessMimeType(baseFilename);
  const mediaType = (mt == null ? void 0 : mt.mimeType) || "text/plain";
  const dataUrl = toDataUrl(fileResource.content, mediaType, [["filename", baseFilename]]);
  return createResponse(Promise.resolve({ url: dataUrl, baseFilename, gz, encoding: mt == null ? void 0 : mt.encoding }));
}, void 0, "Node: fs.writeFile DataUrl");
var handleRequestFsWriteFileGz = RequestFsWriteFile.createRequestHandler((req, next, dispatcher) => {
  const fileResource = req.params;
  if (!fileResource.gz && !isGzFile(fileResource.url) && (!fileResource.baseFilename || !isGzFile(fileResource.baseFilename))) {
    return next(req);
  }
  if (typeof fileResource.content !== "string" && isGZipped(fileResource.content)) {
    return next(req);
  }
  return createResponse(compressAndChainWriteRequest(dispatcher, fileResource, fileResource.content));
}, void 0, "Node: fs.writeFile compressed");
async function compressAndChainWriteRequest(dispatcher, fileRef, content) {
  const buf = await pGzip(encodeContent(fileRef, content));
  const res = dispatcher.dispatch(RequestFsWriteFile.create({ ...fileRef, content: buf }));
  assert7(isServiceResponseSuccess(res));
  return res.value;
}
function registerHandlers(serviceBus) {
  const handlers = [
    handleRequestFsReadFile,
    handleRequestFsReadFileSync,
    handleRequestFsWriteFile,
    handleRequestFsWriteFileDataUrl,
    handleRequestFsWriteFileGz,
    handleRequestFsReadFileHttp,
    handleRequestFsReadFileData,
    handleRequestFsReadFileSyncData,
    handleRequestFsReadDirectory,
    handleRequestZlibInflate,
    handleRequestFsStatSync,
    handleRequestFsStat,
    handleRequestFsStatHttp
  ];
  handlers.forEach((handler) => serviceBus.addHandler(handler));
}
function encodeContent(ref, content) {
  if (typeof content === "string") {
    if ([void 0, "utf8", "utf-8"].includes(ref.encoding))
      return content;
    return arrayBufferViewToBuffer(encodeString(content, ref.encoding));
  }
  return arrayBufferViewToBuffer(content);
}
function mapperDirentToDirEntry(dir) {
  return (dirent) => direntToDirEntry(dir, dirent);
}
function direntToDirEntries(dir, dirent) {
  return dirent.map(mapperDirentToDirEntry(dir));
}
function direntToDirEntry(dir, dirent) {
  return {
    name: dirent.name,
    dir,
    fileType: toFileType(dirent)
  };
}
function toFileType(statLike) {
  const t = statLike.isFile() ? FileType.File : statLike.isDirectory() ? FileType.Directory : FileType.Unknown;
  return statLike.isSymbolicLink() ? t | FileType.SymbolicLink : t;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/CSpellIONode.js
var defaultCSpellIONode = void 0;
var CSpellIONode = class {
  serviceBus;
  constructor(serviceBus = new ServiceBus()) {
    this.serviceBus = serviceBus;
    registerHandlers(serviceBus);
  }
  readFile(urlOrFilename, encoding) {
    const ref = toFileReference(urlOrFilename, encoding);
    const res = this.serviceBus.dispatch(RequestFsReadFile.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFile");
    }
    return res.value;
  }
  readDirectory(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadDirectory.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readDirectory");
    }
    return res.value;
  }
  readFileSync(urlOrFilename, encoding) {
    const ref = toFileReference(urlOrFilename, encoding);
    const res = this.serviceBus.dispatch(RequestFsReadFileTextSync.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFileSync");
    }
    return res.value;
  }
  writeFile(urlOrFilename, content) {
    const ref = toFileReference(urlOrFilename);
    const fileResource = CFileResource.from(ref, content);
    const res = this.serviceBus.dispatch(RequestFsWriteFile.create(fileResource));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "writeFile");
    }
    return res.value;
  }
  getStat(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStat.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStat");
    }
    return res.value;
  }
  getStatSync(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStatSync.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStatSync");
    }
    return res.value;
  }
  compareStats(left, right) {
    return compareStats(left, right);
  }
  toURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename))
      return urlOrFilename.url;
    return toURL(urlOrFilename, relativeTo);
  }
  toFileURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename))
      return urlOrFilename.url;
    return toFileURL(urlOrFilename, relativeTo);
  }
  urlBasename(urlOrFilename) {
    return urlBasename(this.toURL(urlOrFilename));
  }
  urlDirname(urlOrFilename) {
    return urlParent(this.toURL(urlOrFilename));
  }
};
function genError(err, alt) {
  return err || new ErrorNotImplemented(alt);
}
function getDefaultCSpellIO() {
  if (defaultCSpellIONode)
    return defaultCSpellIONode;
  const cspellIO = new CSpellIONode();
  defaultCSpellIONode = cspellIO;
  return cspellIO;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/VirtualFS.js
var debug = false;

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/VirtualFS/findUpFromUrl.js
async function findUpFromUrl(name, from2, options) {
  const { type: entryType = "file", stopAt, fs: fs8 } = options;
  let dir = new URL(".", from2);
  const root = new URL("/", dir);
  const predicate = makePredicate(fs8, name, entryType);
  const stopAtDir = stopAt || root;
  let last = "";
  while (dir.href !== last) {
    const found = await predicate(dir);
    if (found !== void 0)
      return found;
    last = dir.href;
    if (dir.href === root.href || dir.href === stopAtDir.href)
      break;
    dir = new URL("..", dir);
  }
  return void 0;
}
function makePredicate(fs8, name, entryType) {
  if (typeof name === "function")
    return name;
  const checkStat = entryType === "file" || entryType === "!file" ? "isFile" : "isDirectory";
  const checkValue = entryType.startsWith("!") ? false : true;
  function checkName(dir, name2) {
    const f = new URL(name2, dir);
    return fs8.stat(f).then((stats2) => (stats2.isUnknown() || stats2[checkStat]() === checkValue) && f || void 0).catch(() => void 0);
  }
  if (!Array.isArray(name))
    return (dir) => checkName(dir, name);
  return async (dir) => {
    const pending = name.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found)
        return found;
    }
    return void 0;
  };
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/VirtualFS/CVFileSystem.js
var _core;
var CVFileSystem = class {
  constructor(core) {
    __privateAdd(this, _core);
    __publicField(this, "readFile");
    __publicField(this, "writeFile");
    __publicField(this, "stat");
    __publicField(this, "readDirectory");
    __publicField(this, "getCapabilities");
    __privateSet(this, _core, core);
    this.readFile = __privateGet(this, _core).readFile.bind(__privateGet(this, _core));
    this.writeFile = __privateGet(this, _core).writeFile.bind(__privateGet(this, _core));
    this.stat = __privateGet(this, _core).stat.bind(__privateGet(this, _core));
    this.readDirectory = __privateGet(this, _core).readDirectory.bind(__privateGet(this, _core));
    this.getCapabilities = __privateGet(this, _core).getCapabilities.bind(__privateGet(this, _core));
  }
  get providerInfo() {
    return __privateGet(this, _core).providerInfo;
  }
  get hasProvider() {
    return __privateGet(this, _core).hasProvider;
  }
  findUp(name, from2, options = {}) {
    const opts = { ...options, fs: __privateGet(this, _core) };
    return findUpFromUrl(name, from2, opts);
  }
};
_core = new WeakMap();

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/VFileSystem.js
var FSCapabilityFlags;
(function(FSCapabilityFlags2) {
  FSCapabilityFlags2[FSCapabilityFlags2["None"] = 0] = "None";
  FSCapabilityFlags2[FSCapabilityFlags2["Stat"] = 1] = "Stat";
  FSCapabilityFlags2[FSCapabilityFlags2["Read"] = 2] = "Read";
  FSCapabilityFlags2[FSCapabilityFlags2["Write"] = 4] = "Write";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadWrite"] = 6] = "ReadWrite";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadDir"] = 8] = "ReadDir";
  FSCapabilityFlags2[FSCapabilityFlags2["WriteDir"] = 16] = "WriteDir";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadWriteDir"] = 24] = "ReadWriteDir";
})(FSCapabilityFlags || (FSCapabilityFlags = {}));

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/VirtualFS/WrappedProviderFs.js
function cspellIOToFsProvider(cspellIO) {
  const capabilities = FSCapabilityFlags.Stat | FSCapabilityFlags.ReadWrite | FSCapabilityFlags.ReadDir;
  const capabilitiesHttp = capabilities & ~FSCapabilityFlags.Write & ~FSCapabilityFlags.ReadDir;
  const capMap = {
    "file:": capabilities,
    "http:": capabilitiesHttp,
    "https:": capabilitiesHttp
  };
  const name = "CSpellIO";
  const supportedProtocols = /* @__PURE__ */ new Set(["file:", "http:", "https:"]);
  const fs8 = {
    providerInfo: { name },
    stat: (url2) => cspellIO.getStat(url2),
    readFile: (url2) => cspellIO.readFile(url2),
    readDirectory: (url2) => cspellIO.readDirectory(url2),
    writeFile: (file) => cspellIO.writeFile(file.url, file.content),
    dispose: () => void 0,
    capabilities,
    getCapabilities(url2) {
      return fsCapabilities(capMap[url2.protocol] || FSCapabilityFlags.None);
    }
  };
  return {
    name,
    getFileSystem: (url2, _next) => {
      return supportedProtocols.has(url2.protocol) ? fs8 : void 0;
    }
  };
}
function wrapError(e) {
  if (e instanceof VFSError)
    return e;
  return e;
}
var VFSError = class extends Error {
  constructor(message, options) {
    super(message, options);
  }
};
var VFSErrorUnsupportedRequest = class extends VFSError {
  request;
  parameters;
  url;
  constructor(request, url2, parameters) {
    super(`Unsupported request: ${request}`);
    this.request = request;
    this.parameters = parameters;
    this.url = url2 == null ? void 0 : url2.toString();
  }
};
var CFsCapabilities = class {
  flags;
  constructor(flags) {
    this.flags = flags;
  }
  get readFile() {
    return !!(this.flags & FSCapabilityFlags.Read);
  }
  get writeFile() {
    return !!(this.flags & FSCapabilityFlags.Write);
  }
  get readDirectory() {
    return !!(this.flags & FSCapabilityFlags.ReadDir);
  }
  get writeDirectory() {
    return !!(this.flags & FSCapabilityFlags.WriteDir);
  }
  get stat() {
    return !!(this.flags & FSCapabilityFlags.Stat);
  }
};
function fsCapabilities(flags) {
  return new CFsCapabilities(flags);
}
var WrappedProviderFs = class _WrappedProviderFs {
  fs;
  eventLogger;
  hasProvider;
  capabilities;
  providerInfo;
  _capabilities;
  constructor(fs8, eventLogger) {
    this.fs = fs8;
    this.eventLogger = eventLogger;
    this.hasProvider = !!fs8;
    this.capabilities = (fs8 == null ? void 0 : fs8.capabilities) || FSCapabilityFlags.None;
    this._capabilities = fsCapabilities(this.capabilities);
    this.providerInfo = (fs8 == null ? void 0 : fs8.providerInfo) || { name: "unknown" };
  }
  logEvent(method, event, traceID, url2, message) {
    this.eventLogger({ method, event, url: url2, traceID, ts: performance.now(), message });
  }
  getCapabilities(url2) {
    var _a3;
    if ((_a3 = this.fs) == null ? void 0 : _a3.getCapabilities)
      return this.fs.getCapabilities(url2);
    return this._capabilities;
  }
  async stat(urlRef) {
    const traceID = performance.now();
    const url2 = urlOrReferenceToUrl(urlRef);
    this.logEvent("stat", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Stat, "stat", url2);
      return new CVfsStat(await this.fs.stat(urlRef));
    } catch (e) {
      this.logEvent("stat", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("stat", "end", traceID, url2);
    }
  }
  async readFile(urlRef, encoding) {
    const traceID = performance.now();
    const url2 = urlOrReferenceToUrl(urlRef);
    this.logEvent("readFile", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Read, "readFile", url2);
      return fromFileResource(await this.fs.readFile(urlRef), encoding);
    } catch (e) {
      this.logEvent("readFile", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readFile", "end", traceID, url2);
    }
  }
  async readDirectory(url2) {
    const traceID = performance.now();
    this.logEvent("readDir", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.ReadDir, "readDirectory", url2);
      return (await this.fs.readDirectory(url2)).map((e) => new CVfsDirEntry(e));
    } catch (e) {
      this.logEvent("readDir", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readDir", "end", traceID, url2);
    }
  }
  async writeFile(file) {
    const traceID = performance.now();
    const url2 = file.url;
    this.logEvent("writeFile", "start", traceID, url2);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Write, "writeFile", file.url);
      return await this.fs.writeFile(file);
    } catch (e) {
      this.logEvent("writeFile", "error", traceID, url2, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("writeFile", "end", traceID, url2);
    }
  }
  static disposeOf(fs8) {
    var _a3;
    fs8 instanceof _WrappedProviderFs && ((_a3 = fs8.fs) == null ? void 0 : _a3.dispose());
  }
};
function checkCapabilityOrThrow(fs8, capabilities, flag, name, url2) {
  if (!(capabilities & flag)) {
    throw new VFSErrorUnsupportedRequest(name, url2);
  }
}
var CFileType = class {
  fileType;
  constructor(fileType) {
    this.fileType = fileType;
  }
  isFile() {
    return this.fileType === FileType.File;
  }
  isDirectory() {
    return this.fileType === FileType.Directory;
  }
  isUnknown() {
    return !this.fileType;
  }
  isSymbolicLink() {
    return !!(this.fileType & FileType.SymbolicLink);
  }
};
var CVfsStat = class extends CFileType {
  stat;
  constructor(stat2) {
    super(stat2.fileType || FileType.Unknown);
    this.stat = stat2;
  }
  get size() {
    return this.stat.size;
  }
  get mtimeMs() {
    return this.stat.mtimeMs;
  }
  get eTag() {
    return this.stat.eTag;
  }
};
var CVfsDirEntry = class extends CFileType {
  entry;
  _url;
  constructor(entry) {
    super(entry.fileType);
    this.entry = entry;
  }
  get name() {
    return this.entry.name;
  }
  get dir() {
    return this.entry.dir;
  }
  get url() {
    if (this._url)
      return this._url;
    this._url = new URL(this.entry.name, this.entry.dir);
    return this._url;
  }
  toJSON() {
    return {
      name: this.name,
      dir: this.dir,
      fileType: this.fileType
    };
  }
};
function chopUrl(url2) {
  if (!url2)
    return "";
  const href = url2.href;
  const parts = href.split("/");
  const n = parts.indexOf("node_modules");
  if (n > 0) {
    const tail = parts.slice(Math.max(parts.length - 3, n + 1));
    return parts.slice(0, n + 1).join("/") + "/\u2026/" + tail.join("/");
  }
  return href;
}
function rPad(str, len, ch = " ") {
  return str.padEnd(len, ch);
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/CVirtualFS.js
var CVirtualFS = class {
  providers = /* @__PURE__ */ new Set();
  cachedFs = /* @__PURE__ */ new Map();
  revCacheFs = /* @__PURE__ */ new Map();
  fsc;
  fs;
  loggingEnabled = debug;
  constructor() {
    this.fsc = fsPassThroughCore((url2) => this._getFS(url2));
    this.fs = new CVFileSystem(this.fsc);
  }
  enableLogging(value) {
    this.loggingEnabled = value ?? true;
  }
  log = console.log;
  logEvent = (event) => {
    if (this.loggingEnabled) {
      const id = event.traceID.toFixed(13).replaceAll(/\d{4}(?=\d)/g, "$&.");
      const msg = event.message ? `
		${event.message}` : "";
      const method = rPad(`${event.method}-${event.event}`, 16);
      this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
    }
  };
  registerFileSystemProvider(...providers) {
    providers.forEach((provider) => this.providers.add(provider));
    this.reset();
    return {
      dispose: () => {
        for (const provider of providers) {
          for (const key of this.revCacheFs.get(provider) || []) {
            this.cachedFs.delete(key);
          }
          this.providers.delete(provider) && void 0;
        }
        this.reset();
      }
    };
  }
  getFS(url2) {
    return new CVFileSystem(this._getFS(url2));
  }
  _getFS(url2) {
    const key = `${url2.protocol}${url2.hostname}`;
    const cached = this.cachedFs.get(key);
    if (cached) {
      return cached;
    }
    const fnNext = (provider, next2) => {
      return (url3) => {
        let calledNext = false;
        const fs9 = provider.getFileSystem(url3, (_url) => {
          calledNext = calledNext || url3 === _url;
          return next2(_url);
        });
        if (fs9) {
          const s = this.revCacheFs.get(provider) || /* @__PURE__ */ new Set();
          s.add(key);
          this.revCacheFs.set(provider, s);
          return fs9;
        }
        if (!calledNext) {
          return next2(url3);
        }
        return void 0;
      };
    };
    let next = (_url) => void 0;
    for (const provider of this.providers) {
      next = fnNext(provider, next);
    }
    const fs8 = new WrappedProviderFs(next(url2), this.logEvent);
    this.cachedFs.set(key, fs8);
    return fs8;
  }
  reset() {
    this.disposeOfCachedFs();
  }
  disposeOfCachedFs() {
    for (const [key, fs8] of [...this.cachedFs].reverse()) {
      try {
        WrappedProviderFs.disposeOf(fs8);
      } catch {
      }
      this.cachedFs.delete(key);
    }
    this.cachedFs.clear();
    this.revCacheFs.clear();
  }
  dispose() {
    var _a3;
    this.disposeOfCachedFs();
    const providers = [...this.providers].reverse();
    for (const provider of providers) {
      try {
        (_a3 = provider.dispose) == null ? void 0 : _a3.call(provider);
      } catch {
      }
    }
  }
};
function fsPassThroughCore(fs8) {
  function gfs(ur, name) {
    const url2 = urlOrReferenceToUrl(ur);
    const f = fs8(url2);
    if (!f.hasProvider)
      throw new VFSErrorUnsupportedRequest(name, url2, ur instanceof URL ? void 0 : { url: ur.url.toString(), encoding: ur.encoding });
    return f;
  }
  return {
    providerInfo: { name: "default" },
    hasProvider: true,
    stat: async (url2) => gfs(url2, "stat").stat(url2),
    readFile: async (url2) => gfs(url2, "readFile").readFile(url2),
    writeFile: async (file) => gfs(file, "writeFile").writeFile(file),
    readDirectory: async (url2) => gfs(url2, "readDirectory").readDirectory(url2).then((entries) => entries.map((e) => new CVfsDirEntry(e))),
    getCapabilities: (url2) => gfs(url2, "getCapabilities").getCapabilities(url2)
  };
}
function createVirtualFS(cspellIO) {
  const cspell2 = cspellIO || getDefaultCSpellIO();
  const vfs = new CVirtualFS();
  vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell2));
  return vfs;
}
var defaultVirtualFs = void 0;
function getDefaultVirtualFs() {
  if (!defaultVirtualFs) {
    defaultVirtualFs = createVirtualFS();
  }
  return defaultVirtualFs;
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/fileWriter.js
var fs4 = __toESM(require("fs"), 1);
var Stream = __toESM(require("stream"), 1);
var import_node_util4 = require("util");
var zlib = __toESM(require("zlib"), 1);

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/common/transformers.js
function encoderTransformer(iterable, encoding) {
  return isAsyncIterable(iterable) ? encoderAsyncIterable(iterable, encoding) : encoderIterable(iterable, encoding);
}
function* encoderIterable(iterable, encoding) {
  let useBom = true;
  for (const chunk of iterable) {
    yield encodeString(chunk, encoding, useBom);
    useBom = false;
  }
}
async function* encoderAsyncIterable(iterable, encoding) {
  let useBom = true;
  for await (const chunk of iterable) {
    yield encodeString(chunk, encoding, useBom);
    useBom = false;
  }
}
function isAsyncIterable(v) {
  return v && typeof v === "object" && !!v[Symbol.asyncIterator];
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/node/file/fileWriter.js
var pipeline2 = (0, import_node_util4.promisify)(Stream.pipeline);
function writeToFile(filename, data, encoding) {
  return writeToFileIterable(filename, typeof data === "string" ? [data] : data, encoding);
}
function writeToFileIterable(filename, data, encoding) {
  const stream = Stream.Readable.from(encoderTransformer(data, encoding));
  const zip = /\.gz$/.test(filename) ? zlib.createGzip() : new Stream.PassThrough();
  return pipeline2(stream, zip, fs4.createWriteStream(filename));
}

// node_modules/.pnpm/cspell-io@8.14.2/node_modules/cspell-io/dist/esm/file/file.js
async function readFileText(filename, encoding) {
  const fr = await getDefaultCSpellIO().readFile(filename, encoding);
  return fr.getText();
}
function readFileTextSync(filename, encoding) {
  return getDefaultCSpellIO().readFileSync(filename, encoding).getText();
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/fileSystem.js
function getVirtualFS() {
  return getDefaultVirtualFs();
}
function getFileSystem() {
  return getVirtualFS().fs;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/pkg-info.mjs
var import_node_url9 = require("url");
var import_meta = {};
var url = import_meta.url;
function calcSrcDirectory() {
  try {
    return __dirname;
  } catch {
    return url ? (0, import_node_url9.fileURLToPath)(new URL("./", url)) : process.cwd();
  }
}
var srcDirectory = calcSrcDirectory();

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/templates.js
function replaceTemplate(template, replacements) {
  const templateStart = "${";
  const tLen = templateStart.length;
  const templateEnd = "}";
  const parts = [];
  let lastPos = 0;
  let p = template.indexOf(templateStart, lastPos);
  if (p < 0)
    return template;
  while (p >= 0) {
    parts.push(template.substring(lastPos, p));
    lastPos = p;
    const end = template.indexOf(templateEnd, p);
    if (end < 0)
      break;
    const name = template.substring(p + tLen, end);
    if (name in replacements) {
      parts.push(replacements[name] || "");
    } else {
      parts.push(template.substring(p, end + 1));
    }
    lastPos = end + 1;
    p = template.indexOf(templateStart, lastPos);
  }
  parts.push(template.substring(lastPos));
  return parts.join("");
}
function envToTemplateVars(env3) {
  const vars = {};
  for (const [key, value] of Object.entries(env3)) {
    vars[`env:${key}`] = value || "";
  }
  return vars;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/url.js
var import_node_path6 = __toESM(require("path"), 1);
var import_node_url10 = require("url");
function getSourceDirectoryUrl() {
  const srcDirectoryURL = (0, import_node_url10.pathToFileURL)(import_node_path6.default.join(srcDirectory, "/"));
  return srcDirectoryURL;
}
function cwdURL() {
  return (0, import_node_url10.pathToFileURL)("./");
}
function toFileUrl(file) {
  return toFileURL(file, cwdURL());
}
function fileURLOrPathToPath(filenameOrURL) {
  return toFilePathOrHref(filenameOrURL);
}
var regExpWindowsPathDriveLetter2 = /^([a-zA-Z]):[\\]/;
function windowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter2, (s) => s.toUpperCase());
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/resolveFile.js
var regExpStartsWidthNodeModules = /^node_modules[/\\]/;
var FileResolver = class {
  fs;
  templateReplacements;
  constructor(fs8, templateReplacements) {
    this.fs = fs8;
    this.templateReplacements = templateReplacements;
  }
  /**
   * Resolve filename to absolute paths.
   * - Replaces `${env:NAME}` with the value of the environment variable `NAME`.
   * - Replaces `~` with the user's home directory.
   * It tries to look for local files as well as node_modules
   * @param filename an absolute path, relative path, `~` path, a node_module, or URL.
   * @param relativeTo absolute path
   */
  async resolveFile(filename, relativeTo) {
    if (filename instanceof URL) {
      return {
        filename: toFilePathOrHref(filename),
        relativeTo: relativeTo.toString(),
        found: await this.doesExist(filename),
        method: "url"
      };
    }
    const result = await this._resolveFile(filename, relativeTo);
    const match2 = filename.match(regExpStartsWidthNodeModules);
    if (match2) {
      result.warning ?? (result.warning = `Import of '${filename}' should not start with '${match2[0]}' in '${toFilePathOrHref(relativeTo)}'. Use '${filename.replace(regExpStartsWidthNodeModules, "")}' or a relative path instead.`);
    }
    return result;
  }
  async _resolveFile(filename, relativeTo) {
    filename = patchFilename(filename, this.templateReplacements);
    const steps = [
      { filename, fn: this.tryUrlRel },
      { filename, fn: this.tryCreateRequire },
      { filename, fn: this.tryNodeRequireResolve },
      { filename, fn: this.tryImportResolve },
      { filename, fn: this.tryResolveExists },
      { filename, fn: this.tryNodeResolveDefaultPaths },
      { filename, fn: this.tryResolveFrom },
      { filename, fn: this.tryResolveGlobal },
      { filename, fn: this.tryLegacyResolve }
    ];
    for (const step of steps) {
      const r = await step.fn(step.filename, relativeTo);
      if (r == null ? void 0 : r.found)
        return r;
    }
    const result = await this.tryUrl(filename, relativeTo) || {
      filename: isRelative(filename) ? joinWith(filename, relativeTo) : filename.toString(),
      relativeTo: relativeTo.toString(),
      found: false,
      method: "not found"
    };
    return result;
  }
  async doesExist(file) {
    try {
      const s = await this.fs.stat(file);
      return s.isFile() || s.isUnknown();
    } catch {
      return false;
    }
  }
  /**
   * Check to see if it is a URL.
   * Note: URLs are absolute!
   * If relativeTo is a non-file URL, then it will try to resolve the filename relative to it.
   * @param filename - url string
   * @returns ResolveFileResult
   */
  tryUrlRel = async (filename, relativeToURL) => {
    if (isUrlLike(filename)) {
      const fileURL = toURL(filename);
      return {
        filename: toFilePathOrHref(fileURL),
        relativeTo: void 0,
        found: await this.doesExist(fileURL),
        method: "tryUrl"
      };
    }
    if (isRelative(filename) && isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return void 0;
  };
  /**
   * Check to see if it is a URL.
   * Note: URLs are absolute!
   * If relativeTo is a non-file URL, then it will try to resolve the filename relative to it.
   * @param filename - url string
   * @returns ResolveFileResult
   */
  tryUrl = async (filename, relativeToURL) => {
    if (isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return void 0;
  };
  tryCreateRequire = (filename, relativeTo) => {
    if (filename instanceof URL)
      return void 0;
    const rel = !isUrlLike(relativeTo) || isFileURL(relativeTo) ? relativeTo : (0, import_node_url11.pathToFileURL)("./");
    const require2 = (0, import_node_module2.createRequire)(rel);
    try {
      const r = require2.resolve(filename);
      return { filename: r, relativeTo: rel.toString(), found: true, method: "tryCreateRequire" };
    } catch {
      return void 0;
    }
  };
  tryNodeResolveDefaultPaths = (filename) => {
    try {
      const r = require.resolve(filename);
      return { filename: r, relativeTo: void 0, found: true, method: "tryNodeResolveDefaultPaths" };
    } catch {
      return void 0;
    }
  };
  tryNodeRequireResolve = (filenameOrURL, relativeTo) => {
    if (isUrlLike(relativeTo) && !isFileURL(relativeTo))
      return void 0;
    const filename = fileURLOrPathToPath(filenameOrURL);
    const relativeToPath = pathFromRelativeTo(relativeTo);
    const home = os2.homedir();
    function calcPaths(p) {
      const paths2 = [p];
      if (isRelative(filename)) {
        return paths2;
      }
      for (; p && path5.dirname(p) !== p && p !== home; p = path5.dirname(p)) {
        paths2.push(p);
      }
      return paths2;
    }
    const paths = calcPaths(path5.resolve(relativeToPath));
    try {
      const r = require.resolve(filename, { paths });
      return { filename: r, relativeTo: relativeToPath, found: true, method: "tryNodeRequireResolve" };
    } catch {
      return void 0;
    }
  };
  tryImportResolve = (filename, relativeTo) => {
    try {
      const paths = isRelative(filename) ? [relativeTo] : [relativeTo, srcDirectory];
      const resolved = (0, import_node_url12.fileURLToPath)(importResolveModuleName(filename, paths));
      return { filename: resolved, relativeTo: relativeTo.toString(), found: true, method: "tryImportResolve" };
    } catch {
      return void 0;
    }
  };
  tryResolveGlobal = (filename) => {
    const r = resolveGlobal(filename);
    return r && { filename: r, relativeTo: void 0, found: true, method: "tryResolveGlobal" } || void 0;
  };
  tryResolveExists = async (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return void 0;
    }
    relativeTo = pathFromRelativeTo(relativeTo);
    const toTry = [{ filename }, { filename: path5.resolve(relativeTo, filename), relativeTo }];
    for (const { filename: filename2, relativeTo: relativeTo2 } of toTry) {
      const found = path5.isAbsolute(filename2) && await this.doesExist(toFileUrl(filename2));
      if (found)
        return { filename: filename2, relativeTo: relativeTo2 == null ? void 0 : relativeTo2.toString(), found, method: "tryResolveExists" };
    }
    filename = path5.resolve(filename);
    return {
      filename,
      relativeTo: path5.resolve("."),
      found: await this.doesExist(toFileUrl(filename)),
      method: "tryResolveExists"
    };
  };
  tryResolveFrom = (filename, relativeTo) => {
    if (relativeTo instanceof URL)
      return void 0;
    try {
      return {
        filename: (0, import_resolve_from.default)(pathFromRelativeTo(relativeTo), filename),
        relativeTo,
        found: true,
        method: "tryResolveFrom"
      };
    } catch {
      return void 0;
    }
  };
  tryLegacyResolve = (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return void 0;
    }
    const relativeToPath = isUrlLike(relativeTo) ? (0, import_node_url12.fileURLToPath)(new URL("./", relativeTo)) : relativeTo.toString();
    const match2 = filename.match(regExpStartsWidthNodeModules);
    if (match2) {
      const fixedFilename = filename.replace(regExpStartsWidthNodeModules, "");
      const found = this.tryImportResolve(fixedFilename, relativeToPath) || this.tryResolveFrom(fixedFilename, relativeToPath);
      if (found == null ? void 0 : found.found) {
        found.method = "tryLegacyResolve";
        return found;
      }
    }
    return void 0;
  };
};
function patchFilename(filename, templateReplacements) {
  const defaultReplacements = {
    cwd: process.cwd(),
    pathSeparator: path5.sep,
    userHome: os2.homedir()
  };
  filename = filename.replace(/^~(?=[/\\])/, defaultReplacements.userHome);
  filename = replaceTemplate(filename, { ...defaultReplacements, ...templateReplacements });
  return filename;
}
function resolveRelativeTo(filename, relativeTo, templateReplacements = envToTemplateVars(process.env)) {
  if (filename instanceof URL)
    return filename;
  filename = patchFilename(filename, templateReplacements);
  const relativeToUrl = toFileUrl(relativeTo);
  return toFileURL(filename, relativeToUrl);
}
function isRelative(filename) {
  if (filename instanceof URL)
    return false;
  if (isUrlLike(filename))
    return false;
  if (filename.startsWith("./"))
    return true;
  if (filename.startsWith("../"))
    return true;
  if (filename.startsWith("." + path5.sep))
    return true;
  if (filename.startsWith(".." + path5.sep))
    return true;
  return false;
}
function joinWith(filename, relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? toFilePathOrHref(new URL(filename, relativeTo)) : path5.resolve(relativeTo, filename);
}
function pathFromRelativeTo(relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? (0, import_node_url12.fileURLToPath)(new URL("./", relativeTo)) : relativeTo;
}
var loaderCache = /* @__PURE__ */ new WeakMap();
function createFileResolver(fs8, templateVariables = envToTemplateVars(process.env)) {
  let loader2 = loaderCache.get(fs8);
  if (!loader2) {
    loader2 = new FileResolver(fs8, templateVariables);
    loaderCache.set(fs8, loader2);
  }
  return loader2;
}
async function resolveFile(filename, relativeTo, fs8 = getFileSystem()) {
  const resolver = createFileResolver(fs8);
  return resolver.resolveFile(filename, relativeTo);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/DictionaryReferenceCollection.js
function createDictionaryReferenceCollection(dictionaries) {
  return new _DictionaryReferenceCollection(dictionaries);
}
var _DictionaryReferenceCollection = class {
  dictionaries;
  collection;
  constructor(dictionaries) {
    this.dictionaries = dictionaries;
    this.collection = collect(dictionaries);
  }
  isEnabled(name) {
    const entry = this.collection[name];
    return entry === void 0 ? void 0 : !!(entry & 1);
  }
  isBlocked(name) {
    const entry = this.collection[name];
    return entry === void 0 ? void 0 : !(entry & 1);
  }
  enabled() {
    return this.dictionaryIds.filter((n) => this.isEnabled(n));
  }
  blocked() {
    return this.dictionaryIds.filter((n) => this.isBlocked(n));
  }
  get dictionaryIds() {
    return Object.keys(this.collection);
  }
};
function collect(dictionaries) {
  const refs = dictionaries.map(normalizeName).map(mapReference);
  const col = {};
  for (const ref of refs) {
    col[ref.name] = Math.max(ref.weight, col[ref.name] || 0);
  }
  return col;
}
function normalizeName(entry) {
  return entry.normalize().trim();
}
function mapReference(ref) {
  const name = ref.replace(/^!+/, "");
  const weight = ref.length - name.length + 1;
  return { name: name.trim(), weight };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
function filterDictDefsToLoad(dictRefCol, defs) {
  const allActiveDefs = defs.filter(({ name }) => dictRefCol.isEnabled(name)).map(fixPath);
  return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
}
function fixPath(def) {
  if (def instanceof _DictionaryDefinitionInternalWithSource) {
    return def;
  }
  const newPath = fixDicPath(def.path, def.file);
  return {
    ...def,
    file: void 0,
    path: newPath
  };
}
function fixDicPath(defPath, defFile) {
  const parts = [defPath || "", defFile || ""].filter((p) => !!p);
  return parts.length > 1 ? path6.join(...parts) : parts[0] || "";
}
function mapDictDefsToInternal(defs, pathToSettingsFile) {
  return defs == null ? void 0 : defs.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
}
var internalDefs = createAutoResolveWeakWeakCache();
function mapDictDefToInternal(def, pathToSettingsFile) {
  return internalDefs.get(def, (def2) => _mapDictDefToInternal(def2, pathToSettingsFile));
}
function _mapDictDefToInternal(def, pathToSettingsFile) {
  if (isDictionaryDefinitionWithSource(def)) {
    return def;
  }
  const source = pathToSettingsFile.href;
  if (isDictionaryDefinitionInlineInternal(def)) {
    return { ...def, __source: source };
  }
  return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
}
function determineName(filename, options) {
  return options.name || path6.basename(filename);
}
function calcDictionaryDefsToLoad(settings) {
  const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
  const colNoSug = createDictionaryReferenceCollection(noSuggestDictionaries);
  const colDicts = createDictionaryReferenceCollection([...dictionaries, ...colNoSug.enabled()]);
  const modDefs = dictionaryDefinitions.map((def) => {
    const enabled = colNoSug.isEnabled(def.name);
    if (enabled === void 0)
      return def;
    return { ...def, noSuggest: enabled };
  });
  return filterDictDefsToLoad(colDicts, modDefs);
}
function isDictionaryDefinitionWithSource(d) {
  return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
}
function isDictionaryFileDefinitionInternalWithSource(def) {
  return def instanceof _DictionaryDefinitionInternalWithSource;
}
function isDictionaryDefinitionInlineInternalWithSource(def) {
  return isDictionaryDefinitionInlineInternal(def) && !!def.__source;
}
var _DictionaryDefinitionInternalWithSource = class {
  sourceURL;
  _weightMap;
  name;
  path;
  addWords;
  description;
  dictionaryInformation;
  type;
  file;
  repMap;
  useCompounds;
  noSuggest;
  scope;
  __source;
  ddi;
  constructor(def, sourceURL) {
    this.sourceURL = sourceURL;
    this.__source = sourceURL.href;
    const defAll = def;
    const { path: relPath = "", file = "", addWords, description, dictionaryInformation, type, repMap, noSuggest, scope, useCompounds } = defAll;
    const defaultPath = sourceURL;
    const filePath = fixDicPath(relPath, file);
    const name = determineName(filePath, def);
    const resolvedPath = toFilePathOrHref(resolveRelativeTo(filePath, defaultPath));
    const ddi = {
      name,
      file: void 0,
      path: resolvedPath,
      addWords,
      description,
      dictionaryInformation,
      type,
      repMap,
      noSuggest,
      scope,
      useCompounds
    };
    Object.assign(this, clean4(ddi));
    this.ddi = ddi;
    this.name = ddi.name;
    this.file = ddi.file;
    this.path = ddi.path;
    this._weightMap = this.dictionaryInformation ? mapDictionaryInformationToWeightMap(this.dictionaryInformation) : void 0;
  }
  get weightMap() {
    return this._weightMap;
  }
  toJSON() {
    return this.ddi;
  }
};

// node_modules/.pnpm/@cspell+strong-weak-map@8.14.2/node_modules/@cspell/strong-weak-map/dist/esm/StrongWeakMap.js
var StrongWeakMap = class {
  map;
  constructor(init) {
    this.map = new Map(init == null ? void 0 : init.map(([k, v]) => [k, new WeakRef(v)]));
  }
  clear() {
    this.map.clear();
  }
  /**
   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    return this.map.delete(key);
  }
  /**
   * Executes a provided function once per each key/value pair in the Map, in insertion order.
   */
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    for (const [key, value] of this) {
      callbackfn(value, key, this);
    }
  }
  /**
   * Returns a specified element from the Map object. You will get a reference to the value object and any change made to that
   * object will effectively modify it inside the Map.
   * @returns Returns the element associated with the specified key.
   *   If no element is associated with the specified key, undefined is returned.
   */
  get(key) {
    const ref = this.map.get(key);
    if (!ref)
      return void 0;
    const value = ref.deref();
    if (!value) {
      this.map.delete(key);
      return void 0;
    }
    return value;
  }
  /**
   * Returns a specified element from the Map. If the element isn't found, the resolver function is called and the result is stored in the map and returned.
   */
  autoGet(key, resolver) {
    const found = this.get(key);
    if (found)
      return found;
    const created = resolver(key);
    this.set(key, created);
    return created;
  }
  /**
   * Note: has will cause the value object to live longer.
   * See: [WeakRef - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#notes_on_weakrefs)
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  has(key) {
    const value = this.get(key);
    return !!value;
  }
  /**
   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
   */
  set(key, value) {
    this.map.set(key, new WeakRef(value));
    return this;
  }
  /**
   * @returns the number of elements in the Map. Note: it is possible that some of the values have been dereferenced
   */
  get size() {
    return this.map.size;
  }
  /** Returns an iterable of entries in the map. */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Returns an iterable of key, value pairs for every entry in the map.
   */
  *entries() {
    for (const key of this.map.keys()) {
      const value = this.get(key);
      if (!value)
        continue;
      yield [key, value];
    }
  }
  /**
   * Returns an iterable of keys in the map
   *
   * Note: It is possible that the value associated with the key was released.
   */
  keys() {
    return this.map.keys();
  }
  /**
   * Returns an iterable of values in the map
   */
  *values() {
    for (const [_, value] of this) {
      yield value;
    }
  }
  /**
   * Removes any keys that reference released objects.
   */
  cleanKeys() {
    const keysToDel = [];
    for (const [key, ref] of this.map.entries()) {
      if (!ref.deref()) {
        keysToDel.push(key);
      }
    }
    for (const key of keysToDel) {
      this.map.delete(key);
    }
    return this;
  }
  [Symbol.toStringTag] = "StrongWeakMap";
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/simpleCache.js
var SimpleCache2 = class {
  size;
  L0 = /* @__PURE__ */ new Map();
  L1 = /* @__PURE__ */ new Map();
  L2 = /* @__PURE__ */ new Map();
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  delete(key) {
    let deleted = false;
    for (const c of this.caches()) {
      deleted = c.delete(key) || deleted;
    }
    return deleted;
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    const L2 = this.L2;
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = L2;
    this.L0.clear();
  }
};
var AutoCache = class extends SimpleCache2 {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/SpellingDictionary/SpellingDictionaryError.js
var SpellingDictionaryLoadError = class extends Error {
  uri;
  options;
  cause;
  name;
  constructor(uri, options, cause, message) {
    super(message);
    this.uri = uri;
    this.options = options;
    this.cause = cause;
    this.name = options.name;
  }
};
function isSpellingDictionaryLoadError(e) {
  return e instanceof SpellingDictionaryLoadError;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/DictionaryLoader.js
var MAX_AGE = 1e4;
var loaders = {
  S: loadSimpleWordList,
  C: legacyWordList,
  W: wordsPerLineWordList,
  T: loadTrie,
  default: loadSimpleWordList
};
var LoadingState;
(function(LoadingState2) {
  LoadingState2[LoadingState2["Loaded"] = 0] = "Loaded";
  LoadingState2[LoadingState2["Loading"] = 1] = "Loading";
})(LoadingState || (LoadingState = {}));
var DictionaryLoader = class {
  fs;
  dictionaryCache = new StrongWeakMap();
  inlineDictionaryCache = new AutoResolveWeakCache2();
  dictionaryCacheByDef = new AutoResolveWeakWeakCache();
  reader;
  /** The keepAliveCache is to hold onto the most recently loaded dictionaries. */
  keepAliveCache;
  constructor(fs8, keepAliveSize = 10) {
    this.fs = fs8;
    this.reader = toReader(fs8);
    this.keepAliveCache = new SimpleCache2(keepAliveSize);
  }
  loadDictionary(def) {
    if (isDictionaryDefinitionInlineInternal(def)) {
      return Promise.resolve(this.loadInlineDict(def));
    }
    const { key, entry } = this.getCacheEntry(def);
    if (entry) {
      return entry.pending.then(([dictionary]) => dictionary);
    }
    const loadedEntry = this.loadEntry(def.path, def);
    this.setCacheEntry(key, loadedEntry, def);
    this.keepAliveCache.set(def, loadedEntry);
    return loadedEntry.pending.then(([dictionary]) => dictionary);
  }
  /**
   * Check to see if any of the cached dictionaries have changed. If one has changed, reload it.
   * @param maxAge - Only check the dictionary if it has been at least `maxAge` ms since the last check.
   * @param now - optional timestamp representing now. (Mostly used in testing)
   */
  async refreshCacheEntries(maxAge = MAX_AGE, now = Date.now()) {
    await Promise.all([...this.dictionaryCache.values()].map((entry) => this.refreshEntry(entry, maxAge, now)));
  }
  getCacheEntry(def) {
    const defEntry = this.dictionaryCacheByDef.get(def);
    if (defEntry) {
      this.keepAliveCache.get(def);
      return defEntry;
    }
    const key = this.calcKey(def);
    const entry = this.dictionaryCache.get(key);
    if (entry) {
      entry.options = def;
      this.keepAliveCache.set(def, entry);
    }
    return { key, entry };
  }
  setCacheEntry(key, entry, def) {
    this.dictionaryCache.set(key, entry);
    this.dictionaryCacheByDef.set(def, { key, entry });
  }
  async refreshEntry(entry, maxAge, now) {
    if (now - entry.ts >= maxAge) {
      const sig = now + Math.random();
      entry.sig = sig;
      entry.ts = now;
      const pStat = this.getStat(entry.uri);
      const [newStat] = await Promise.all([pStat, entry.pending]);
      const hasChanged = !this.isEqual(newStat, entry.stat);
      const sigMatches = entry.sig === sig;
      if (sigMatches && hasChanged) {
        entry.loadingState = LoadingState.Loading;
        const key = this.calcKey(entry.options);
        const newEntry = this.loadEntry(entry.uri, entry.options);
        this.dictionaryCache.set(key, newEntry);
        this.dictionaryCacheByDef.set(entry.options, { key, entry: newEntry });
      }
    }
  }
  loadEntry(fileOrUri, options, now = Date.now()) {
    const url2 = toFileURL(fileOrUri);
    options = this.normalizeOptions(url2, options);
    const pDictionary = load(this.reader, toFileURL(fileOrUri), options).catch((e) => createFailedToLoadDictionary(options.name, fileOrUri, new SpellingDictionaryLoadError(url2.href, options, e, "failed to load"), options));
    const pStat = this.getStat(fileOrUri);
    const pending = Promise.all([pDictionary, pStat]);
    const sig = now + Math.random();
    const entry = {
      uri: url2.href,
      options,
      ts: now,
      stat: void 0,
      dictionary: void 0,
      pending,
      loadingState: LoadingState.Loading,
      sig
    };
    pending.then(([dictionary, stat2]) => {
      entry.stat = stat2;
      entry.dictionary = dictionary;
      entry.loadingState = LoadingState.Loaded;
      return;
    }).catch(() => void 0);
    return entry;
  }
  getStat(uri) {
    return this.fs.stat(toFileURL(uri)).catch(toError);
  }
  isEqual(a, b) {
    if (!b)
      return false;
    if (isError3(a)) {
      return isError3(b) && a.message === b.message && a.name === b.name;
    }
    return !isError3(b) && !compareStats(a, b);
  }
  normalizeOptions(uri, options) {
    if (options.name)
      return options;
    return { ...options, name: urlBasename(uri) };
  }
  loadInlineDict(def) {
    return this.inlineDictionaryCache.get(def, (def2) => createInlineSpellingDictionary(def2, def2.__source || "memory"));
  }
  calcKey(def) {
    const path13 = def.path;
    const loaderType = determineType(toFileURL(path13), def);
    const optValues = importantOptionKeys.map((k) => {
      var _a3;
      return ((_a3 = def[k]) == null ? void 0 : _a3.toString()) || "";
    });
    const parts = [path13, loaderType, ...optValues];
    return parts.join("|");
  }
};
function toReader(fs8) {
  async function readFile3(url2) {
    return (await fs8.readFile(url2)).getText();
  }
  return {
    read: readFile3,
    readLines: async (filename) => toLines(await readFile3(filename))
  };
}
var importantOptionKeys = ["name", "noSuggest", "useCompounds", "type"];
function isError3(e) {
  const err = e;
  return !!err.message;
}
function determineType(uri, opts) {
  const t = opts.type && opts.type in loaders && opts.type || "S";
  const defLoaderType = t;
  const defType = uri.pathname.endsWith(".trie.gz") ? "T" : defLoaderType;
  const regTrieTest = /\.trie\b/i;
  return regTrieTest.test(uri.pathname) ? "T" : defType;
}
function load(reader, uri, options) {
  const type = determineType(uri, options);
  const loader2 = loaders[type] || loaders.default;
  return loader2(reader, uri, options);
}
async function legacyWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _legacyWordListSync(lines, filename, options);
}
function _legacyWordListSync(lines, filename, options) {
  const words = pipeSync(
    lines,
    // Remove comments
    opMapSync((line) => line.replaceAll(/#.*/g, "")),
    // Split on everything else
    opConcatMapSync((line) => line.split(/[^\w\p{L}\p{M}']+/gu)),
    opFilterSync((word) => !!word)
  );
  return createSpellingDictionary(words, options.name, filename.toString(), options);
}
async function wordsPerLineWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _wordsPerLineWordList(lines, filename.toString(), options);
}
function _wordsPerLineWordList(lines, filename, options) {
  const words = pipeSync(
    lines,
    // Remove comments
    opMapSync((line) => line.replaceAll(/#.*/g, "")),
    // Split on everything else
    opConcatMapSync((line) => line.split(/\s+/gu)),
    opFilterSync((word) => !!word)
  );
  return createSpellingDictionary(words, options.name, filename, options);
}
async function loadSimpleWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return createSpellingDictionary(lines, options.name, filename.href, options);
}
async function loadTrie(reader, filename, options) {
  const content = await reader.read(filename);
  return createSpellingDictionaryFromTrieFile(content, options.name, filename.href, options);
}
function toLines(content) {
  return content.split(/\n|\r\n|\r/);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryLoader.js
var loader;
function getDictionaryLoader(vfs) {
  if (loader)
    return loader;
  return loader = new DictionaryLoader(vfs || getFileSystem());
}
function loadDictionary(def) {
  return getDictionaryLoader().loadDictionary(def);
}
async function refreshCacheEntries(maxAge, now) {
  return getDictionaryLoader().refreshCacheEntries(maxAge, now);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/SpellingDictionary/Dictionaries.js
function loadDictionaryDefs(defsToLoad) {
  return defsToLoad.map(loadDictionary);
}
function refreshDictionaryCache(maxAge) {
  return refreshCacheEntries(maxAge);
}
var emptyWords = Object.freeze([]);
async function getDictionaryInternal(settings) {
  const spellDictionaries = await Promise.all(loadDictionaryDefs(calcDictionaryDefsToLoad(settings)));
  return _getDictionaryInternal(settings, spellDictionaries);
}
var specialDictionaryNames = {
  words: "[words]",
  userWords: "[userWords]",
  flagWords: "[flagWords]",
  ignoreWords: "[ignoreWords]",
  suggestWords: "[suggestWords]"
};
var mapSpecialDictionaryNamesToSettings = new Map(Object.entries(specialDictionaryNames).map(([k, v]) => [v, k]));
function getInlineConfigDictionaries(settings) {
  const { words = emptyWords, userWords = emptyWords, flagWords = emptyWords, ignoreWords = emptyWords, suggestWords = emptyWords } = settings;
  const settingsWordsDictionary = createSpellingDictionary(words, specialDictionaryNames.words, "From Settings `words`", {
    caseSensitive: true,
    weightMap: void 0
  });
  const settingsUserWordsDictionary = userWords.length ? createSpellingDictionary(userWords, specialDictionaryNames.userWords, "From Settings `userWords`", {
    caseSensitive: true,
    weightMap: void 0
  }) : void 0;
  const ignoreWordsDictionary = createIgnoreWordsDictionary(ignoreWords, specialDictionaryNames.ignoreWords, "From Settings `ignoreWords`");
  const flagWordsDictionary = createFlagWordsDictionary(flagWords, specialDictionaryNames.flagWords, "From Settings `flagWords`");
  const suggestWordsDictionary = createSuggestDictionary(suggestWords, "[suggestWords]", "From Settings `suggestWords`");
  const dictionaries = [
    settingsWordsDictionary,
    settingsUserWordsDictionary,
    ignoreWordsDictionary,
    flagWordsDictionary,
    suggestWordsDictionary
  ].filter(isDefined4);
  return dictionaries;
}
function _getDictionaryInternal(settings, spellDictionaries) {
  const dictionaries = [...spellDictionaries, ...getInlineConfigDictionaries(settings)];
  return createCollection(dictionaries, "dictionary collection");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/clearCachedFiles.js
function clearCachedFiles() {
  return _clearCachedFiles();
}
function _clearCachedFiles() {
  dispatchClearCache();
  return refreshDictionaryCache(0).then(() => void 0);
}
function clearCaches() {
  clearCachedFiles().catch(() => {
  });
}

// node_modules/.pnpm/@cspell+filetypes@8.14.2/node_modules/@cspell/filetypes/dist/definitions.js
var definitions = [
  { id: "ada", extensions: [".adb", ".ads"] },
  { id: "apiblueprint", extensions: [".apib", ".apiblueprint"] },
  { id: "argdown", extensions: [".ad", ".adown", ".argdn", ".argdown"] },
  { id: "asciidoc", extensions: [".adoc", ".asc", ".asciidoc"] },
  { id: "bat", extensions: [".bat", ".cmd"] },
  { id: "bazel", extensions: [".bazel", ".bzl"] },
  { id: "bibtex", extensions: [".bib"] },
  { id: "bicep", extensions: [".bicep"] },
  { id: "c", extensions: [".c", ".i"] },
  { id: "cache_files", extensions: [], filenames: [".DS_Store", ".cspellcache", ".eslintcache"] },
  { id: "clojure", extensions: [".clj", ".cljc", ".cljs", ".cljx", ".clojure", ".edn"] },
  { id: "cmake", extensions: [".cmake"], filenames: ["CMakeLists.txt"] },
  { id: "coffeescript", extensions: [".coffee", ".cson", ".iced"] },
  {
    id: "cpp",
    extensions: [
      ".c++",
      ".c++m",
      ".cc",
      ".ccm",
      ".cpp",
      ".cppm",
      ".cxx",
      ".cxxm",
      ".h",
      ".h++",
      ".h.in",
      ".hh",
      ".hpp",
      ".hpp.in",
      ".hxx",
      ".ii",
      ".inl",
      ".ino",
      ".ipp",
      ".ixx",
      ".mm",
      ".tpp",
      ".txx"
    ]
  },
  { id: "cpp_embedded_latex", extensions: [] },
  { id: "csharp", extensions: [".cake", ".cs", ".csx"] },
  { id: "css", extensions: [".css"] },
  { id: "cuda-cpp", extensions: [".cu", ".cuh"] },
  { id: "dart", extensions: [".dart"] },
  { id: "dhall", extensions: [".dhall"] },
  { id: "diff", extensions: [".diff", ".patch", ".rej"] },
  { id: "dockercompose", extensions: [], filenames: ["*docker*compose*.yaml", "*docker*compose*.yml", "compose.*.yaml", "compose.*.yml", "compose.yaml", "compose.yml"] },
  {
    id: "dockerfile",
    extensions: [".containerfile", ".dockerfile"],
    filenames: ["*.Dockerfile.*", "Containerfile", "Containerfile.*", "Dockerfile", "Dockerfile.*", "Dockerfile.dev", "dockerfile"]
  },
  { id: "elisp", extensions: [".el"] },
  { id: "elixir", extensions: [".ex", ".exs"] },
  { id: "elm", extensions: [".elm"] },
  { id: "erb", extensions: [".erb", ".html.erb", ".rhtml"] },
  { id: "fsharp", extensions: [".fs", ".fsi", ".fsscript", ".fsx"] },
  { id: "git-commit", extensions: [], filenames: ["COMMIT_EDITMSG", "MERGE_MSG"] },
  { id: "git-rebase", extensions: [], filenames: ["git-rebase-todo"] },
  { id: "github-issues", extensions: [".github-issues"] },
  { id: "go", extensions: [".go"] },
  { id: "godot", extensions: [".gd", ".godot", ".tres", ".tscn"] },
  { id: "gradle", extensions: [".gradle"] },
  { id: "groovy", extensions: [".gradle", ".groovy", ".gvy", ".jenkinsfile", ".nf"], filenames: ["Jenkinsfile", "Jenkinsfile*"] },
  { id: "haml", extensions: [".haml"] },
  { id: "handlebars", extensions: [".handlebars", ".hbs", ".hjs"] },
  { id: "haskell", extensions: [".hs", ".lhs"] },
  { id: "haxe", extensions: [".hx"] },
  { id: "hlsl", extensions: [".cginc", ".compute", ".fx", ".fxh", ".hlsl", ".hlsli", ".psh", ".vsh"] },
  { id: "html", extensions: [".asp", ".aspx", ".ejs", ".htm", ".html", ".jshtm", ".jsp", ".mdoc", ".rhtml", ".shtml", ".volt", ".vue", ".xht", ".xhtml"] },
  { id: "ignore", extensions: [".git-blame-ignore-revs", ".gitignore", ".gitignore_global", ".npmignore"], filenames: [".vscodeignore"] },
  { id: "ini", extensions: [".conf", ".ini"] },
  { id: "jade", extensions: [".jade", ".pug"] },
  { id: "java", extensions: [".jav", ".java"] },
  { id: "javascript", extensions: [".cjs", ".es6", ".js", ".mjs", ".pac"], filenames: ["jakefile"] },
  { id: "javascriptreact", extensions: [".jsx"] },
  { id: "jinja", extensions: [".jinja"] },
  {
    id: "json",
    extensions: [
      ".babelrc",
      ".bowerrc",
      ".code-profile",
      ".css.map",
      ".eslintrc",
      ".geojson",
      ".har",
      ".ipynb",
      ".js.map",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      ".json",
      ".jsonc",
      ".jsonld",
      ".ts.map",
      ".tsbuildinfo",
      ".vuerc",
      ".webmanifest"
    ],
    filenames: [".watchmanconfig", "composer.lock"]
  },
  {
    id: "jsonc",
    extensions: [
      ".babelrc",
      ".code-workspace",
      ".color-theme.json",
      ".eslintrc",
      ".eslintrc.json",
      ".hintrc",
      ".icon-theme.json",
      ".jsfmtrc",
      ".jshintrc",
      ".jsonc",
      ".language-configuration.json",
      ".swcrc"
    ],
    filenames: [
      ".babelrc.json",
      ".code-workspace",
      ".devcontainer.json",
      ".ember-cli",
      "argv.json",
      "babel.config.json",
      "devcontainer.json",
      "extensions.json",
      "jsconfig-*.json",
      "jsconfig.*.json",
      "jsconfig.json",
      "keybindings.json",
      "launch.json",
      "profiles.json",
      "settings.json",
      "tasks.json",
      "tsconfig-*.json",
      "tsconfig.*.json",
      "tsconfig.json",
      "typedoc.json"
    ]
  },
  { id: "jsonl", extensions: [".jsonl"] },
  { id: "jsx-tags", extensions: [] },
  { id: "julia", extensions: [".jl"] },
  { id: "juliamarkdown", extensions: [".jmd"] },
  { id: "jungle", extensions: [".jungle"] },
  { id: "kotlin", extensions: [".kt"] },
  { id: "latex", extensions: [".ctx", ".ltx", ".tex"] },
  { id: "less", extensions: [".less"] },
  { id: "lisp", extensions: [".fasl", ".l", ".lisp", ".lsp"] },
  { id: "literate haskell", extensions: [".lhs"] },
  { id: "lock", extensions: [".lock"], filenames: ["Cargo.lock", "berksfile.lock", "composer.lock", "package-lock.json"] },
  { id: "log", extensions: [".log"], filenames: ["*.log.?"] },
  { id: "lua", extensions: [".lua"] },
  { id: "makefile", extensions: [".mak", ".mk"], filenames: ["GNUmakefile", "Makefile", "OCamlMakefile", "makefile"] },
  { id: "map", extensions: [".map", ".css.map", ".ts.map", ".js.map"] },
  { id: "markdown", extensions: [".markdn", ".markdown", ".md", ".mdown", ".mdtext", ".mdtxt", ".mdwn", ".mkd", ".workbook"] },
  { id: "markdown_latex_combined", extensions: [] },
  { id: "markdown-math", extensions: [] },
  { id: "mdx", extensions: [".mdx"] },
  { id: "monkeyc", extensions: [".mb", ".mc"] },
  { id: "mustache", extensions: [".mst", ".mu", ".mustache", ".stache"] },
  { id: "nix", extensions: [".nix"] },
  { id: "nunjucks", extensions: [".nj", ".njk", ".nunj", ".nunjs", ".nunjucks", ".tmpl", ".tpl"] },
  { id: "objective-c", extensions: [".m"] },
  { id: "objective-cpp", extensions: [".mm"] },
  { id: "ocaml", extensions: [".eliom", ".eliomi", ".ml", ".mli", ".mll", ".mly"] },
  { id: "pdf", extensions: [".pdf"] },
  { id: "pem", extensions: [".pem", ".private-key.pem"] },
  { id: "pem-private-key", extensions: [".private-key.pem"] },
  { id: "perl", extensions: [".PL", ".pl", ".pm", ".pod", ".psgi", ".t"] },
  { id: "perl6", extensions: [".nqp", ".p6", ".pl6", ".pm6"] },
  { id: "php", extensions: [".ctp", ".php", ".php4", ".php5", ".phtml"] },
  { id: "plaintext", extensions: [".txt"] },
  { id: "powershell", extensions: [".ps1", ".psd1", ".psm1", ".psrc", ".pssc"] },
  {
    id: "properties",
    extensions: [".cfg", ".conf", ".directory", ".editorconfig", ".gitattributes", ".gitconfig", ".gitmodules", ".npmrc", ".properties", ".repo"],
    filenames: [".env", "gitconfig"]
  },
  { id: "puppet", extensions: [".puppet"] },
  { id: "purescript", extensions: [".purs"] },
  { id: "python", extensions: [".cpy", ".gyp", ".gypi", ".ipy", ".py", ".pyi", ".pyt", ".pyw", ".rpy"], filenames: ["SConscript", "SConstruct"] },
  { id: "r", extensions: [".R", ".r", ".rhistory", ".rprofile", ".rt"] },
  { id: "raku", extensions: [".nqp", ".p6", ".pl6", ".pm6", ".raku", ".rakudoc", ".rakumod", ".rakutest"] },
  { id: "razor", extensions: [".cshtml", ".razor"] },
  { id: "rescript", extensions: [".res", ".resi"] },
  { id: "restructuredtext", extensions: [".rst"] },
  { id: "rsa", extensions: [".pub"], filenames: ["id_rsa", "id_rsa.pub"] },
  {
    id: "ruby",
    extensions: [".erb", ".gemspec", ".podspec", ".rake", ".rb", ".rbi", ".rbx", ".rjs", ".ru"],
    filenames: [
      "Gemfile",
      "appfile",
      "appraisals",
      "berksfile",
      "berksfile.lock",
      "brewfile",
      "capfile",
      "cheffile",
      "dangerfile",
      "deliverfile",
      "fastfile",
      "gemfile",
      "guardfile",
      "gymfile",
      "hobofile",
      "matchfile",
      "podfile",
      "puppetfile",
      "rakefile",
      "rantfile",
      "scanfile",
      "snapfile",
      "thorfile",
      "vagrantfile"
    ]
  },
  { id: "rust", extensions: [".rs"] },
  { id: "sass", extensions: [".sass"] },
  { id: "scala", extensions: [".sbt", ".sc", ".scala"] },
  { id: "scss", extensions: [".scss"] },
  { id: "search-result", extensions: [".code-search"] },
  { id: "shaderlab", extensions: [".cginc", ".shader"] },
  {
    id: "shellscript",
    extensions: [
      ".Xsession",
      ".bash",
      ".bash_aliases",
      ".bash_login",
      ".bash_logout",
      ".bash_profile",
      ".bashrc",
      ".csh",
      ".cshrc",
      ".ebuild",
      ".eclass",
      ".fish",
      ".install",
      ".ksh",
      ".profile",
      ".sh",
      ".tcshrc",
      ".xprofile",
      ".xsession",
      ".xsessionrc",
      ".yash_profile",
      ".yashrc",
      ".zlogin",
      ".zlogout",
      ".zprofile",
      ".zsh",
      ".zsh-theme",
      ".zshenv",
      ".zshrc"
    ],
    filenames: [".env.*", ".envrc", ".hushlogin", "APKBUILD", "PKGBUILD", "bashrc_Apple_Terminal", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc", "zshrc_Apple_Terminal"]
  },
  { id: "snippets", extensions: [".code-snippets"] },
  { id: "sql", extensions: [".dsql", ".sql"] },
  { id: "stylus", extensions: [".styl"] },
  { id: "svelte", extensions: [".svelte"] },
  { id: "swift", extensions: [".swift"] },
  { id: "terraform", extensions: [".hcl", ".tf", ".tf.json", ".tfvars"] },
  { id: "tex", extensions: [".bbx", ".cbx", ".cls", ".sty"] },
  { id: "tfvars", extensions: [".tfvars"], description: "Terraform Variables" },
  { id: "todo", extensions: [], filenames: ["todo"] },
  { id: "toml", extensions: [".toml"], filenames: ["Cargo.lock", "Cargo.toml"] },
  { id: "typescript", extensions: [".cts", ".mts", ".ts"] },
  { id: "typescriptreact", extensions: [".tsx"] },
  { id: "typst", extensions: [".typst"] },
  { id: "vala", extensions: [".vala"] },
  { id: "vb", extensions: [".bas", ".brs", ".vb", ".vba", ".vbs"] },
  { id: "vue", extensions: [".vue"] },
  {
    id: "xml",
    extensions: [
      ".ascx",
      ".atom",
      ".axaml",
      ".axml",
      ".bpmn",
      ".config",
      ".cpt",
      ".csl",
      ".csproj",
      ".csproj.user",
      ".dita",
      ".ditamap",
      ".dtd",
      ".dtml",
      ".ent",
      ".fsproj",
      ".fxml",
      ".iml",
      ".isml",
      ".jmx",
      ".launch",
      ".menu",
      ".mod",
      ".mxml",
      ".nuspec",
      ".opml",
      ".owl",
      ".proj",
      ".props",
      ".pt",
      ".publishsettings",
      ".pubxml",
      ".pubxml.user",
      ".rbxlx",
      ".rbxmx",
      ".rdf",
      ".rng",
      ".rss",
      ".shproj",
      ".storyboard",
      ".svg",
      ".targets",
      ".tld",
      ".tmx",
      ".vbproj",
      ".vbproj.user",
      ".vcxproj",
      ".vcxproj.filters",
      ".wsdl",
      ".wxi",
      ".wxl",
      ".wxs",
      ".xaml",
      ".xbl",
      ".xib",
      ".xlf",
      ".xliff",
      ".xml",
      ".xoml",
      ".xpdl",
      ".xsd",
      ".xul"
    ]
  },
  { id: "xsl", extensions: [".xsl", ".xslt"] },
  { id: "yaml", extensions: [".cff", ".eyaml", ".eyml", ".yaml", ".yaml-tmlanguage", ".yaml-tmpreferences", ".yaml-tmtheme", ".yml"] },
  { id: "binary", extensions: [".bin", ".cur", ".dll", ".eot", ".exe", ".gz", ".lib", ".o", ".obj", ".phar", ".zip"], format: "Binary" },
  { id: "dll", extensions: [".dll"], format: "Binary" },
  { id: "exe", extensions: [".exe"], format: "Binary" },
  { id: "fonts", extensions: [".ttf", ".woff", ".woff2"], format: "Binary" },
  { id: "gzip", extensions: [".gz"], format: "Binary" },
  {
    id: "image",
    extensions: [".bmp", ".exr", ".gif", ".heic", ".ico", ".jpeg", ".jpg", ".pbm", ".pgm", ".png", ".ppm", ".ras", ".sgi", ".tiff", ".webp", ".xbm"],
    format: "Binary",
    description: "Some image extensions"
  },
  { id: "jar", extensions: [".jar"], format: "Binary" },
  { id: "mdb", extensions: [".mdb"], format: "Binary", description: "Microsoft Access DB" },
  { id: "object-file", extensions: [".o", ".obj"], format: "Binary" },
  { id: "spv", extensions: [".spv"], format: "Binary", description: "SPSS Output Document" },
  { id: "trie", extensions: [".trie"], format: "Binary", description: "CSpell dictionary file." },
  { id: "video", extensions: [".avi", ".flv", ".mkv", ".mov", ".mp4", ".mpeg", ".mpg", ".wmv"], format: "Binary" },
  { id: "webm", extensions: [".webm"], format: "Binary", description: "WebM is an audiovisual media file format." },
  { id: "wheel", extensions: [".whl"], format: "Binary" }
];

// node_modules/.pnpm/@cspell+filetypes@8.14.2/node_modules/@cspell/filetypes/dist/filetypes.js
var binaryFormatIds = definitions.filter((d) => d.format === "Binary").map((d) => d.id);
var binaryLanguages = /* @__PURE__ */ new Set(["binary", "image", "video", "fonts", ...binaryFormatIds]);
var generatedFiles = /* @__PURE__ */ new Set([
  ...binaryLanguages,
  "map",
  "lock",
  "pdf",
  "cache_files",
  "rsa",
  "pem",
  "trie",
  "log"
]);
var languageIds = definitions.map(({ id }) => id);
var mapExtensionToSetOfLanguageIds = buildLanguageExtensionMapSet(definitions);
var mapExtensionToLanguageIds = buildExtensionToLanguageIdMap(mapExtensionToSetOfLanguageIds);
var idsWithRegExp = definitions.map(defToRegExp).filter((f) => !!f);
function isFileTypeGenerated(fileTypeId) {
  return doesSetContainAnyOf(generatedFiles, fileTypeId);
}
function doesSetContainAnyOf(setOfIds, fileTypeId) {
  if (typeof fileTypeId === "string") {
    return setOfIds.has(fileTypeId);
  }
  for (const id of fileTypeId) {
    if (setOfIds.has(id)) {
      return true;
    }
  }
  return false;
}
function buildLanguageExtensionMapSet(defs) {
  return defs.reduce((map3, def) => {
    var _a3;
    function addId(value) {
      autoResolve2(map3, value, () => /* @__PURE__ */ new Set()).add(def.id);
    }
    def.extensions.forEach(addId);
    (_a3 = def.filenames) == null ? void 0 : _a3.forEach((filename) => typeof filename === "string" ? addId(filename) : void 0);
    return map3;
  }, /* @__PURE__ */ new Map());
}
function buildExtensionToLanguageIdMap(map3) {
  return new Map([...map3].map(([k, s]) => [k, [...s]]));
}
function _getLanguagesForExt(ext) {
  return mapExtensionToLanguageIds.get(ext) || mapExtensionToLanguageIds.get("." + ext);
}
function getFileTypesForExt(ext) {
  return _getLanguagesForExt(ext) || _getLanguagesForExt(ext.toLowerCase()) || [];
}
function matchPatternsToFilename(basename5) {
  return idsWithRegExp.filter(({ regexp }) => regexp.test(basename5)).map(({ id }) => id);
}
function _getLanguagesForBasename(basename5) {
  const found = mapExtensionToLanguageIds.get(basename5);
  if (found)
    return found;
  const patternMatches = matchPatternsToFilename(basename5);
  if (patternMatches.length)
    return patternMatches;
  for (let pos = basename5.indexOf("."); pos >= 0; pos = basename5.indexOf(".", pos + 1)) {
    const ids = mapExtensionToLanguageIds.get(basename5.slice(pos));
    if (ids)
      return ids;
  }
  return void 0;
}
function findMatchingFileTypes(filename) {
  filename = basename2(filename);
  return _getLanguagesForBasename(filename) || _getLanguagesForBasename(filename.toLowerCase()) || [];
}
var regExpPathSep = /[\\/]/g;
function basename2(filename) {
  return regExpPathSep.test(filename) ? filename.split(regExpPathSep).slice(-1).join("") : filename;
}
function autoResolve2(map3, key, resolve3) {
  const found = map3.get(key);
  if (found !== void 0 || map3.has(key))
    return found;
  const value = resolve3(key);
  map3.set(key, value);
  return value;
}
function escapeRegEx2(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}
function stringOrGlob(s) {
  return s.includes("*") ? simpleGlob(s) : s;
}
function simpleGlob(s) {
  s = s.replaceAll("**", "*");
  let pattern = "";
  for (const char of s) {
    switch (char) {
      case "?": {
        pattern += ".";
        break;
      }
      case "*": {
        pattern += ".*";
        break;
      }
      default: {
        pattern += escapeRegEx2(char);
      }
    }
  }
  return new RegExp(pattern);
}
function defToRegExp(def) {
  if (!def.filenames)
    return void 0;
  const regExps = def.filenames.map(stringOrGlob).map((f) => f instanceof RegExp ? f : void 0).filter((f) => !!f);
  if (!regExps.length)
    return void 0;
  const regexp = new RegExp(regExps.map((r) => r.source).join("|"));
  return { regexp, id: def.id };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/Uri.js
var import_node_assert8 = __toESM(require("assert"), 1);
var import_node_url13 = require("url");

// node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 470: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
        if (h < t3.length) r3 = t3.charCodeAt(h);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o === h - 1 || 1 === s) ;
          else if (o !== h - 1 && 2 === s) {
            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a = n3.lastIndexOf("/");
                if (a !== n3.length - 1) {
                  -1 === a ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i = 0, o = h, s = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
          o = h, s = 0;
        } else 46 === r3 && -1 !== s ? ++s : s = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
        var s;
        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
      }
      return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i = arguments[r3];
        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
      for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h) ;
      for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {
        if (u === c) {
          if (a > c) {
            if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);
            if (0 === u) return r3.slice(h + u);
          } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
          break;
        }
        var l = t3.charCodeAt(i + u);
        if (l !== r3.charCodeAt(h + u)) break;
        47 === l && (f = u);
      }
      var g = "";
      for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
      return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
        if (!o) {
          i = s;
          break;
        }
      } else o = false;
      return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i = 0, o = -1, s = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h = r3.length - 1, a = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c = t3.charCodeAt(n3);
          if (47 === c) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));
        }
        return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s) {
          i = n3 + 1;
          break;
        }
      } else -1 === o && (s = false, o = n3 + 1);
      return -1 === o ? "" : t3.slice(i, o);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
        var a = t3.charCodeAt(h);
        if (47 !== a) -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
        else if (!o) {
          n3 = h + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i = t3.charCodeAt(0), o = 47 === i;
      o ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
      else if (!c) {
        h = f + 1;
        break;
      }
      return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i = e[n2];
    if (void 0 !== i) return i.exports;
    var o = e[n2] = { exports: {} };
    return t[n2](o, o.exports, r), o.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  (() => {
    let t2;
    if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), "object" == typeof process) t2 = "win32" === process.platform;
    else if ("object" == typeof navigator) {
      let e3 = navigator.userAgent;
      t2 = e3.indexOf("Windows") >= 0;
    }
    const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
    function s(t3, r2) {
      if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
      if (t3.scheme && !e2.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t3.path) {
        if (t3.authority) {
          if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class f {
      static isUri(t3) {
        return t3 instanceof f || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(t3, e3, r2, n2, i2, o2 = false) {
        "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {
          return t4 || e4 ? t4 : "file";
        }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
          switch (t4) {
            case "https":
            case "http":
            case "file":
              e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;
          }
          return e4;
        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
      }
      get fsPath() {
        return m(this, false);
      }
      with(t3) {
        if (!t3) return this;
        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
      }
      static parse(t3, e3 = false) {
        const r2 = c.exec(t3);
        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
      }
      static file(e3) {
        let r2 = h;
        if (t2 && (e3 = e3.replace(/\\/g, a)), e3[0] === a && e3[1] === a) {
          const t3 = e3.indexOf(a, 2);
          -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);
        }
        return new l("file", r2, e3, h, h);
      }
      static from(t3) {
        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
        return s(e3, true), e3;
      }
      toString(t3 = false) {
        return y(this, t3);
      }
      toJSON() {
        return this;
      }
      static revive(t3) {
        if (t3) {
          if (t3 instanceof f) return t3;
          {
            const e3 = new l(t3);
            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
          }
        }
        return t3;
      }
    }
    const u = t2 ? 1 : void 0;
    class l extends f {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
      }
      toString(t3 = false) {
        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
      }
      toJSON() {
        const t3 = { $mid: 1 };
        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
      }
    }
    const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function d(t3, e3, r2) {
      let n2, i2 = -1;
      for (let o2 = 0; o2 < t3.length; o2++) {
        const s2 = t3.charCodeAt(o2);
        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
        else {
          void 0 === n2 && (n2 = t3.substr(0, o2));
          const e4 = g[s2];
          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
        }
      }
      return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
    }
    function p(t3) {
      let e3;
      for (let r2 = 0; r2 < t3.length; r2++) {
        const n2 = t3.charCodeAt(r2);
        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
      }
      return void 0 !== e3 ? e3 : t3;
    }
    function m(e3, r2) {
      let n2;
      return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
    }
    function y(t3, e3) {
      const r2 = e3 ? p : d;
      let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
      if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a, n2 += a), o2) {
        let t4 = o2.indexOf("@");
        if (-1 !== t4) {
          const e4 = o2.substr(0, t4);
          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
        }
        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
      }
      if (s2) {
        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
          const t4 = s2.charCodeAt(1);
          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
          const t4 = s2.charCodeAt(0);
          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
        }
        n2 += r2(s2, true, false);
      }
      return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
    }
    function v(t3) {
      try {
        return decodeURIComponent(t3);
      } catch {
        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
      }
    }
    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function C(t3) {
      return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
    }
    var A = r(470);
    const w = A.posix || A, x = "/";
    var P;
    !function(t3) {
      t3.joinPath = function(t4, ...e3) {
        return t4.with({ path: w.join(t4.path, ...e3) });
      }, t3.resolvePath = function(t4, ...e3) {
        let r2 = t4.path, n2 = false;
        r2[0] !== x && (r2 = x + r2, n2 = true);
        let i2 = w.resolve(r2, ...e3);
        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
      }, t3.dirname = function(t4) {
        if (0 === t4.path.length || t4.path === x) return t4;
        let e3 = w.dirname(t4.path);
        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
      }, t3.basename = function(t4) {
        return w.basename(t4.path);
      }, t3.extname = function(t4) {
        return w.extname(t4.path);
      };
    }(P || (P = {}));
  })(), LIB = n;
})();
var { URI, Utils } = LIB;

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Models/TextDocument.js
var import_node_assert7 = __toESM(require("assert"), 1);
var TextDocumentImpl = class {
  languageId;
  locale;
  vsTextDoc;
  uri;
  constructor(uri, text, languageId, locale, version2) {
    this.languageId = languageId;
    this.locale = locale;
    const primaryLanguageId = typeof languageId === "string" ? languageId : languageId[0] || "plaintext";
    this.vsTextDoc = TextDocument.create(uri.toString(), primaryLanguageId, version2, text);
    this.uri = documentUriToURL(uri);
  }
  get version() {
    return this.vsTextDoc.version;
  }
  get text() {
    return this.vsTextDoc.getText();
  }
  positionAt(offset) {
    return this.vsTextDoc.positionAt(offset);
  }
  offsetAt(position) {
    return this.vsTextDoc.offsetAt(position);
  }
  lineAt(offset) {
    const position = this.vsTextDoc.positionAt(offset);
    return this.getLine(position.line);
  }
  getLine(lineNum) {
    const position = { line: lineNum, character: 0 };
    const end = { line: lineNum + 1, character: 0 };
    const range = {
      start: position,
      end
    };
    const lineOffset = this.vsTextDoc.offsetAt(position);
    const text = this.vsTextDoc.getText(range);
    return {
      text,
      offset: lineOffset,
      position
    };
  }
  /**
   * Iterate over the lines of a document one-by-one.
   * Changing the document between iterations can change the result
   */
  *getLines() {
    const range = {
      start: { line: 0, character: 0 },
      end: { line: 1, character: 0 }
    };
    while (this.vsTextDoc.offsetAt(range.end) > this.vsTextDoc.offsetAt(range.start)) {
      const offset = this.vsTextDoc.offsetAt(range.start);
      yield {
        text: this.vsTextDoc.getText(range),
        offset,
        position: range.start
      };
      ++range.start.line;
      ++range.end.line;
    }
  }
  /**
   * Apply edits to the text.
   * Note: the edits are applied one after the other.
   * @param edits - changes to the text
   * @param version - optional version to use.
   * @returns this
   */
  update(edits, version2) {
    version2 = version2 ?? this.version + 1;
    for (const edit of edits) {
      const vsEdit = edit.range ? {
        range: { start: this.positionAt(edit.range[0]), end: this.positionAt(edit.range[1]) },
        text: edit.text
      } : edit;
      TextDocument.update(this.vsTextDoc, [vsEdit], version2);
    }
    return this;
  }
};
function createTextDocument({ uri, content, languageId, locale, version: version2 }) {
  version2 = version2 ?? 1;
  uri = toUri(uri);
  languageId = languageId ?? findMatchingFileTypes(basename3(uri));
  languageId = languageId.length === 0 ? "text" : languageId;
  return new TextDocumentImpl(uri, content, languageId, locale, version2);
}
function updateTextDocument(doc, edits, version2) {
  (0, import_node_assert7.default)(isTextDocumentImpl(doc), "Unknown TextDocument type");
  return doc.update(edits, version2);
}
function isTextDocumentImpl(doc) {
  return doc instanceof TextDocumentImpl;
}
var isTextDocument = isTextDocumentImpl;
function documentUriToURL(uri) {
  return toURL(uri instanceof URL ? uri : typeof uri === "string" ? toFileURL(uri) : new URL(from(uri).toString()));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/Uri.js
var STDIN_PROTOCOL = "stdin:";
function toUri(uriOrFile) {
  if (UriImpl.isUri(uriOrFile))
    return uriOrFile;
  if (URI.isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (uriOrFile instanceof URL)
    return UriImpl.parse(uriOrFile.toString());
  if (isHRef(uriOrFile))
    return UriImpl.parse(uriOrFile.href);
  if (isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (isUrlLike(uriOrFile))
    return UriImpl.parse(uriOrFile);
  return UriImpl.file(normalizeDriveLetter(uriOrFile));
}
var isWindows3 = process.platform === "win32";
var hasDriveLetter = /^[a-zA-Z]:[\\/]/;
var rootUrl = (0, import_node_url13.pathToFileURL)("/");
function uriToFilePath(uri) {
  let url2 = documentUriToURL(uri);
  url2 = url2.protocol === "stdin:" ? new URL(url2.pathname, rootUrl) : url2;
  return toFilePathOrHref(url2);
}
function normalizeDriveLetter(path13) {
  return hasDriveLetter.test(path13) ? path13[0].toUpperCase() + path13.slice(1) : path13;
}
function isHRef(url2) {
  return !!url2 && typeof url2 === "object" && typeof url2.href === "string" || false;
}
function isUri(uri) {
  if (!uri || typeof uri !== "object")
    return false;
  if (UriImpl.isUri(uri))
    return true;
  if (URI.isUri(uri))
    return true;
  const u = uri;
  return typeof u.path === "string" && typeof u.scheme === "string";
}
function basename3(uri) {
  return Utils.basename(URI.from(uri));
}
function from(uri, ...parts) {
  return UriImpl.from(uri, ...parts);
}
var keys2 = ["scheme", "authority", "path", "query", "fragment"];
var UriImpl = class _UriImpl extends URI {
  constructor(uri) {
    super(uri.scheme, uri.authority, uri.path, uri.query, uri.fragment);
  }
  toString() {
    const path13 = encodeURI(this.path || "").replaceAll(/[#?]/g, (c) => `%${(c.codePointAt(0) || 0).toString(16)}`);
    const base = `${this.scheme}://${this.authority || ""}${path13}`;
    const query = this.query && `?${this.query}` || "";
    const fragment = this.fragment && `#${this.fragment}` || "";
    const url2 = base + query + fragment;
    return url2;
  }
  toJSON() {
    const { scheme, authority, path: path13, query, fragment } = this;
    return { scheme, authority, path: path13, query, fragment };
  }
  with(change) {
    const { scheme, authority, path: path13, query, fragment } = this;
    const u = { scheme, authority, path: path13, query, fragment };
    for (const key of keys2) {
      if (change[key] && typeof change[key] === "string") {
        u[key] = change[key];
      }
    }
    return new _UriImpl(u);
  }
  static isUri(uri) {
    return uri instanceof _UriImpl;
  }
  static from(uri, ...parts) {
    let u = new _UriImpl(uri);
    for (const part of parts) {
      u = u.with(part);
    }
    return u;
  }
  static parse(uri) {
    if (uri.startsWith(STDIN_PROTOCOL)) {
      return _UriImpl.from(parseStdinUri(uri));
    }
    const u = URI.parse(uri);
    return _UriImpl.from(u);
  }
  static file(filename) {
    if (!isWindows3 && hasDriveLetter.test(filename)) {
      filename = "/" + filename.replaceAll("\\", "/");
    }
    const url2 = toFileURL(filename);
    return _UriImpl.parse(url2.href);
  }
  static stdin(filePath = "") {
    return _UriImpl.from(_UriImpl.file(filePath), { scheme: "stdin" });
  }
};
function normalizeFilePath(path13) {
  return normalizeDriveLetter(path13.replaceAll("\\", "/"));
}
function parseStdinUri(uri) {
  (0, import_node_assert8.default)(uri.startsWith(STDIN_PROTOCOL));
  const idxSlash = STDIN_PROTOCOL.length;
  let idxSlashEnd = idxSlash;
  for (; uri[idxSlashEnd] === "/"; ++idxSlashEnd) {
  }
  const pathStart = idxSlashEnd;
  const iH = uri.indexOf("#", pathStart);
  const idxHash = iH > 0 ? iH : uri.length;
  const iQ = uri.indexOf("?", pathStart);
  const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
  const pathEnd = idxQ;
  const path13 = uri.slice(pathStart, pathEnd);
  const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : "";
  const hash = uri.slice(idxHash + 1);
  const pathPrefix = idxSlashEnd - idxSlash > 2 ? "/" : "";
  return {
    scheme: "stdin",
    path: pathPrefix + normalizeFilePath(decodeURI(path13)),
    query: decodeURI(query),
    fragment: decodeURI(hash)
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Document/normalizeLanguageIds.js
function normalizeLanguageIds(languageId) {
  return (Array.isArray(languageId) ? languageId.join(",") : languageId).split(",").map((s) => s.trim());
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Document/isBinaryDoc.js
function isBinaryDoc(document) {
  return isBinaryFile2(toUri(document.uri), document.languageId, document.text);
}
function isBinaryFile2(filename, languageId, text) {
  const filenameUri = toUri(filename);
  if (languageId) {
    const ids2 = normalizeLanguageIds(languageId);
    if (ids2.length)
      return isFileTypeGenerated(ids2);
  }
  const file = basename3(filenameUri);
  const ids = findMatchingFileTypes(file);
  if (ids.length)
    return isFileTypeGenerated(ids);
  return (text == null ? void 0 : text.slice(0, 1024).includes("\0")) || false;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Document/resolveDocument.js
var import_promises = require("fs/promises");
var defaultEncoding = "utf8";
function fileToDocument(file, text, languageId, locale) {
  return clean4({
    uri: toUri(file).toString(),
    text,
    languageId,
    locale
  });
}
async function fileToTextDocument(file) {
  return documentToTextDocument(await resolveDocument(fileToDocument(file)));
}
function documentToTextDocument(document) {
  const { uri, text: content, languageId, locale } = document;
  return createTextDocument({ uri, content, languageId, locale });
}
async function resolveDocumentToTextDocument(doc) {
  return documentToTextDocument(await resolveDocument(doc));
}
async function readDocument(filename, encoding = defaultEncoding) {
  const text = await (0, import_promises.readFile)(filename, encoding);
  const uri = toUri(filename).toString();
  return {
    uri,
    text
  };
}
function resolveDocument(document, encoding) {
  if (isDocumentWithText(document))
    return Promise.resolve(document);
  const uri = toUri(document.uri);
  if (uri.scheme !== "file") {
    throw new Error(`Unsupported schema: "${uri.scheme}", open "${uri.toString()}"`);
  }
  return readDocument(uriToFilePath(uri), encoding);
}
function isDocumentWithText(doc) {
  return doc.text !== void 0;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/exclusionHelper.js
var exclusionHelper_exports = {};
__export(exclusionHelper_exports, {
  extractGlobsFromExcludeFilesGlobMap: () => extractGlobsFromExcludeFilesGlobMap,
  generateExclusionFunctionForFiles: () => generateExclusionFunctionForFiles,
  generateExclusionFunctionForUri: () => generateExclusionFunctionForUri
});

// node_modules/.pnpm/cspell-glob@8.14.2/node_modules/cspell-glob/dist/globHelper.js
var Path2 = __toESM(require("path"), 1);
var { posix } = Path2;
var isGlobalPatternRegExp = /^!*[*]{2}/;
var fileUrlBuilder2 = new FileUrlBuilder();
var GlobPlaceHolders = {
  cwd: "${cwd}"
};
var GlobPatterns = {
  suffixAny: "/**",
  /**
   * Use as as suffix for a directory. Example `node_modules/` becomes `node_modules/**/*`.
   */
  suffixDir: "/**/*",
  prefixAny: "**/"
};
function isGlobPatternWithOptionalRoot(g) {
  return typeof g !== "string" && typeof g.glob === "string";
}
function isGlobPatternWithRoot(g) {
  if (typeof g === "string")
    return false;
  return typeof g.root === "string" && "isGlobalPattern" in g;
}
function isGlobPatternNormalized(g) {
  if (!isGlobPatternWithRoot(g))
    return false;
  const gr = g;
  return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
}
function isGlobPatternNormalizedToRoot(g, options) {
  if (!isGlobPatternNormalized(g))
    return false;
  return g.root === options.root;
}
function urlBuilder(path13 = Path2) {
  return path13 === Path2 ? fileUrlBuilder2 : new FileUrlBuilder({ path: path13 });
}
function normalizePattern(pattern, nested) {
  pattern = pattern.replace(/^(!!)+/, "");
  const isNeg = pattern.startsWith("!");
  const prefix = isNeg ? "!" : "";
  pattern = isNeg ? pattern.slice(1) : pattern;
  const patterns = nested ? normalizePatternNested(pattern) : normalizePatternGeneral(pattern);
  return patterns.map((p) => prefix + p);
}
function normalizePatternNested(pattern) {
  if (!pattern.includes("/")) {
    if (pattern === "**")
      return ["**"];
    return ["**/" + pattern, "**/" + pattern + "/**"];
  }
  const hasLeadingSlash = pattern.startsWith("/");
  pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
  if (pattern.endsWith("/")) {
    return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
  }
  if (pattern.endsWith("**")) {
    return [pattern];
  }
  return [pattern, pattern + "/**"];
}
function normalizePatternGeneral(pattern) {
  pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
  pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
  return [pattern];
}
function normalizeGlobPatterns(patterns, options) {
  function* normalize3() {
    for (const glob of patterns) {
      if (isGlobPatternNormalized(glob)) {
        yield isGlobPatternNormalizedToRoot(glob, options) ? glob : normalizeGlobToRoot(glob, options.root, options.nodePath || Path2);
        continue;
      }
      yield* normalizeGlobPattern(glob, options);
    }
  }
  return [...normalize3()];
}
function normalizeGlobPattern(g, options) {
  const { root, nodePath: path13 = Path2, nested } = options;
  const builder = urlBuilder(path13);
  const cwd = options.cwd ?? path13.resolve();
  const cwdUrl = builder.toFileDirURL(cwd);
  const rootUrl2 = builder.toFileDirURL(root, cwdUrl);
  const gIsGlobalPattern = isGlobPatternWithRoot(g) ? g.isGlobalPattern : void 0;
  g = !isGlobPatternWithOptionalRoot(g) ? { glob: g } : g;
  const gr = { ...g, root: g.root ?? root };
  const rawRoot = gr.root;
  const rawGlob = g.glob;
  gr.glob = trimGlob(g.glob);
  if (gr.glob.startsWith(GlobPlaceHolders.cwd)) {
    gr.glob = gr.glob.replace(GlobPlaceHolders.cwd, "");
    gr.root = GlobPlaceHolders.cwd;
  }
  if (gr.root.startsWith(GlobPlaceHolders.cwd)) {
    const relRoot = gr.root.replace(GlobPlaceHolders.cwd, "./");
    const r = builder.toFileDirURL(relRoot, cwdUrl);
    r.pathname = posix.normalize(r.pathname);
    gr.root = builder.urlToFilePathOrHref(r);
  }
  const isGlobalPattern = gIsGlobalPattern ?? isGlobalGlob(gr.glob);
  gr.root = builder.urlToFilePathOrHref(builder.toFileDirURL(gr.root, rootUrl2));
  const globs = normalizePattern(gr.glob, nested);
  return globs.map((glob) => ({ ...gr, glob, rawGlob, rawRoot, isGlobalPattern }));
}
function normalizeGlobToRoot(glob, root, path13) {
  const builder = urlBuilder(path13);
  glob = { ...glob };
  fixPatternRoot(glob, builder);
  const rootURL = builder.toFileDirURL(root);
  root = builder.urlToFilePathOrHref(rootURL);
  if (glob.root === root) {
    return glob;
  }
  const globRootUrl = builder.toFileDirURL(glob.root);
  const relFromRootToGlob = builder.relative(rootURL, globRootUrl);
  if (!relFromRootToGlob) {
    return glob;
  }
  if (glob.isGlobalPattern) {
    return { ...glob, root };
  }
  const relFromGlobToRoot = builder.relative(globRootUrl, rootURL);
  const globIsUnderRoot = isRelativeValueNested(relFromRootToGlob);
  const rootIsUnderGlob = isRelativeValueNested(relFromGlobToRoot);
  if (!globIsUnderRoot && !rootIsUnderGlob) {
    return glob;
  }
  const isNeg = glob.glob.startsWith("!");
  const g = isNeg ? glob.glob.slice(1) : glob.glob;
  const prefix = isNeg ? "!" : "";
  if (globIsUnderRoot) {
    const relGlob = relFromRootToGlob;
    return {
      ...glob,
      glob: prefix + posix.join(relGlob, g),
      root
    };
  }
  const rebasedGlob = rebaseGlob(g, nRel(relFromRootToGlob), nRel(relFromGlobToRoot));
  return rebasedGlob ? { ...glob, glob: prefix + rebasedGlob, root } : glob;
}
function nRel(rel) {
  return rel.endsWith("/") ? rel : rel + "/";
}
function isRelativeValueNested(rel) {
  return !rel || !(rel === ".." || rel.startsWith("../") || rel.startsWith("/"));
}
function rebaseGlob(glob, fromRootToGlob, fromGlobToRoot) {
  if (!fromGlobToRoot || fromGlobToRoot === "/")
    return glob;
  if (fromRootToGlob.startsWith("../") && !fromGlobToRoot.startsWith("../") && glob.startsWith("**"))
    return glob;
  fromRootToGlob = nRel(fromRootToGlob);
  fromGlobToRoot = nRel(fromGlobToRoot);
  const relToParts = fromRootToGlob.split("/");
  const relFromParts = fromGlobToRoot.split("/");
  if (glob.startsWith(fromGlobToRoot) && fromRootToGlob === "../".repeat(relToParts.length - 1)) {
    return glob.slice(fromGlobToRoot.length);
  }
  const lastRelIdx = relToParts.findIndex((s) => s !== "..");
  const lastRel = lastRelIdx < 0 ? relToParts.length : lastRelIdx;
  const globParts = [...relToParts.slice(lastRel).filter((a) => a), ...glob.split("/")];
  relToParts.length = lastRel;
  if (fromRootToGlob.startsWith("../") && relFromParts.length !== relToParts.length + 1) {
    return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
  }
  for (let i = 0; i < relFromParts.length && i < globParts.length; ++i) {
    const relSeg = relFromParts[i];
    const globSeg = globParts[i];
    if (!relSeg || globSeg === "**") {
      return globParts.slice(i).join("/");
    }
    if (relSeg !== globSeg && globSeg !== "*") {
      break;
    }
  }
  return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
}
function trimGlob(glob) {
  glob = globRemoveComment(glob);
  glob = trimGlobLeft(glob);
  glob = trimGlobRight(glob);
  return glob;
}
function globRemoveComment(glob) {
  return glob.replace(/(?<=^|\s)#.*/, "");
}
var spaces = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true
};
function trimGlobRight(glob) {
  const lenMin1 = glob.length - 1;
  let i = lenMin1;
  while (i >= 0 && glob[i] in spaces) {
    --i;
  }
  if (glob[i] === "\\") {
    ++i;
  }
  ++i;
  return i ? glob.slice(0, i) : "";
}
function trimGlobLeft(glob) {
  return glob.trimStart();
}
function isGlobalGlob(glob) {
  return isGlobalPatternRegExp.test(glob);
}
function rootToUrl(root, builder) {
  if (root.startsWith(GlobPlaceHolders.cwd)) {
    return new URL(builder.normalizeFilePathForUrl(root.replace(GlobPlaceHolders.cwd, ".")), builder.cwd);
  }
  return builder.toFileDirURL(root);
}
function fixPatternRoot(glob, builder) {
  if (glob.root.startsWith(GlobPlaceHolders.cwd)) {
    return glob;
  }
  glob.root = builder.urlToFilePathOrHref(rootToUrl(glob.root, builder));
  return glob;
}

// node_modules/.pnpm/cspell-glob@8.14.2/node_modules/cspell-glob/dist/GlobMatcher.js
var Path3 = __toESM(require("path"), 1);
var import_micromatch = __toESM(require_micromatch(), 1);
var traceMode = false;
var idGlobMatcher = 0;
var GlobMatcher = class {
  /**
   * @param filename full path of file to match against.
   * @returns a GlobMatch - information about the match.
   */
  matchEx;
  path;
  patterns;
  patternsNormalizedToRoot;
  /**
   * path or href of the root directory.
   */
  root;
  dot;
  options;
  /**
   * Instance ID
   */
  id;
  constructor(patterns, rootOrOptions, _nodePath) {
    this.id = idGlobMatcher++;
    const options = typeof rootOrOptions === "string" || rootOrOptions instanceof URL ? { root: rootOrOptions.toString() } : rootOrOptions ?? {};
    const mode = options.mode ?? "exclude";
    const isExcludeMode = mode !== "include";
    const nodePath = options.nodePath ?? _nodePath ?? Path3;
    this.path = nodePath;
    const cwd = options.cwd ?? nodePath.resolve();
    const dot = options.dot ?? isExcludeMode;
    const nested = options.nested ?? isExcludeMode;
    const nobrace = options.nobrace;
    const root = options.root ?? nodePath.resolve();
    const builder = new FileUrlBuilder({ path: nodePath });
    const rootURL = builder.toFileDirURL(root);
    const normalizedRoot = builder.urlToFilePathOrHref(rootURL);
    this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
    patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
    const globPatterns = normalizeGlobPatterns(patterns, this.options);
    this.patternsNormalizedToRoot = globPatterns.map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath)).filter((g) => builder.relative(builder.toFileDirURL(g.root), rootURL) === "");
    this.patterns = globPatterns;
    this.root = normalizedRoot;
    this.dot = dot;
    this.matchEx = buildMatcherFn(this.id, this.patterns, this.options);
  }
  /**
   * Check to see if a filename matches any of the globs.
   * If filename is relative, it is considered relative to the root.
   * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
   * If filename is absolute and not contained within the root, it will be tested as is.
   * @param filename full path of the file to check.
   */
  match(filename) {
    return this.matchEx(filename).matched;
  }
};
function buildMatcherFn(_id, patterns, options) {
  const { nodePath, dot, nobrace } = options;
  const builder = new FileUrlBuilder({ path: nodePath });
  const makeReOptions = { dot, nobrace };
  const suffixDir = GlobPatterns.suffixDir;
  const rules = patterns.map((pattern, index) => ({ pattern, index })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
    const matchNeg = pattern.glob.match(/^!/);
    const glob = pattern.glob.replace(/^!/, "");
    const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
    const reg = import_micromatch.default.makeRe(glob, makeReOptions);
    const fn2 = pattern.glob.endsWith(suffixDir) ? (filename) => {
      return reg.test(filename) || filename.endsWith("/") && reg.test(filename + " ");
    } : (filename) => {
      return reg.test(filename);
    };
    return { pattern, index, isNeg, fn: fn2, reg };
  });
  const negRules = rules.filter((r) => r.isNeg);
  const posRules = rules.filter((r) => !r.isNeg);
  const mapRoots = /* @__PURE__ */ new Map();
  const fn = (filename) => {
    const fileUrl = builder.toFileURL(filename);
    const relFilePathname = builder.relative(new URL("file:///"), fileUrl);
    let lastRoot = new URL("placeHolder://");
    let lastRel = "";
    function rootToUrl2(root) {
      const found = mapRoots.get(root);
      if (found)
        return found;
      const url2 = builder.toFileDirURL(root);
      mapRoots.set(root, url2);
      return url2;
    }
    function relativeToRoot(root) {
      if (root.href !== lastRoot.href) {
        lastRoot = root;
        lastRel = builder.relative(root, fileUrl);
      }
      return lastRel;
    }
    function testRules(rules2, matched) {
      for (const rule of rules2) {
        const pattern = rule.pattern;
        const root = pattern.root;
        const rootURL = rootToUrl2(root);
        const isRelPat = !pattern.isGlobalPattern;
        let fname = relFilePathname;
        if (isRelPat) {
          const relPathToFile = relativeToRoot(rootURL);
          if (!isRelativeValueNested(relPathToFile)) {
            continue;
          }
          fname = relPathToFile;
        }
        if (rule.fn(fname)) {
          return {
            matched,
            glob: pattern.glob,
            root,
            pattern,
            index: rule.index,
            isNeg: rule.isNeg
          };
        }
      }
    }
    const result = testRules(negRules, false) || testRules(posRules, true) || { matched: false };
    traceMode && logMatchTest(_id, filename, result);
    return result;
  };
  return fn;
}
function logMatchTest(id, filename, match2) {
  console.warn("%s;%d;%s", filename, id, JSON.stringify(match2.matched));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/exclusionHelper.js
var defaultAllowedSchemes = /* @__PURE__ */ new Set(["file", "untitled"]);
function extractGlobsFromExcludeFilesGlobMap(globMap) {
  const globs = Object.getOwnPropertyNames(globMap).filter((glob) => globMap[glob]);
  return globs;
}
var leadingGlobPattern = /^\*\*\/([^/*{}]+)$/;
function adjustGlobPatternForBackwardsCompatibility(g) {
  return g.replace(leadingGlobPattern, "**/{$1,$1/**}");
}
function adjustGlobPatternsForBackwardsCompatibility(globs) {
  return globs.map((g) => {
    if (typeof g === "string") {
      return adjustGlobPatternForBackwardsCompatibility(g);
    }
    return { ...g, glob: adjustGlobPatternForBackwardsCompatibility(g.glob) };
  });
}
function generateExclusionFunctionForUri(globs, root, allowedSchemes = defaultAllowedSchemes) {
  const adjustedGlobs = adjustGlobPatternsForBackwardsCompatibility(globs);
  const matchFn = generateExclusionFunctionForFiles(adjustedGlobs, root);
  function testUri(uri) {
    if (!allowedSchemes.has(uri.scheme)) {
      return true;
    }
    return matchFn(uri.scheme === "file" || uri.scheme === "stdin" ? uriToFilePath(uri) : uri.path);
  }
  function testUriPath(uriPath) {
    const uri = toUri(uriPath);
    return testUri(uri);
  }
  return testUriPath;
}
function generateExclusionFunctionForFiles(globs, root) {
  const matcher = new GlobMatcher(globs, { root, dot: true });
  return (file) => matcher.match(file);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/FeatureFlags/FeatureFlags.js
var systemFeatureFlags;
var FeatureFlags = class {
  flags;
  flagValues = /* @__PURE__ */ new Map();
  constructor(flags = []) {
    this.flags = new Map(flags.map((f) => [f.name, f]));
  }
  register(flagOrName, description) {
    if (typeof flagOrName === "string") {
      return this.register({ name: flagOrName, description: description || "" });
    }
    this.flags.set(flagOrName.name, flagOrName);
    return this;
  }
  getFlag(flag) {
    return this.flagValues.get(flag);
  }
  getFlagBool(flag) {
    return toBool(this.getFlag(flag));
  }
  setFlag(flag, value = true) {
    if (!this.flags.has(flag)) {
      throw new UnknownFeatureFlagError(flag);
    }
    this.flagValues.set(flag, value);
    return this;
  }
  getFlagInfo(flag) {
    return this.flags.get(flag);
  }
  getFlags() {
    return [...this.flags.values()];
  }
  getFlagValues() {
    return new Map(this.flagValues);
  }
  reset() {
    this.flagValues.clear();
    return this;
  }
};
var UnknownFeatureFlagError = class extends Error {
  flag;
  constructor(flag) {
    super(`Unknown feature flag: ${flag}`);
    this.flag = flag;
  }
};
function getSystemFeatureFlags() {
  return systemFeatureFlags || (systemFeatureFlags = new FeatureFlags());
}
var boolValues = {
  0: false,
  1: true,
  f: false,
  false: false,
  n: false,
  no: false,
  t: true,
  true: true,
  y: true,
  yes: true
};
function toBool(value) {
  if (typeof value !== "string")
    return value;
  return boolValues[value.toLowerCase()];
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var import_node_assert9 = __toESM(require("assert"), 1);
var import_node_url14 = require("url");

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/constants.js
var configSettingsFileVersion0_1 = "0.1";
var configSettingsFileVersion0_2 = "0.2";
var currentSettingsFileVersion = configSettingsFileVersion0_2;
var ENV_CSPELL_GLOB_ROOT = "CSPELL_GLOB_ROOT";
var defaultConfigFileModuleRef = "@cspell/cspell-bundled-dicts/cspell-default.json";

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/mergeCache.js
var CalcLeftRightResultWeakCache = class {
  map = new AutoResolveWeakCache2();
  _toDispose;
  constructor() {
    this._toDispose = onClearCache(() => {
      this.clear();
    });
  }
  get(left, right, calc) {
    const m = this.map.get(left, () => new AutoResolveWeakCache2());
    return m.get(right, () => calc(left, right));
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    var _a3;
    this.map.dispose();
    (_a3 = this._toDispose) == null ? void 0 : _a3.dispose();
    this._toDispose = void 0;
  }
  stats() {
    return this.map.stats();
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/mergeList.js
var cacheMergeListUnique = new CalcLeftRightResultWeakCache();
var cacheMergeLists = new CalcLeftRightResultWeakCache();
function mergeListUnique(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!right.length)
    return left;
  if (!left.length)
    return right;
  const result = cacheMergeListUnique.get(left, right, (left2, right2) => [.../* @__PURE__ */ new Set([...left2, ...right2])]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function mergeList(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!left.length)
    return right;
  if (!right.length)
    return left;
  const result = cacheMergeLists.get(left, right, (left2, right2) => [...left2, ...right2]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function stats() {
  return {
    cacheMergeListUnique: cacheMergeListUnique.stats(),
    cacheMergeLists: cacheMergeLists.stats()
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/textRegex.js
var regExUpperSOrIng = new RegExp("([\\p{Lu}\\p{M}]+(?:\\\\?['\u2019])?(?:s|ing|ies|es|ings|ed|ning))(?!\\p{Ll})", "gu");
var regExSplitWords = new RegExp("(\\p{Ll}\\p{M}?)(\\p{Lu})", "gu");
var regExSplitWords2 = new RegExp("(\\p{Lu}\\p{M}?)((\\p{Lu}\\p{M}?)\\p{Ll})", "gu");
var regExpCamelCaseWordBreaksWithEnglishSuffix = new RegExp("(?<=\\p{Ll}\\p{M}?)(?=\\p{Lu})|(?<=\\p{Lu}\\p{M}?)(?=\\p{Lu}\\p{M}?\\p{Ll})(?!\\p{Lu}\\p{M}?(?:s|ing|ies|es|ings|ed|ning)(?!\\p{Ll}))", "gu");
var regExpCamelCaseWordBreaks = new RegExp("(?<=\\p{Ll}\\p{M}?)(?=\\p{Lu})|(?<=\\p{Lu}\\p{M}?)(?=\\p{Lu}\\p{M}?\\p{Ll})", "gu");
var regExpAllPossibleWordBreaks = new RegExp("(?<=\\p{Ll}\\p{M}?)(?=\\p{Lu})|(?<=\\p{Lu}\\p{M}?)(?=\\p{Lu}\\p{M}?\\p{Ll})|(?<=\\p{Lu}\\p{M}?\\p{Lu}\\p{M}?)(?=\\p{Ll})|(?<=\\p{L}\\p{M}?)(?=\\P{L})|(?<=\\P{L})(?=\\p{L})", "gu");
var regExWords = new RegExp("\\p{L}\\p{M}?(?:(?:\\\\?['\u2019])?\\p{L}\\p{M}?)*", "gu");
var regExWordsAndDigits = /[\p{L}\w'`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'`.+-])*/gu;
var regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
var regExFirstUpper2 = new RegExp("^\\p{Lu}\\p{M}?\\p{Ll}+$", "u");
var regExAllUpper2 = new RegExp("^(?:\\p{Lu}\\p{M}?)+$", "u");
var regExAllLower2 = new RegExp("^(?:\\p{Ll}\\p{M}?)+$", "u");
var regExPossibleWordBreaks = /[-+_'`.\s]/g;
var regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
var regExAccents2 = new RegExp("\\p{M}", "gu");
var regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
var regExDanglingQuote = new RegExp("(?<=(?:^|(?!\\p{M})\\P{L})(?:\\p{L}\\p{M}?)?)[']", "gu");
var regExTrailingEndings = new RegExp("(?<=(?:\\p{Lu}\\p{M}?){2})['\u2019]?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\\p{Ll})", "gu");
var regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
function stringToRegExp(pattern, defaultFlags = "gimu", forceFlags = "g") {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  try {
    const [, pat, flag] = [
      ...pattern.match(regExMatchRegExParts) || ["", pattern.trim(), defaultFlags],
      forceFlags
    ];
    if (pat) {
      const regPattern = flag.includes("x") ? removeVerboseFromRegExp(pat) : pat;
      const flags = [...new Set(forceFlags + flag)].join("").replaceAll(/[^gimuy]/g, "");
      const regex = new RegExp(regPattern, flags);
      return regex;
    }
  } catch {
  }
  return void 0;
}
var SPACES = {
  " ": true,
  "\n": true,
  "\r": true,
  "	": true
};
function removeVerboseFromRegExp(pattern) {
  function escape(acc) {
    const char = pattern[acc.idx];
    if (char !== "\\")
      return void 0;
    const next = pattern[++acc.idx];
    acc.idx++;
    if (next === "#") {
      acc.result += "#";
      return acc;
    }
    if (!(next in SPACES)) {
      acc.result += "\\" + next;
      return acc;
    }
    acc.result += next;
    if (next === "\r" && pattern[acc.idx] === "\n") {
      acc.result += "\n";
      acc.idx++;
    }
    return acc;
  }
  function braces(acc) {
    const char = pattern[acc.idx];
    if (char !== "[")
      return void 0;
    acc.result += char;
    acc.idx++;
    let escCount = 0;
    while (acc.idx < pattern.length) {
      const char2 = pattern[acc.idx];
      acc.result += char2;
      acc.idx++;
      if (char2 === "]" && !(escCount & 1))
        break;
      escCount = char2 === "\\" ? escCount + 1 : 0;
    }
    return acc;
  }
  function spaces2(acc) {
    const char = pattern[acc.idx];
    if (!(char in SPACES))
      return void 0;
    acc.idx++;
    return acc;
  }
  function comments(acc) {
    const char = pattern[acc.idx];
    if (char !== "#")
      return void 0;
    while (acc.idx < pattern.length && pattern[acc.idx] !== "\n") {
      acc.idx++;
    }
    return acc;
  }
  function copy(acc) {
    const char = pattern[acc.idx++];
    acc.result += char;
    return acc;
  }
  const reducers = [escape, braces, spaces2, comments, copy];
  const result = { idx: 0, result: "" };
  while (result.idx < pattern.length) {
    for (const r of reducers) {
      if (r(result))
        break;
    }
  }
  return result.result;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/patterns.js
var emptyRegExpList = [];
var emptyPatternDefinitions = [];
var cache3 = new CalcLeftRightResultWeakCache();
function resolvePatterns(regExpList = emptyRegExpList, patternDefinitions = emptyPatternDefinitions) {
  return cache3.get(regExpList, patternDefinitions, _resolvePatterns);
}
function _resolvePatterns(regExpList, patternDefinitions) {
  const patternMap = new Map(patternDefinitions.map((def) => [def.name.toLowerCase(), def.pattern]));
  const resolved = /* @__PURE__ */ new Set();
  function resolvePattern(p) {
    if (resolved.has(p))
      return void 0;
    resolved.add(p);
    return patternMap.get(p.toString().toLowerCase()) || p;
  }
  function* flatten2(patterns) {
    for (const pattern of patterns) {
      if (Array.isArray(pattern)) {
        yield* flatten2(pattern.map(resolvePattern).filter(isDefined4));
      } else {
        yield pattern;
      }
    }
  }
  const patternList = regExpList.map(resolvePattern).filter(isDefined4);
  const result = [...flatten2(patternList)].map(toRegExp).filter(isDefined4);
  Object.freeze(regExpList);
  Object.freeze(patternDefinitions);
  Object.freeze(result);
  return result;
}
function toRegExp(pattern) {
  return pattern instanceof RegExp ? new RegExp(pattern) : stringToRegExp(pattern, "gim", "g");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var emptyWords2 = [];
Object.freeze(emptyWords2);
var cachedMerges = new AutoResolveWeakCache2();
var mergeCache = new AutoResolveWeakCache2();
var cacheInternalSettings = new AutoResolveWeakCache2();
var parserCache = new AutoResolveWeakCache2();
var emptyParserMap = /* @__PURE__ */ new Map();
onClearCache(() => {
  parserCache.clear();
  emptyParserMap.clear();
  cachedMerges.clear();
  mergeCache.clear();
  cacheInternalSettings.clear();
});
function _mergeWordsCached(left, right) {
  const map3 = autoResolveWeak2(cachedMerges, left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak2(map3, right, () => [...left, ...right]);
}
function mergeWordsCached(left, right) {
  if (!Array.isArray(left) || !left.length) {
    return Array.isArray(right) ? right.length ? right : emptyWords2 : void 0;
  }
  if (!Array.isArray(right) || !right.length)
    return left;
  return _mergeWordsCached(left, right);
}
function mergeObjects(left, right) {
  if (!left || typeof left !== "object")
    return !right || typeof right !== "object" ? void 0 : right;
  if (!right || typeof right !== "object")
    return left;
  return { ...left, ...right };
}
function replaceIfNotEmpty(left = [], right = []) {
  const filtered = right.filter((a) => !!a);
  if (filtered.length) {
    return filtered;
  }
  return left;
}
function mergeSettings(left, ...settings) {
  const rawSettings = settings.filter(isDefined4).reduce(merge2, toInternalSettings(left));
  return clean4(rawSettings);
}
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
function merge2(left, right) {
  const map3 = mergeCache.get(left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak2(map3, right, () => _merge(left, right));
}
function _merge(left, right) {
  const _left = toInternalSettings(left);
  const _right = toInternalSettings(right);
  if (left === right) {
    return _left;
  }
  if (isEmpty(right)) {
    return _left;
  }
  if (isEmpty(left)) {
    return _right;
  }
  if (isLeftAncestorOfRight(_left, _right)) {
    return _right;
  }
  if (doesLeftHaveRightAncestor(_left, _right)) {
    return _left;
  }
  const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
  const optionals = (includeRegExpList == null ? void 0 : includeRegExpList.length) ? { includeRegExpList } : {};
  const version2 = max3(_left.version, _right.version);
  const valuesToClear = {
    name: void 0,
    id: void 0,
    description: void 0,
    globRoot: void 0,
    import: void 0,
    __importRef: void 0
  };
  const settings = cleanCSpellSettingsInternal({
    ..._left,
    ..._right,
    ...optionals,
    ...valuesToClear,
    version: version2,
    words: mergeWordsCached(_left.words, _right.words),
    userWords: mergeWordsCached(_left.userWords, _right.userWords),
    flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
    ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
    suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
    enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
    enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
    enabledFileTypes: mergeObjects(_left.enabledFileTypes, _right.enabledFileTypes),
    ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
    patterns: mergeListUnique(_left.patterns, _right.patterns),
    dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
    dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
    noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
    languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
    enabled: _right.enabled !== void 0 ? _right.enabled : _left.enabled,
    files: mergeListUnique(_left.files, _right.files),
    ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version2),
    overrides: versionBasedMergeList(_left.overrides, _right.overrides, version2),
    features: mergeObjects(_left.features, _right.features),
    source: mergeSources(_left, _right),
    plugins: mergeList(_left.plugins, _right.plugins),
    __imports: mergeImportRefs(_left, _right)
  });
  return settings;
}
function versionBasedMergeList(left, right, version2) {
  if (version2 === configSettingsFileVersion0_1) {
    return takeRightOtherwiseLeft(left, right);
  }
  return mergeListUnique(left, right);
}
function isLeftAncestorOfRight(left, right) {
  return hasAncestor(right, left, 0);
}
function doesLeftHaveRightAncestor(left, right) {
  return hasAncestor(left, right, 1);
}
function hasAncestor(s, ancestor, side) {
  var _a3;
  const sources = (_a3 = s.source) == null ? void 0 : _a3.sources;
  if (!sources)
    return false;
  const i = side ? sources.length - 1 : 0;
  const src = sources[i];
  return src === ancestor || src && hasAncestor(src, ancestor, side) || false;
}
function mergeInDocSettings(left, right) {
  const merged = {
    ...mergeSettings(left, right),
    includeRegExpList: mergeListUnique(left.includeRegExpList, right.includeRegExpList)
  };
  return clean4(merged);
}
function takeRightOtherwiseLeft(left, right) {
  if (right == null ? void 0 : right.length) {
    return right;
  }
  return left || right;
}
function finalizeSettings(settings) {
  return _finalizeSettings(toInternalSettings(settings));
}
function _finalizeSettings(settings) {
  const finalized = {
    ...settings,
    finalized: true,
    ignoreRegExpList: resolvePatterns(settings.ignoreRegExpList, settings.patterns),
    includeRegExpList: resolvePatterns(settings.includeRegExpList, settings.patterns),
    parserFn: resolveParser(settings)
  };
  finalized.name = "Finalized " + (finalized.name || "");
  finalized.source = { name: settings.name || "src", sources: [settings] };
  return finalized;
}
function toInternalSettings(settings) {
  if (settings === void 0)
    return void 0;
  if (isCSpellSettingsInternal(settings))
    return settings;
  return cacheInternalSettings.get(settings, _toInternalSettings);
}
function _toInternalSettings(settings) {
  var _a3, _b;
  const { dictionaryDefinitions: defs, ...rest } = settings;
  const dictionaryDefinitions = mapDictDefsToInternal(defs, ((_a3 = settings.source) == null ? void 0 : _a3.filename) && toFileUrl((_b = settings.source) == null ? void 0 : _b.filename) || resolveCwd());
  const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
  return cleanCSpellSettingsInternal(setting);
}
function mergeSources(left, right) {
  return {
    name: "merged",
    sources: [left, right]
  };
}
function max3(a, b) {
  if (a === void 0 || a === null)
    return b;
  if (b === void 0 || b === null)
    return a;
  return a > b ? a : b;
}
function getSources(settings) {
  const visited = /* @__PURE__ */ new Set();
  const sources = [];
  function _walkSourcesTree(settings2) {
    var _a3, _b;
    if (!settings2 || visited.has(settings2))
      return;
    visited.add(settings2);
    if (!((_b = (_a3 = settings2.source) == null ? void 0 : _a3.sources) == null ? void 0 : _b.length)) {
      sources.push(settings2);
      return;
    }
    settings2.source.sources.forEach(_walkSourcesTree);
  }
  _walkSourcesTree(settings);
  return sources;
}
function mergeImportRefs(left, right = {}) {
  var _a3;
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = ((_a3 = right.__imports) == null ? void 0 : _a3.values()) || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : void 0;
}
function extractDependencies(settings) {
  const settingsI = toInternalSettings(settings);
  const configFiles = [...mergeImportRefs(settingsI) || []].map(([filename]) => filename);
  const dictionaryFiles = calcDictionaryDefsToLoad(settingsI).map((dict) => dict.path).filter((file) => !!file);
  return {
    configFiles,
    dictionaryFiles
  };
}
function resolveCwd() {
  const envGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
  const cwd = envGlobRoot || process.cwd();
  return (0, import_node_url14.pathToFileURL)(cwd);
}
function resolveParser(settings) {
  if (!settings.parser)
    return void 0;
  if (typeof settings.parser === "function")
    return settings.parser;
  const parserName = settings.parser;
  (0, import_node_assert9.default)(typeof parserName === "string");
  const parsers3 = extractParsers(settings.plugins);
  const parser2 = parsers3.get(parserName);
  (0, import_node_assert9.default)(parser2, `Parser "${parserName}" not found.`);
  return parser2;
}
function* parsers(plugins) {
  for (const plugin of plugins) {
    if (!plugin.parsers)
      continue;
    for (const parser2 of plugin.parsers) {
      yield [parser2.name, parser2];
    }
  }
}
function mapPlugins(plugins) {
  return new Map(parsers(plugins));
}
function extractParsers(plugins) {
  if (!plugins || !plugins.length)
    return emptyParserMap;
  return parserCache.get(plugins, mapPlugins);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/getDictionary.js
async function getDictionary(settings) {
  return getDictionaryInternal(toInternalSettings(settings));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/perf/timer.js
function createPerfTimer2(name, onEnd, timeNowFn) {
  return new SimpleTimer(name, onEnd, timeNowFn);
}
var SimpleTimer = class {
  name;
  onEnd;
  timeNowFn;
  _start = performance.now();
  _elapsed = void 0;
  _running = true;
  constructor(name, onEnd, timeNowFn = performance.now) {
    this.name = name;
    this.onEnd = onEnd;
    this.timeNowFn = timeNowFn;
  }
  get startTime() {
    return this._start;
  }
  get elapsed() {
    return this._elapsed ?? performance.now() - this._start;
  }
  end() {
    var _a3;
    if (!this._running)
      return;
    this._running = false;
    const end = performance.now();
    this._elapsed = end - this._start;
    (_a3 = this.onEnd) == null ? void 0 : _a3.call(this, this._elapsed, this.name);
  }
  start() {
    this._start = performance.now();
    this._running = true;
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/globs/getGlobMatcher.js
var simpleGlobCache = /* @__PURE__ */ new Map();
var globCache = /* @__PURE__ */ new WeakMap();
onClearCache(() => {
  globCache = /* @__PURE__ */ new WeakMap();
  simpleGlobCache.clear();
});
var emptyIgnorePaths = [];
function getGlobMatcherForExcluding(glob) {
  if (!glob || Array.isArray(glob) && !glob.length)
    return getGlobMatcherGlobGlob(emptyIgnorePaths);
  return typeof glob === "string" ? getGlobMatcherGlobString(glob) : getGlobMatcherGlobGlob(glob);
}
function getGlobMatcherGlobString(glob) {
  const cached = simpleGlobCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  simpleGlobCache.set(glob, m);
  return m;
}
function getGlobMatcherGlobGlob(glob) {
  const cached = globCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  globCache.set(glob, m);
  return m;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/globs/checkFilenameMatchesGlob.js
function checkFilenameMatchesExcludeGlob(filename, globs) {
  const m = getGlobMatcherForExcluding(globs);
  return m.match(filename);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/calcOverrideSettings.js
function calcOverrideSettings(settings, filename) {
  const _settings = toInternalSettings(settings);
  const overrides = _settings.overrides || [];
  const result = overrides.filter((override) => checkFilenameMatchesExcludeGlob(filename, override.filename)).reduce((settings2, override) => mergeSettings(settings2, override), _settings);
  return result;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
var import_node_assert10 = __toESM(require("assert"), 1);
var import_node_path10 = __toESM(require("path"), 1);
var import_node_url19 = require("url");

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
var import_posix = require("path/posix");

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/defaultNext.js
var defaultNextDeserializer = (content) => {
  throw new Error(`Unable to parse config file: "${content.url}"`);
};
var defaultNextSerializer = (file) => {
  throw new Error(`Unable to serialize config file: "${file.url}"`);
};

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/middlewareHelper.js
function getDeserializer(middleware) {
  let next = defaultNextDeserializer;
  for (const des of middleware) {
    next = curryDeserialize(des, next);
  }
  return next;
}
function getSerializer(middleware) {
  let next = defaultNextSerializer;
  for (const des of middleware) {
    next = currySerialize(des, next);
  }
  return next;
}
function curryDeserialize(middle, next) {
  return (content) => middle.deserialize(content, next);
}
function currySerialize(middle, next) {
  return (cfg) => middle.serialize(cfg, next);
}
function curryLoader(loader2, next) {
  return (req) => loader2.load(req, next);
}
async function defaultLoader(req) {
  const { io, deserialize } = req.context;
  const url2 = req.url;
  const file = await io.readFile(url2);
  return deserialize(file);
}
function getLoader(loaders2) {
  let next = defaultLoader;
  for (const loader2 of loaders2) {
    next = curryLoader(loader2, next);
  }
  return next;
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/util/toURL.js
function toURL3(url2) {
  return typeof url2 === "string" ? new URL(url2) : url2;
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
var CSpellConfigFileReaderWriterImpl = class {
  io;
  middleware;
  loaders;
  /**
   * @param io - an optional injectable IO interface. The default is to use the file system.
   * @param deserializers - Additional deserializers to use when reading a config file. The order of the deserializers is
   *    important. The last one in the list will be the first one to be called.
   */
  constructor(io, middleware, loaders2) {
    this.io = io;
    this.middleware = middleware;
    this.loaders = loaders2;
  }
  _untrustedExtensions = /* @__PURE__ */ new Set();
  _trustedUrls = [];
  /**
   * Untrusted extensions are extensions that are not trusted to be loaded from a file system.
   * Extension are case insensitive and should include the leading dot.
   */
  get untrustedExtensions() {
    return [...this._untrustedExtensions];
  }
  /**
   * Urls starting with these urls are trusted to be loaded from a file system.
   */
  get trustedUrls() {
    return [...this._trustedUrls].map((url2) => new URL(url2));
  }
  readConfig(uri) {
    const url2 = new URL(uri);
    if (!isTrusted(url2, this._trustedUrls, this._untrustedExtensions)) {
      return Promise.reject(new UntrustedUrlError(url2));
    }
    const loader2 = getLoader(this.loaders);
    return loader2({ url: toURL3(uri), context: { deserialize: this.getDeserializer(), io: this.io } });
  }
  getDeserializer() {
    return getDeserializer(this.middleware);
  }
  serialize(configFile) {
    const serializer4 = getSerializer(this.middleware);
    return serializer4(configFile);
  }
  async writeConfig(configFile) {
    if (configFile.readonly)
      throw new Error(`Config file is readonly: ${configFile.url.href}`);
    const content = this.serialize(configFile);
    await this.io.writeFile({ url: configFile.url, content });
    return { url: configFile.url };
  }
  setUntrustedExtensions(ext) {
    this._untrustedExtensions.clear();
    ext.forEach((e) => this._untrustedExtensions.add(e.toLowerCase()));
    return this;
  }
  setTrustedUrls(urls) {
    this._trustedUrls = [...new Set(urls.map((url2) => new URL(url2).href))].sort();
    return this;
  }
  clearCachedFiles() {
    var _a3;
    for (const loader2 of this.loaders) {
      (_a3 = loader2.reset) == null ? void 0 : _a3.call(loader2);
    }
  }
};
function isTrusted(url2, trustedUrls, untrustedExtensions) {
  const path13 = url2.pathname;
  const ext = (0, import_posix.extname)(path13).toLowerCase();
  if (!untrustedExtensions.has(ext))
    return true;
  const href = url2.href;
  return trustedUrls.some((trustedUrl) => href.startsWith(trustedUrl));
}
var UntrustedUrlError = class extends Error {
  constructor(url2) {
    super(`Untrusted URL: "${url2.href}"`);
  }
};

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/defaultIO.js
var import_node_fs6 = require("fs");
var defaultIO = {
  readFile: readFile2,
  writeFile: writeFile2
};
async function readFile2(url2) {
  const content = await import_node_fs6.promises.readFile(url2, "utf8");
  return { url: url2, content };
}
async function writeFile2(file) {
  await import_node_fs6.promises.writeFile(file.url, file.content);
  return { url: file.url };
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/loaders/loaderJavaScript.js
var import_posix2 = require("path/posix");

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile.js
var CSpellConfigFile = class {
  url;
  constructor(url2) {
    this.url = url2;
  }
  get readonly() {
    return this.settings.readonly || this.url.protocol !== "file:";
  }
  get virtual() {
    return false;
  }
  get remote() {
    return this.url.protocol !== "file:";
  }
};
var ImplCSpellConfigFile = class extends CSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2);
    this.url = url2;
    this.settings = settings;
  }
  addWords(words) {
    if (this.readonly)
      throw new Error(`Config file is readonly: ${this.url.href}`);
    const w = this.settings.words || [];
    this.settings.words = w;
    addUniqueWordsToListAndSort(w, words);
    return this;
  }
};
function addUniqueWordsToListAndSort(list, toAdd) {
  list.unshift(...toAdd);
  list.sort();
  for (let i = 1; i < list.length; ++i) {
    if (list[i] === list[i - 1]) {
      list.splice(i, 1);
      --i;
    }
  }
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJavaScript.js
var CSpellConfigFileJavaScript = class extends ImplCSpellConfigFile {
  url;
  settings;
  get readonly() {
    return true;
  }
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  addWords(_words) {
    throw new Error("Unable to add words to a JavaScript config file.");
  }
};

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/loaders/loaderJavaScript.js
var _debug = false;
var _log = _debug ? console.warn.bind(console) : () => void 0;
async function importJavaScript(url2, hashSuffix) {
  try {
    const _url = new URL(url2.href);
    _url.hash = `${_url.hash};loaderSuffix=${hashSuffix}`;
    _log("importJavaScript: %o", { url: _url.href });
    const result = await import(_url.href);
    const settingsOrFunction = await (result.default ?? result);
    const settings = typeof settingsOrFunction === "function" ? await settingsOrFunction() : settingsOrFunction;
    return new CSpellConfigFileJavaScript(url2, settings);
  } catch (e) {
    _log("importJavaScript Error: %o", { url: url2.href, error: e, hashSuffix });
    throw e;
  } finally {
    _log("importJavaScript Done: %o", { url: url2.href, hashSuffix });
  }
}
var LoaderJavaScript = class {
  hashSuffix = 1;
  async _load(req, next) {
    const { url: url2 } = req;
    const ext = (0, import_posix2.extname)(url2.pathname).toLowerCase();
    switch (ext) {
      case ".js":
      case ".cjs":
      case ".mjs": {
        return importJavaScript(url2, this.hashSuffix);
      }
    }
    return next(req);
  }
  load = this._load.bind(this);
  reset() {
    this.hashSuffix += 1;
  }
};
var loaderJavaScript = new LoaderJavaScript();

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/loaders/index.js
var defaultLoaders = [loaderJavaScript];

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
var import_comment_json = __toESM(require_src2(), 1);

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/serializers/util.js
function detectIndent(content) {
  const m = content.match(/^[ \t]+/m);
  return m && m[0] || "  ";
}
function detectIndentAsNum(content) {
  const indent = detectIndent(content).replaceAll("	", "    ").replaceAll(/[^ ]/g, "");
  return indent.length;
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
var CSpellConfigFileJson = class _CSpellConfigFileJson extends ImplCSpellConfigFile {
  url;
  settings;
  indent = 2;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  serialize() {
    return (0, import_comment_json.stringify)(this.settings, void 0, this.indent) + "\n";
  }
  static parse(file) {
    try {
      const cspell2 = (0, import_comment_json.parse)(file.content);
      if (!isCSpellSettings(cspell2)) {
        throw new ParseError(file.url);
      }
      const indent = detectIndent(file.content);
      const cfg = new _CSpellConfigFileJson(file.url, cspell2);
      cfg.indent = indent;
      return cfg;
    } catch (cause) {
      if (cause instanceof ParseError) {
        throw cause;
      }
      throw new ParseError(file.url, void 0, { cause });
    }
  }
};
function parseCSpellConfigFileJson(file) {
  return CSpellConfigFileJson.parse(file);
}
function isCSpellSettings(cfg) {
  return !(!cfg || typeof cfg !== "object" || Array.isArray(cfg));
}
var ParseError = class extends Error {
  url;
  constructor(url2, message, options) {
    super(message || `Unable to parse ${url2}`, options);
    this.url = url2;
  }
};

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/serializers/cspellJson.js
function deserializer(params, next) {
  if (!isJsonFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileJson(params);
}
function isJsonFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".json") || pathname.endsWith(".jsonc");
}
function serializer(settings, next) {
  if (!(settings instanceof CSpellConfigFileJson))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellJson = { deserialize: deserializer, serialize: serializer };

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileYaml.js
var import_yaml = __toESM(require_dist(), 1);
var CSpellConfigFileYaml = class extends ImplCSpellConfigFile {
  url;
  settings;
  serializer;
  constructor(url2, settings, serializer4) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
    this.serializer = serializer4;
  }
  serialize() {
    return this.serializer(this.settings);
  }
};
function parseCSpellConfigFileYaml(file) {
  const { url: url2, content } = file;
  const cspell2 = (0, import_yaml.parse)(content) || {};
  if (!cspell2 || typeof cspell2 !== "object" || Array.isArray(cspell2)) {
    throw new Error(`Unable to parse ${url2}`);
  }
  const indent = detectIndentAsNum(content);
  function serialize(settings) {
    return (0, import_yaml.stringify)(settings, { indent });
  }
  return new CSpellConfigFileYaml(url2, cspell2, serialize);
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/serializers/cspellYaml.js
function deserializer2(params, next) {
  if (!isYamlFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileYaml(params);
}
function isYamlFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".yml") || pathname.endsWith(".yaml");
}
function serializer2(settings, next) {
  if (!(settings instanceof CSpellConfigFileYaml))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellYaml = { deserialize: deserializer2, serialize: serializer2 };

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFilePackageJson.js
var CSpellConfigFilePackageJson = class extends ImplCSpellConfigFile {
  url;
  settings;
  serializer;
  constructor(url2, settings, serializer4) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
    this.serializer = serializer4;
  }
  serialize() {
    return this.serializer(this.settings);
  }
};
function parseCSpellConfigFilePackageJson(file) {
  const { url: url2, content } = file;
  const packageJson = JSON.parse(content);
  if (!packageJson || typeof packageJson !== "object" || Array.isArray(packageJson)) {
    throw new Error(`Unable to parse ${url2}`);
  }
  packageJson["cspell"] = packageJson["cspell"] || {};
  const cspell2 = packageJson["cspell"];
  if (typeof cspell2 !== "object" || Array.isArray(cspell2)) {
    throw new TypeError(`Unable to parse ${url2}`);
  }
  const indent = detectIndent(content);
  function serialize(settings) {
    packageJson["cspell"] = settings;
    return JSON.stringify(packageJson, void 0, indent) + "\n";
  }
  return new CSpellConfigFilePackageJson(url2, cspell2, serialize);
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/serializers/packageJson.js
var isSupportedFormat = /\bpackage\.json$/i;
function deserializer3(params, next) {
  if (!isSupportedFormat.test(params.url.pathname))
    return next(params);
  return parseCSpellConfigFilePackageJson(params);
}
function serializer3(settings, next) {
  if (!(settings instanceof CSpellConfigFilePackageJson))
    return next(settings);
  return settings.serialize();
}
var serializerPackageJson = { deserialize: deserializer3, serialize: serializer3 };

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/serializers/index.js
var defaultDeserializers = [
  serializerCSpellJson,
  serializerCSpellYaml,
  serializerPackageJson
];

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/createReaderWriter.js
function createReaderWriter(deserializers2 = [], loaders2 = [], io = defaultIO) {
  return new CSpellConfigFileReaderWriterImpl(io, [...defaultDeserializers, ...deserializers2], [...defaultLoaders, ...loaders2]);
}

// node_modules/.pnpm/cspell-config-lib@8.14.2/node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileInMemory.js
var CSpellConfigFileInMemory = class extends ImplCSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  get virtual() {
    return true;
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/logger.js
var _logger = console;
function logError(...args) {
  _logger.error(...args);
}
function logWarning(...args) {
  _logger.warn(...args);
}
function setLogger(logger) {
  const oldLogger = _logger;
  _logger = logger;
  return oldLogger;
}
function getLogger() {
  return _logger;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/GlobalSettings.js
var import_node_url16 = require("url");

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_node_path8 = __toESM(require("path"), 1);

// node_modules/.pnpm/env-paths@3.0.0/node_modules/env-paths/index.js
var import_node_path7 = __toESM(require("path"), 1);
var import_node_os3 = __toESM(require("os"), 1);
var import_node_process3 = __toESM(require("process"), 1);
var homedir2 = import_node_os3.default.homedir();
var tmpdir = import_node_os3.default.tmpdir();
var { env } = import_node_process3.default;
var macos = (name) => {
  const library = import_node_path7.default.join(homedir2, "Library");
  return {
    data: import_node_path7.default.join(library, "Application Support", name),
    config: import_node_path7.default.join(library, "Preferences", name),
    cache: import_node_path7.default.join(library, "Caches", name),
    log: import_node_path7.default.join(library, "Logs", name),
    temp: import_node_path7.default.join(tmpdir, name)
  };
};
var windows = (name) => {
  const appData = env.APPDATA || import_node_path7.default.join(homedir2, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || import_node_path7.default.join(homedir2, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: import_node_path7.default.join(localAppData, name, "Data"),
    config: import_node_path7.default.join(appData, name, "Config"),
    cache: import_node_path7.default.join(localAppData, name, "Cache"),
    log: import_node_path7.default.join(localAppData, name, "Log"),
    temp: import_node_path7.default.join(tmpdir, name)
  };
};
var linux = (name) => {
  const username = import_node_path7.default.basename(homedir2);
  return {
    data: import_node_path7.default.join(env.XDG_DATA_HOME || import_node_path7.default.join(homedir2, ".local", "share"), name),
    config: import_node_path7.default.join(env.XDG_CONFIG_HOME || import_node_path7.default.join(homedir2, ".config"), name),
    cache: import_node_path7.default.join(env.XDG_CACHE_HOME || import_node_path7.default.join(homedir2, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: import_node_path7.default.join(env.XDG_STATE_HOME || import_node_path7.default.join(homedir2, ".local", "state"), name),
    temp: import_node_path7.default.join(tmpdir, username, name)
  };
};
function envPaths(name, { suffix = "nodejs" } = {}) {
  if (typeof name !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name}`);
  }
  if (suffix) {
    name += `-${suffix}`;
  }
  if (import_node_process3.default.platform === "darwin") {
    return macos(name);
  }
  if (import_node_process3.default.platform === "win32") {
    return windows(name);
  }
  return linux(name);
}

// node_modules/.pnpm/xdg-basedir@5.1.0/node_modules/xdg-basedir/index.js
var import_os = __toESM(require("os"), 1);
var import_path = __toESM(require("path"), 1);
var homeDirectory = import_os.default.homedir();
var { env: env2 } = process;
var xdgData = env2.XDG_DATA_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".local", "share") : void 0);
var xdgConfig = env2.XDG_CONFIG_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".config") : void 0);
var xdgState = env2.XDG_STATE_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".local", "state") : void 0);
var xdgCache = env2.XDG_CACHE_HOME || (homeDirectory ? import_path.default.join(homeDirectory, ".cache") : void 0);
var xdgRuntime = env2.XDG_RUNTIME_DIR || void 0;
var xdgDataDirectories = (env2.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
if (xdgData) {
  xdgDataDirectories.unshift(xdgData);
}
var xdgConfigDirectories = (env2.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
if (xdgConfig) {
  xdgConfigDirectories.unshift(xdgConfig);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
var packageName = "cspell";
var legacyLocationDir = xdgConfig ? import_node_path8.default.join(xdgConfig, "configstore") : void 0;
var cspellGlobalLocationDir = envPaths(packageName, { suffix: "" }).config;
var defaultConfigFileName = "cspell.json";
var searchOrder = [cspellGlobalLocationDir, legacyLocationDir].filter(isDefined4);
var _foundLocation, _baseFilename, _GlobalConfigStore_instances, readConfigFile_fn;
var GlobalConfigStore = class {
  constructor(filename = defaultConfigFileName) {
    __privateAdd(this, _GlobalConfigStore_instances);
    __privateAdd(this, _foundLocation);
    __privateAdd(this, _baseFilename);
    __privateSet(this, _baseFilename, filename);
  }
  async readConfigFile() {
    if (__privateGet(this, _foundLocation)) {
      const found = await __privateMethod(this, _GlobalConfigStore_instances, readConfigFile_fn).call(this, __privateGet(this, _foundLocation));
      if (found)
        return found;
    }
    const firstFile = import_node_path8.default.resolve(cspellGlobalLocationDir, __privateGet(this, _baseFilename));
    const possibleLocations = /* @__PURE__ */ new Set([
      firstFile,
      ...searchOrder.map((p) => import_node_path8.default.resolve(p, defaultConfigFileName))
    ]);
    for (const filename of possibleLocations) {
      const found = await __privateMethod(this, _GlobalConfigStore_instances, readConfigFile_fn).call(this, filename);
      if (found) {
        __privateSet(this, _foundLocation, found.filename);
        return found;
      }
    }
    return void 0;
  }
  async writeConfigFile(cfg) {
    __privateGet(this, _foundLocation) ?? __privateSet(this, _foundLocation, import_node_path8.default.join(cspellGlobalLocationDir, __privateGet(this, _baseFilename)));
    await import_promises2.default.mkdir(import_node_path8.default.dirname(__privateGet(this, _foundLocation)), { recursive: true });
    await import_promises2.default.writeFile(__privateGet(this, _foundLocation), JSON.stringify(cfg, void 0, 2) + "\n");
    return __privateGet(this, _foundLocation);
  }
  get location() {
    return __privateGet(this, _foundLocation);
  }
  static create() {
    return new this();
  }
};
_foundLocation = new WeakMap();
_baseFilename = new WeakMap();
_GlobalConfigStore_instances = new WeakSet();
readConfigFile_fn = async function(location) {
  try {
    const json = await import_promises2.default.readFile(location, "utf8");
    return { filename: location, config: JSON.parse(json) };
  } catch {
    return void 0;
  }
};
__publicField(GlobalConfigStore, "defaultLocation", import_node_path8.default.join(cspellGlobalLocationDir, defaultConfigFileName));

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
var import_node_os4 = require("os");
var import_node_url15 = require("url");

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/toGlobDef.js
function toGlobDef(g, root, source) {
  if (g === void 0)
    return void 0;
  if (Array.isArray(g)) {
    return g.map((g2) => toGlobDef(g2, root, source));
  }
  if (typeof g === "string") {
    const glob = { glob: g };
    if (root !== void 0) {
      glob.root = root;
    }
    return toGlobDef(glob, root, source);
  }
  if (source) {
    return { ...g, source };
  }
  return g;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
function normalizeRawConfig(config) {
  if (typeof config.version === "number") {
    config.version = config.version.toString();
  }
  if (config.import) {
    config.import = normalizeImport(config.import);
  }
}
function normalizeDictionaryDefs(settings, settingsFileUrl) {
  var _a3;
  const dictionaryDefinitions = mapDictDefsToInternal(settings.dictionaryDefinitions, settingsFileUrl);
  const languageSettings = (_a3 = settings.languageSettings) == null ? void 0 : _a3.map((langSetting) => clean4({
    ...langSetting,
    dictionaryDefinitions: mapDictDefsToInternal(langSetting.dictionaryDefinitions, settingsFileUrl)
  }));
  return clean4({
    dictionaryDefinitions,
    languageSettings
  });
}
function normalizeOverrides(settings, pathToSettingsFile) {
  var _a3;
  const { globRoot = toFilePathOrHref(new URL(".", pathToSettingsFile)) } = settings;
  const overrides = (_a3 = settings.overrides) == null ? void 0 : _a3.map((override) => {
    const filename = toGlobDef(override.filename, globRoot, toFilePathOrHref(pathToSettingsFile));
    const { dictionaryDefinitions, languageSettings } = normalizeDictionaryDefs(override, pathToSettingsFile);
    return clean4({
      ...override,
      filename,
      dictionaryDefinitions,
      languageSettings: normalizeLanguageSettings(languageSettings)
    });
  });
  return overrides ? { overrides } : {};
}
async function normalizeReporters(settings, pathToSettingsFile) {
  if (settings.reporters === void 0)
    return {};
  async function resolve3(s) {
    if (s === "default")
      return s;
    const r = await resolveFile(s, pathToSettingsFile);
    if (!r.found) {
      throw new Error(`Not found: "${s}"`);
    }
    return r.filename;
  }
  async function resolveReporter(s) {
    if (typeof s === "string") {
      return resolve3(s);
    }
    if (!Array.isArray(s) || typeof s[0] !== "string")
      throw new Error("Invalid Reporter");
    const [r, ...rest] = s;
    return [await resolve3(r), ...rest];
  }
  return {
    reporters: await Promise.all(settings.reporters.map(resolveReporter))
  };
}
function normalizeLanguageSettings(languageSettings) {
  if (!languageSettings)
    return void 0;
  function fixLocale(s) {
    const { local: locale, ...rest } = s;
    return clean4({ locale, ...rest });
  }
  return languageSettings.map(fixLocale);
}
function normalizeGitignoreRoot(settings, pathToSettingsFile) {
  const { gitignoreRoot } = settings;
  if (!gitignoreRoot)
    return {};
  const roots = Array.isArray(gitignoreRoot) ? gitignoreRoot : [gitignoreRoot];
  return {
    gitignoreRoot: roots.map((p) => resolveFilePathToPath(p, pathToSettingsFile))
  };
}
function normalizeSettingsGlobs(settings, pathToSettingsFile) {
  const { globRoot } = settings;
  const normalized = {};
  if (settings.ignorePaths) {
    normalized.ignorePaths = toGlobDef(settings.ignorePaths, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  if (settings.files) {
    normalized.files = toGlobDef(settings.files, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  return normalized;
}
function normalizeCacheSettings(settings, pathToSettingsFile) {
  const { cache: cache4 } = settings;
  if (cache4 === void 0)
    return {};
  const { cacheLocation } = cache4;
  if (cacheLocation === void 0)
    return { cache: cache4 };
  return { cache: { ...cache4, cacheLocation: toFilePathOrHref(resolveFilePath(cacheLocation, pathToSettingsFile)) } };
}
function resolveFilePath(filename, pathToSettingsFile) {
  const cwd = process.cwd();
  return toFileURL(filename.replace("${cwd}", cwd).replace(/^~/, (0, import_node_os4.homedir)()), pathToSettingsFile);
}
function resolveFilePathToPath(filename, pathToSettingsFile) {
  const url2 = resolveFilePath(filename, pathToSettingsFile);
  return url2.protocol === "file:" ? (0, import_node_url15.fileURLToPath)(url2) : url2.toString();
}
function normalizeImport(imports) {
  if (typeof imports === "string") {
    return [imports];
  }
  if (Array.isArray(imports)) {
    return imports;
  }
  return [];
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configToRawSettings.js
function configErrorToRawSettings(error, url2) {
  const filename = toFilePathOrHref(url2);
  const fileRef = { filename, error };
  const source = { name: filename, filename };
  return { __importRef: fileRef, source };
}
function configToRawSettings(cfgFile) {
  if (!cfgFile)
    return {};
  const url2 = cfgFile.url;
  const filename = toFilePathOrHref(url2);
  const fileRef = {
    filename,
    error: void 0
  };
  const source = {
    name: cfgFile.settings.name || filename,
    filename: cfgFile.virtual ? void 0 : filename
  };
  const rawSettings = { ...cfgFile.settings };
  rawSettings.import = normalizeImport(rawSettings.import);
  normalizeRawConfig(rawSettings);
  rawSettings.source = source;
  if (!cfgFile.virtual) {
    rawSettings.__importRef = fileRef;
  }
  const id = rawSettings.id || urlToSimpleId(url2);
  const name = rawSettings.name || id;
  rawSettings.id = id;
  rawSettings.name = cfgFile.settings.name || name;
  return rawSettings;
}
function urlToSimpleId(url2) {
  return url2.pathname.split("/").slice(-2).join("/");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/GlobalSettings.js
var globalConfig = new GlobalConfigStore();
async function getRawGlobalSettings() {
  return configToRawSettings(await getGlobalConfig());
}
async function getGlobalConfig() {
  const name = "CSpell Configstore";
  const configPath = getGlobalConfigPath();
  let urlGlobal = configPath ? (0, import_node_url16.pathToFileURL)(configPath) : new URL("global-config.json", getSourceDirectoryUrl());
  const source = {
    name,
    filename: toFilePathOrHref(urlGlobal)
  };
  const globalConf = { source };
  let hasGlobalConfig = false;
  const found = await globalConfig.readConfigFile();
  if (found && found.config && found.filename) {
    const cfg = found.config;
    urlGlobal = (0, import_node_url16.pathToFileURL)(found.filename);
    if (cfg && Object.keys(cfg).length) {
      Object.assign(globalConf, cfg);
      globalConf.source = {
        name,
        filename: found.filename
      };
      hasGlobalConfig = Object.keys(cfg).length > 0;
    }
  }
  const settings = { ...globalConf, name, source };
  const ConfigFile = hasGlobalConfig ? CSpellConfigFileJson : CSpellConfigFileInMemory;
  return new ConfigFile(urlGlobal, settings);
}
async function writeRawGlobalSettings(settings) {
  const toWrite = {
    import: settings.import
  };
  await globalConfig.writeConfigFile(toWrite);
}
function getGlobalConfigPath() {
  try {
    return globalConfig.location || GlobalConfigStore.defaultLocation;
  } catch {
    return void 0;
  }
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/ImportError.js
var ImportError = class extends Error {
  cause;
  constructor(msg, cause) {
    super(msg);
    this.cause = isError(cause) ? cause : void 0;
  }
};
var UnsupportedPnpFile = class extends Error {
  constructor(msg) {
    super(msg);
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var import_node_url18 = require("url");
var import_clear_module = __toESM(require_clear_module(), 1);
var import_import_fresh = __toESM(require_import_fresh(), 1);

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/findUp.js
var import_promises3 = require("fs/promises");
var import_node_path9 = __toESM(require("path"), 1);
var import_node_url17 = require("url");
async function findUp(name, options = {}) {
  const { cwd = process.cwd(), type: entryType = "file", stopAt } = options;
  let dir = import_node_path9.default.resolve(toDirPath(cwd));
  const root = import_node_path9.default.parse(dir).root;
  const predicate = makePredicate2(name, entryType);
  const stopAtDir = import_node_path9.default.resolve(toDirPath(stopAt || root));
  while (dir !== root && dir !== stopAtDir) {
    const found = await predicate(dir);
    if (found !== void 0)
      return found;
    dir = import_node_path9.default.dirname(dir);
  }
  return void 0;
}
function makePredicate2(name, entryType) {
  if (typeof name === "function")
    return name;
  const checkStat = entryType === "file" ? "isFile" : "isDirectory";
  function checkName(dir, name2) {
    const f = import_node_path9.default.join(dir, name2);
    return (0, import_promises3.stat)(f).then((stats2) => stats2[checkStat]() && f || void 0).catch(() => void 0);
  }
  if (!Array.isArray(name))
    return (dir) => checkName(dir, name);
  return async (dir) => {
    const pending = name.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found)
        return found;
    }
    return void 0;
  };
}
function toDirPath(urlOrPath) {
  return urlOrPath instanceof URL ? (0, import_node_url17.fileURLToPath)(new URL(".", urlOrPath)) : urlOrPath;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var defaultPnpFiles = [".pnp.cjs", ".pnp.js"];
var supportedSchemas = /* @__PURE__ */ new Set(["file:"]);
var cachedRequests = /* @__PURE__ */ new Map();
var lock = void 0;
var cachedPnpImportsSync = /* @__PURE__ */ new Map();
var cachedRequestsSync = /* @__PURE__ */ new Map();
var PnpLoader = class {
  pnpFiles;
  cacheKeySuffix;
  constructor(pnpFiles = defaultPnpFiles) {
    this.pnpFiles = pnpFiles;
    this.cacheKeySuffix = ":" + pnpFiles.join(",");
  }
  /**
   * Request that the nearest .pnp file gets loaded
   * @param urlDirectory starting directory
   * @returns promise - rejects on error - success if loaded or not found.
   */
  async load(urlDirectory) {
    if (!isSupported(urlDirectory))
      return void 0;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    const cached = cachedRequests.get(cacheKey);
    if (cached)
      return cached;
    const r = findPnpAndLoad(urlDirectory, this.pnpFiles);
    cachedRequests.set(cacheKey, r);
    const result = await r;
    cachedRequestsSync.set(cacheKey, result);
    return result;
  }
  async peek(urlDirectory) {
    if (!isSupported(urlDirectory))
      return void 0;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    return cachedRequests.get(cacheKey) ?? Promise.resolve(void 0);
  }
  /**
   * Clears the cached so .pnp files will get reloaded on request.
   */
  clearCache() {
    return clearPnPGlobalCache();
  }
  calcKey(urlDirectory) {
    return urlDirectory.toString() + this.cacheKeySuffix;
  }
};
function pnpLoader(pnpFiles) {
  return new PnpLoader(pnpFiles);
}
async function findPnpAndLoad(urlDirectory, pnpFiles) {
  const found = await findUp(pnpFiles, { cwd: (0, import_node_url18.fileURLToPath)(urlDirectory) });
  return loadPnpIfNeeded(found);
}
function loadPnpIfNeeded(found) {
  if (!found)
    return void 0;
  const c = cachedPnpImportsSync.get(found);
  if (c || cachedPnpImportsSync.has(found))
    return c;
  const r = loadPnp(found);
  cachedPnpImportsSync.set(found, r);
  return r;
}
function loadPnp(pnpFile) {
  const pnp = (0, import_import_fresh.default)(pnpFile);
  if (pnp.setup) {
    pnp.setup();
    return toFileUrl(pnpFile);
  }
  throw new UnsupportedPnpFile(`Unsupported pnp file: "${pnpFile}"`);
}
function clearPnPGlobalCache() {
  if (lock)
    return lock;
  lock = _cleanCache().finally(() => {
    lock = void 0;
  });
  return lock;
}
async function _cleanCache() {
  await Promise.all([...cachedRequests.values()].map(rejectToUndefined));
  const modules = [...cachedPnpImportsSync.values()];
  modules.forEach((r) => r && import_clear_module.default.single((0, import_node_url18.fileURLToPath)(r)));
  cachedRequests.clear();
  cachedRequestsSync.clear();
  cachedPnpImportsSync.clear();
  return void 0;
}
function rejectToUndefined(p) {
  return p.catch(() => void 0);
}
function isSupported(url2) {
  return supportedSchemas.has(url2.protocol);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLocations.js
var supportedExtensions = [".json", ".jsonc", ".yaml", ".yml", ".mjs", ".cjs", ".js"];
var setOfLocations = /* @__PURE__ */ new Set([
  "package.json",
  // Original locations
  ".cspell.json",
  "cspell.json",
  ".cSpell.json",
  "cSpell.json",
  // Original locations jsonc
  ".cspell.jsonc",
  "cspell.jsonc",
  // Alternate locations
  ".vscode/cspell.json",
  ".vscode/cSpell.json",
  ".vscode/.cspell.json",
  // Standard Locations
  ".cspell.config.json",
  ".cspell.config.jsonc",
  ".cspell.config.yaml",
  ".cspell.config.yml",
  "cspell.config.json",
  "cspell.config.jsonc",
  "cspell.config.yaml",
  "cspell.config.yml",
  // Dynamic config is looked for last
  ...genCfgLoc("cspell.config", supportedExtensions),
  ...genCfgLoc(".cspell.config", supportedExtensions),
  // .config
  ".cspell.yaml",
  ".cspell.yml",
  "cspell.yaml",
  "cspell.yml",
  ".config/.cspell.json",
  ".config/cspell.json",
  ".config/.cSpell.json",
  ".config/cSpell.json",
  ".config/.cspell.jsonc",
  ".config/cspell.jsonc",
  ...genCfgLoc(".config/cspell.config", supportedExtensions),
  ...genCfgLoc(".config/.cspell.config", supportedExtensions),
  ".config/cspell.yaml",
  ".config/cspell.yml"
]);
var searchPlaces = Object.freeze([...setOfLocations]);
var defaultConfigFilenames = Object.freeze([...searchPlaces]);
function genCfgLoc(filename, extensions) {
  return extensions.map((ext) => filename + ext);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
var import_posix3 = require("path/posix");

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/findUpFromUrl.js
async function findUpFromUrl2(name, from2, options = {}) {
  const fs8 = options.fs ?? getVirtualFS().fs;
  return fs8.findUp(name, from2, options);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
var ConfigSearch = class {
  searchPlaces;
  allowedExtensionsByProtocol;
  fs;
  searchCache = /* @__PURE__ */ new Map();
  searchDirCache = /* @__PURE__ */ new Map();
  searchPlacesByProtocol;
  /**
   * @param searchPlaces - The list of file names to search for.
   * @param allowedExtensionsByProtocol - Map of allowed extensions by protocol, '*' is used to match all protocols.
   * @param fs - The file system to use.
   */
  constructor(searchPlaces2, allowedExtensionsByProtocol, fs8) {
    this.searchPlaces = searchPlaces2;
    this.allowedExtensionsByProtocol = allowedExtensionsByProtocol;
    this.fs = fs8;
    this.searchPlacesByProtocol = setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol);
    this.searchPlaces = this.searchPlacesByProtocol.get("*") || searchPlaces2;
  }
  searchForConfig(searchFromURL) {
    const dirUrl = new URL(".", searchFromURL);
    const searchHref = dirUrl.href;
    const searchCache = this.searchCache;
    const cached = searchCache.get(searchHref);
    if (cached) {
      return cached;
    }
    const toPatchCache = [];
    const pFoundUrl = this.findUpConfigPath(dirUrl, storeVisit);
    this.searchCache.set(searchHref, pFoundUrl);
    const searchDirCache = this.searchDirCache;
    const patch = async () => {
      try {
        await pFoundUrl;
        for (const dir of toPatchCache) {
          searchDirCache.set(dir.href, searchDirCache.get(dir.href) || pFoundUrl);
          searchCache.set(dir.href, searchCache.get(dir.href) || pFoundUrl);
        }
        const result = searchCache.get(searchHref) || pFoundUrl;
        searchCache.set(searchHref, result);
      } catch {
      }
    };
    patch();
    return pFoundUrl;
    function storeVisit(dir) {
      toPatchCache.push(dir);
    }
  }
  clearCache() {
    this.searchCache.clear();
    this.searchDirCache.clear();
  }
  findUpConfigPath(cwd, visit) {
    const searchDirCache = this.searchDirCache;
    const cached = searchDirCache.get(cwd.href);
    if (cached)
      return cached;
    return findUpFromUrl2((dir) => this.hasConfig(dir, visit), cwd, { type: "file" });
  }
  hasConfig(dir, visited) {
    const cached = this.searchDirCache.get(dir.href);
    if (cached)
      return cached;
    visited(dir);
    const result = this.hasConfigDir(dir);
    this.searchDirCache.set(dir.href, result);
    return result;
  }
  createHasFileDirSearch() {
    const dirInfoCache = createAutoResolveCache();
    const hasFile = async (filename) => {
      const dir = new URL(".", filename);
      const parent = new URL("..", dir);
      const parentHref = parent.href;
      const parentInfoP = dirInfoCache.get(parentHref);
      if (parentInfoP) {
        const parentInfo = await parentInfoP;
        const name2 = urlBasename(dir).slice(0, -1);
        const found2 = parentInfo.get(name2);
        if (!(found2 == null ? void 0 : found2.isDirectory()) && !(found2 == null ? void 0 : found2.isSymbolicLink()))
          return false;
      }
      const dirUrlHref = dir.href;
      const dirInfo = await dirInfoCache.get(dirUrlHref, async () => await this.readDir(dir));
      const name = urlBasename(filename);
      const found = dirInfo.get(name);
      return (found == null ? void 0 : found.isFile()) || (found == null ? void 0 : found.isSymbolicLink()) || false;
    };
    return hasFile;
  }
  async readDir(dir) {
    try {
      const dirInfo = await this.fs.readDirectory(dir);
      return new Map(dirInfo.map((ent) => [ent.name, ent]));
    } catch {
      return /* @__PURE__ */ new Map();
    }
  }
  createHasFileStatCheck() {
    const hasFile = async (filename) => {
      const stat2 = await this.fs.stat(filename).catch(() => void 0);
      return !!(stat2 == null ? void 0 : stat2.isFile());
    };
    return hasFile;
  }
  async hasConfigDir(dir) {
    const hasFile = this.fs.getCapabilities(dir).readDirectory ? this.createHasFileDirSearch() : this.createHasFileStatCheck();
    const searchPlaces2 = this.searchPlacesByProtocol.get(dir.protocol) || this.searchPlaces;
    for (const searchPlace of searchPlaces2) {
      const file = new URL(searchPlace, dir);
      const found = await hasFile(file);
      if (found) {
        if (urlBasename(file) !== "package.json")
          return file;
        if (await checkPackageJson(this.fs, file))
          return file;
      }
    }
    return void 0;
  }
};
function setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol) {
  const map3 = new Map([...allowedExtensionsByProtocol.entries()].map(([k, v]) => [k, new Set(v)]).map(([protocol, exts]) => [protocol, searchPlaces2.filter((url2) => exts.has((0, import_posix3.extname)(url2)))]));
  return map3;
}
async function checkPackageJson(fs8, filename) {
  try {
    const file = await fs8.readFile(filename);
    const pkg = JSON.parse(file.getText());
    return typeof pkg.cspell === "object";
  } catch {
    return false;
  }
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultSettings.js
var defaultSettings = createCSpellSettingsInternal({
  id: "default",
  name: "default",
  version: currentSettingsFileVersion
});

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/PnPSettings.js
var defaultPnPSettings = Object.freeze({});
var lastPnP = defaultPnPSettings;
function normalizePnPSettings(settings) {
  if (equal(lastPnP, settings))
    return lastPnP;
  if (equal(defaultPnPSettings, settings))
    return defaultPnPSettings;
  const { usePnP, pnpFiles } = settings;
  return lastPnP = clean4({ usePnP, pnpFiles });
}
function equal(a, b) {
  var _a3, _b;
  return a === b || a.usePnP === b.usePnP && (a.pnpFiles === b.pnpFiles || ((_a3 = a.pnpFiles) == null ? void 0 : _a3.join("|")) === ((_b = b.pnpFiles) == null ? void 0 : _b.join("|")));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
var supportedCSpellConfigVersions = [configSettingsFileVersion0_2];
var setOfSupportedConfigVersions = Object.freeze(new Set(supportedCSpellConfigVersions));
var sectionCSpell = "cSpell";
var defaultFileName = "cspell.json";
var defaultConfigLoader = void 0;
var defaultExtensions = [".json", ".yaml", ".yml", ".jsonc"];
var defaultJsExtensions = [".js", ".cjs", ".mjs"];
var trustedSearch = /* @__PURE__ */ new Map([
  ["*", defaultExtensions],
  ["file:", [...defaultExtensions, ...defaultJsExtensions]]
]);
var unTrustedSearch = /* @__PURE__ */ new Map([["*", defaultExtensions]]);
var ConfigLoader = class {
  fs;
  templateVariables;
  onReady;
  fileResolver;
  _isTrusted = true;
  /**
   * Use `createConfigLoader`
   * @param virtualFs - virtual file system to use.
   */
  constructor(fs8, templateVariables = envToTemplateVars(process.env)) {
    this.fs = fs8;
    this.templateVariables = templateVariables;
    this.configSearch = new ConfigSearch(searchPlaces, trustedSearch, fs8);
    this.cspellConfigFileReaderWriter = createReaderWriter(void 0, void 0, createIO(fs8));
    this.fileResolver = new FileResolver(fs8, this.templateVariables);
    this.onReady = this.init();
    this.subscribeToEvents();
  }
  subscribeToEvents() {
    this.toDispose.push(onClearCache(() => this.clearCachedSettingsFiles()));
  }
  cachedConfig = /* @__PURE__ */ new Map();
  cachedConfigFiles = /* @__PURE__ */ new Map();
  cachedPendingConfigFile = new AutoResolveCache();
  cachedMergedConfig = /* @__PURE__ */ new WeakMap();
  cachedCSpellConfigFileInMemory = /* @__PURE__ */ new WeakMap();
  globalSettings;
  cspellConfigFileReaderWriter;
  configSearch;
  toDispose = [];
  async readSettingsAsync(filename, relativeTo, pnpSettings) {
    await this.onReady;
    const ref = await this.resolveFilename(filename, relativeTo || (0, import_node_url19.pathToFileURL)("./"));
    const entry = this.importSettings(ref, pnpSettings || defaultPnPSettings, []);
    return entry.onReady;
  }
  async readConfigFile(filenameOrURL, relativeTo) {
    const ref = await this.resolveFilename(filenameOrURL.toString(), relativeTo || (0, import_node_url19.pathToFileURL)("./"));
    const url2 = toFileURL(ref.filename);
    const href = url2.href;
    if (ref.error)
      return new ImportError(`Failed to read config file: "${ref.filename}"`, ref.error);
    const cached = this.cachedConfigFiles.get(href);
    if (cached)
      return cached;
    return this.cachedPendingConfigFile.get(href, async () => {
      try {
        const file = await this.cspellConfigFileReaderWriter.readConfig(href);
        this.cachedConfigFiles.set(href, file);
        return file;
      } catch (error) {
        return new ImportError(`Failed to read config file: "${ref.filename}"`, error);
      } finally {
        setTimeout(() => this.cachedPendingConfigFile.delete(href), 1);
      }
    });
  }
  async searchForConfigFileLocation(searchFrom) {
    const url2 = toFileURL(searchFrom || cwdURL(), cwdURL());
    if (typeof searchFrom === "string" && !isUrlLike(searchFrom) && url2.protocol === "file:" && // check to see if it is a directory
    await isDirectory(this.fs, url2)) {
      return this.configSearch.searchForConfig(addTrailingSlash(url2));
    }
    return this.configSearch.searchForConfig(url2);
  }
  async searchForConfigFile(searchFrom) {
    const location = await this.searchForConfigFileLocation(searchFrom);
    if (!location)
      return void 0;
    const file = await this.readConfigFile(location);
    return file instanceof Error ? void 0 : file;
  }
  /**
   *
   * @param searchFrom the directory / file URL to start searching from.
   * @param pnpSettings - related to Using Yarn PNP.
   * @returns the resulting settings
   */
  async searchForConfig(searchFrom, pnpSettings = defaultPnPSettings) {
    const configFile = await this.searchForConfigFile(searchFrom);
    if (!configFile)
      return void 0;
    return this.mergeConfigFileWithImports(configFile, pnpSettings);
  }
  getGlobalSettings() {
    (0, import_node_assert10.default)(this.globalSettings, "Global settings not loaded");
    return this.globalSettings;
  }
  async getGlobalSettingsAsync() {
    if (!this.globalSettings) {
      const globalConfFile = await getGlobalConfig();
      const normalized = await this.mergeConfigFileWithImports(globalConfFile, void 0);
      normalized.id ?? (normalized.id = "global_config");
      this.globalSettings = normalized;
    }
    return this.globalSettings;
  }
  clearCachedSettingsFiles() {
    this.globalSettings = void 0;
    this.cachedConfig.clear();
    this.cachedConfigFiles.clear();
    this.configSearch.clearCache();
    this.cachedPendingConfigFile.clear();
    this.cspellConfigFileReaderWriter.clearCachedFiles();
    this.cachedMergedConfig = /* @__PURE__ */ new WeakMap();
    this.cachedCSpellConfigFileInMemory = /* @__PURE__ */ new WeakMap();
    this.prefetchGlobalSettingsAsync();
  }
  /**
   * Resolve and merge the settings from the imports.
   * @param settings - settings to resolve imports for
   * @param filename - the path / URL to the settings file. Used to resolve imports.
   */
  resolveSettingsImports(settings, filename) {
    const settingsFile = this.createCSpellConfigFile(filename, settings);
    return this.mergeConfigFileWithImports(settingsFile, settings);
  }
  init() {
    this.onReady = Promise.all([this.prefetchGlobalSettingsAsync(), this.resolveDefaultConfig()]).then(() => void 0);
    return this.onReady;
  }
  async prefetchGlobalSettingsAsync() {
    await this.getGlobalSettingsAsync().catch((e) => logError(e));
  }
  async resolveDefaultConfig() {
    const r = await this.fileResolver.resolveFile(defaultConfigFileModuleRef, srcDirectory);
    const url2 = toFileURL(r.filename);
    this.cspellConfigFileReaderWriter.setTrustedUrls([new URL("../..", url2)]);
    return url2;
  }
  importSettings(fileRef, pnpSettings, backReferences) {
    const url2 = toFileURL(fileRef.filename);
    const cacheKey = url2.href;
    const cachedImport = this.cachedConfig.get(cacheKey);
    if (cachedImport) {
      backReferences.forEach((ref) => cachedImport.referencedSet.add(ref));
      return cachedImport;
    }
    if (fileRef.error) {
      const settings = createCSpellSettingsInternal({
        __importRef: fileRef,
        source: { name: fileRef.filename, filename: fileRef.filename }
      });
      const importedConfig2 = {
        href: cacheKey,
        fileRef,
        configFile: void 0,
        settings,
        isReady: true,
        onReady: Promise.resolve(settings),
        onConfigFileReady: Promise.resolve(fileRef.error),
        referencedSet: new Set(backReferences)
      };
      this.cachedConfig.set(cacheKey, importedConfig2);
      return importedConfig2;
    }
    const source = {
      name: fileRef.filename,
      filename: fileRef.filename
    };
    const mergeImports = (cfgFile) => {
      if (cfgFile instanceof Error) {
        fileRef.error = cfgFile;
        return createCSpellSettingsInternal({ __importRef: fileRef, source });
      }
      return this.mergeConfigFileWithImports(cfgFile, pnpSettings, backReferences);
    };
    const referencedSet = new Set(backReferences);
    const onConfigFileReady = onConfigFileReadyFixUp(this.readConfigFile(fileRef.filename));
    const importedConfig = {
      href: cacheKey,
      fileRef,
      configFile: void 0,
      settings: void 0,
      isReady: false,
      onReady: onReadyFixUp(onConfigFileReady.then(mergeImports)),
      onConfigFileReady,
      referencedSet
    };
    this.cachedConfig.set(cacheKey, importedConfig);
    return importedConfig;
    async function onReadyFixUp(pSettings) {
      const settings = await pSettings;
      settings.source ?? (settings.source = source);
      settings.__importRef ?? (settings.__importRef = fileRef);
      importedConfig.isReady = true;
      importedConfig.settings = settings;
      return settings;
    }
    async function onConfigFileReadyFixUp(pCfgFile) {
      const cfgFile = await pCfgFile;
      if (cfgFile instanceof Error) {
        importedConfig.fileRef.error = cfgFile;
        return cfgFile;
      }
      source.name = cfgFile.settings.name || source.name;
      importedConfig.configFile = cfgFile;
      return cfgFile;
    }
  }
  async setupPnp(cfgFile, pnpSettings) {
    if (!(pnpSettings == null ? void 0 : pnpSettings.usePnP) || pnpSettings === defaultPnPSettings)
      return;
    if (cfgFile.url.protocol !== "file:")
      return;
    const { usePnP = pnpSettings.usePnP, pnpFiles = pnpSettings.pnpFiles } = cfgFile.settings;
    const pnpSettingsToUse = normalizePnPSettings({ usePnP, pnpFiles });
    const pathToSettingsDir = new URL(".", cfgFile.url);
    await loadPnP(pnpSettingsToUse, pathToSettingsDir);
  }
  mergeConfigFileWithImports(cfgFile, pnpSettings, referencedBy) {
    const cached = this.cachedMergedConfig.get(cfgFile);
    if (cached && cached.pnpSettings === pnpSettings && cached.referencedBy === referencedBy) {
      return cached.result;
    }
    const result = this._mergeConfigFileWithImports(cfgFile, pnpSettings, referencedBy);
    this.cachedMergedConfig.set(cfgFile, { pnpSettings, referencedBy, result });
    return result;
  }
  async _mergeConfigFileWithImports(cfgFile, pnpSettings, referencedBy = []) {
    await this.setupPnp(cfgFile, pnpSettings);
    const href = cfgFile.url.href;
    const referencedSet = new Set(referencedBy);
    const imports = normalizeImport(cfgFile.settings.import);
    const __imports = await Promise.all(imports.map((name) => this.resolveFilename(name, cfgFile.url)));
    const toImport = __imports.map((ref) => this.importSettings(ref, pnpSettings, [...referencedBy, href]));
    toImport.forEach((entry) => {
      entry.referencedSet.add(href);
    });
    const pendingImports = toImport.map((entry) => {
      return referencedSet.has(entry.href) ? entry.settings || configToRawSettings(entry.configFile) : entry.onReady;
    });
    const importSettings = await Promise.all(pendingImports);
    const cfg = await this.mergeImports(cfgFile, importSettings);
    return cfg;
  }
  /**
   * normalizeSettings handles correcting all relative paths, anchoring globs, and importing other config files.
   * @param rawSettings - raw configuration settings
   * @param pathToSettingsFile - path to the source file of the configuration settings.
   */
  async mergeImports(cfgFile, importedSettings) {
    const rawSettings = configToRawSettings(cfgFile);
    const url2 = cfgFile.url;
    const fileRef = rawSettings.__importRef;
    const source = rawSettings.source;
    (0, import_node_assert10.default)(source);
    const settings = {
      version: defaultSettings.version,
      ...rawSettings,
      globRoot: resolveGlobRoot(rawSettings, cfgFile.url),
      languageSettings: normalizeLanguageSettings(rawSettings.languageSettings)
    };
    const normalizedDictionaryDefs = normalizeDictionaryDefs(settings, url2);
    const normalizedSettingsGlobs = normalizeSettingsGlobs(settings, url2);
    const normalizedOverrides = normalizeOverrides(settings, url2);
    const normalizedReporters = await normalizeReporters(settings, url2);
    const normalizedGitignoreRoot = normalizeGitignoreRoot(settings, url2);
    const normalizedCacheSettings = normalizeCacheSettings(settings, url2);
    const fileSettings = createCSpellSettingsInternal({
      ...settings,
      source,
      ...normalizedDictionaryDefs,
      ...normalizedSettingsGlobs,
      ...normalizedOverrides,
      ...normalizedReporters,
      ...normalizedGitignoreRoot,
      ...normalizedCacheSettings
    });
    if (!importedSettings.length) {
      return fileSettings;
    }
    const mergedImportedSettings = importedSettings.reduce((a, b) => mergeSettings(a, b));
    const finalizeSettings2 = mergeSettings(mergedImportedSettings, fileSettings);
    finalizeSettings2.name = settings.name || finalizeSettings2.name || "";
    finalizeSettings2.id = settings.id || finalizeSettings2.id || "";
    if (fileRef) {
      finalizeSettings2.__importRef = fileRef;
    }
    return finalizeSettings2;
  }
  createCSpellConfigFile(filename, settings) {
    const map3 = autoResolveWeak2(this.cachedCSpellConfigFileInMemory, settings, () => /* @__PURE__ */ new Map());
    return autoResolve(map3, filename, () => new CSpellConfigFileInMemory(toFileURL(filename), settings));
  }
  dispose() {
    var _a3;
    while (this.toDispose.length) {
      try {
        (_a3 = this.toDispose.pop()) == null ? void 0 : _a3.dispose();
      } catch (e) {
        logError(e);
      }
    }
  }
  getStats() {
    return { ...stats() };
  }
  async resolveConfigFileLocation(filenameOrURL, relativeTo) {
    const r = await this.fileResolver.resolveFile(filenameOrURL, relativeTo);
    return r.found ? toFileURL(r.filename) : void 0;
  }
  async resolveFilename(filename, relativeTo) {
    if (filename instanceof URL)
      return { filename: toFilePathOrHref(filename) };
    if (isUrlLike(filename))
      return { filename: toFilePathOrHref(filename) };
    const r = await this.fileResolver.resolveFile(filename, relativeTo);
    if (r.warning) {
      logWarning(r.warning);
    }
    return {
      filename: r.filename.startsWith("file:/") ? (0, import_node_url19.fileURLToPath)(r.filename) : r.filename,
      error: r.found ? void 0 : new ConfigurationLoaderFailedToResolveError(filename, relativeTo)
    };
  }
  get isTrusted() {
    return this._isTrusted;
  }
  setIsTrusted(isTrusted2) {
    this._isTrusted = isTrusted2;
    this.clearCachedSettingsFiles();
    this.configSearch = new ConfigSearch(searchPlaces, isTrusted2 ? trustedSearch : unTrustedSearch, this.fs);
    this.cspellConfigFileReaderWriter.setUntrustedExtensions(isTrusted2 ? [] : defaultJsExtensions);
  }
};
var ConfigLoaderInternal = class extends ConfigLoader {
  constructor(vfs) {
    super(vfs);
  }
  get _cachedFiles() {
    return this.cachedConfig;
  }
};
function loadPnP(pnpSettings, searchFrom) {
  if (!pnpSettings.usePnP) {
    return Promise.resolve(void 0);
  }
  const loader2 = pnpLoader(pnpSettings.pnpFiles);
  return loader2.load(searchFrom);
}
var nestedConfigDirectories = {
  ".vscode": true,
  ".config": true
  // this should be removed in the future, but it is a breaking change.
};
function resolveGlobRoot(settings, urlSettingsFile) {
  const urlSettingsFileDir = new URL(".", urlSettingsFile);
  const uriSettingsFileDir = URI.parse(urlSettingsFileDir.href);
  const settingsFileDirName = Utils.basename(uriSettingsFileDir);
  const isNestedConfig = settingsFileDirName in nestedConfigDirectories;
  const isVSCode = settingsFileDirName === ".vscode";
  const settingsFileDir = (isNestedConfig ? Utils.dirname(uriSettingsFileDir) : uriSettingsFileDir).toString();
  const envGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
  const defaultGlobRoot = envGlobRoot ?? "${cwd}";
  const rawRoot = settings.globRoot ?? (settings.version === configSettingsFileVersion0_1 || envGlobRoot && !settings.version || isVSCode && !settings.version ? defaultGlobRoot : settingsFileDir);
  const globRoot = rawRoot.startsWith("${cwd}") ? rawRoot : toFileURL(rawRoot, new URL(settingsFileDir));
  return typeof globRoot === "string" ? globRoot : globRoot.protocol === "file:" ? windowsDriveLetterToUpper(import_node_path10.default.resolve((0, import_node_url19.fileURLToPath)(globRoot))) : addTrailingSlash(globRoot).href;
}
function createConfigLoaderInternal(fs8) {
  return new ConfigLoaderInternal(fs8 ?? getVirtualFS().fs);
}
function createConfigLoader(fs8) {
  return createConfigLoaderInternal(fs8);
}
function getDefaultConfigLoaderInternal() {
  if (defaultConfigLoader)
    return defaultConfigLoader;
  return defaultConfigLoader = createConfigLoaderInternal();
}
function createIO(fs8) {
  const readFile3 = (url2) => fs8.readFile(url2).then((file) => ({ url: file.url, content: file.getText() }));
  const writeFile3 = (file) => fs8.writeFile(file);
  return {
    readFile: readFile3,
    writeFile: writeFile3
  };
}
async function isDirectory(fs8, path13) {
  try {
    return (await fs8.stat(path13)).isDirectory();
  } catch {
    return false;
  }
}
var ConfigurationLoaderError = class extends Error {
  configurationFile;
  relativeTo;
  constructor(message, configurationFile, relativeTo, cause) {
    super(message);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
    this.name = "Configuration Loader Error";
    if (cause) {
      this.cause = cause;
    }
  }
};
var ConfigurationLoaderFailedToResolveError = class extends ConfigurationLoaderError {
  configurationFile;
  relativeTo;
  constructor(configurationFile, relativeTo, cause) {
    const filename = configurationFile.startsWith("file:/") ? (0, import_node_url19.fileURLToPath)(configurationFile) : configurationFile;
    const relSource = relativeToCwd(relativeTo);
    const message = `Failed to resolve configuration file: "${filename}" referenced from "${relSource}"`;
    super(message, configurationFile, relativeTo, cause);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
  }
};
function relativeToCwd(file) {
  const url2 = toFileUrl(file);
  const cwdPath = cwdURL().pathname.split("/").slice(0, -1);
  const urlPath = url2.pathname.split("/");
  if (urlPath[0] !== cwdPath[0])
    return toFilePathOrHref(file);
  let i = 0;
  for (; i < cwdPath.length; ++i) {
    if (cwdPath[i] !== urlPath[i])
      break;
  }
  const segments = cwdPath.length - i;
  if (segments > 3)
    return toFilePathOrHref(file);
  const prefix = [...".".repeat(segments)].map(() => "..").join("/");
  return [prefix || ".", ...urlPath.slice(i)].join("/");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultConfigLoader.js
var gcl = getDefaultConfigLoaderInternal;
function searchForConfig(searchFrom, pnpSettings = defaultPnPSettings) {
  return gcl().searchForConfig(searchFrom, pnpSettings);
}
async function loadConfig(file, pnpSettings) {
  return gcl().readSettingsAsync(file, void 0, pnpSettings);
}
async function resolveSettingsImports(settings, filename) {
  return gcl().resolveSettingsImports(settings, filename);
}
async function readConfigFile(filename, relativeTo) {
  const result = await gcl().readConfigFile(filename, relativeTo);
  if (result instanceof Error) {
    throw result;
  }
  return result;
}
function getGlobalSettings() {
  return gcl().getGlobalSettings();
}
function getGlobalSettingsAsync() {
  return gcl().getGlobalSettingsAsync();
}
function getCachedFileSize() {
  return cachedFiles().size;
}
function getDefaultConfigLoader() {
  return getDefaultConfigLoaderInternal();
}
function cachedFiles() {
  return gcl()._cachedFiles;
}
async function readRawSettings(filename, relativeTo) {
  try {
    const cfg = await readConfigFile(filename, relativeTo);
    return configToRawSettings(cfg);
  } catch (e) {
    return configErrorToRawSettings(toError(e), toFileUrl(filename));
  }
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/extractImportErrors.js
function extractImportErrors(settings) {
  const imports = mergeImportRefs2(settings);
  return !imports ? [] : [...imports.values()].filter(isImportFileRefWithError);
}
function mergeImportRefs2(left, right = {}) {
  var _a3;
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = ((_a3 = right.__imports) == null ? void 0 : _a3.values()) || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : void 0;
}
function isImportFileRefWithError(ref) {
  return !!ref.error;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/readSettings.js
async function readSettings(filename, relativeToOrPnP, pnpSettings) {
  const loader2 = getDefaultConfigLoader();
  const relativeTo = typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL ? relativeToOrPnP : void 0;
  const pnp = pnpSettings ? pnpSettings : !(typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL) ? relativeToOrPnP : void 0;
  return loader2.readSettingsAsync(filename, relativeTo, pnp);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/readSettingsFiles.js
async function readSettingsFiles(filenames) {
  const settings = await Promise.all(filenames.map((filename) => readSettings(filename)));
  return settings.reduce((a, b) => mergeSettings(a, b), defaultSettings);
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/grammarTypesHelpers.js
function isPatternInclude(p) {
  return !!p.include;
}
var TypeofMatch = {
  object: true,
  string: true
};
var TypeofBegin = TypeofMatch;
var TypeofEnd = { ...TypeofBegin, undefined: true };
function isPatternMatch(pattern) {
  const p = pattern;
  return !!p.match && typeof p.match in TypeofMatch;
}
function isPatternBeginEnd(pattern) {
  const p = pattern;
  return p.begin !== void 0 && typeof p.begin in TypeofBegin && typeof p.end in TypeofEnd;
}
function isPatternPatterns(p) {
  return Array.isArray(p.patterns);
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/matchResult.js
function segmentMatch(mr) {
  const { matches, index, groups, input } = mr;
  const segments = [];
  let p = index;
  for (let groupNum = 0; groupNum < matches.length; ++groupNum) {
    const m = matches[groupNum];
    if (!m)
      continue;
    const idx0 = input.indexOf(m, p);
    const idx2 = idx0 >= p ? idx0 : input.lastIndexOf(m, p);
    if (idx2 < 0)
      continue;
    segments.push({ match: m, index: idx2, groupNum, groupName: void 0 });
    p = idx2;
  }
  const textToSeg = new Map(segments.map((s) => [s.match, s]));
  for (const [name, value] of Object.entries(groups)) {
    const s = value && textToSeg.get(value);
    if (!s)
      continue;
    s.groupName = s.groupName ? Array.isArray(s.groupName) ? [...s.groupName, name] : [s.groupName, name] : name;
  }
  return segments;
}
function createMatchResult(r, lineNumber) {
  const groups = /* @__PURE__ */ Object.create(null);
  r.groups && Object.assign(groups, r.groups);
  const matches = r;
  const match2 = r[0];
  return { index: r.index, input: r.input, match: match2, matches, groups, lineNumber };
}
function createSimpleMatchResult(match2, input, index, lineNumber) {
  const groups = /* @__PURE__ */ Object.create(null);
  return { index, input, match: match2, matches: [match2], groups, lineNumber };
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/scope.js
var import_node_assert11 = __toESM(require("assert"), 1);
var Scope = class _Scope {
  value;
  parent;
  constructor(value, parent) {
    this.value = value;
    this.parent = parent;
  }
  /**
   * Convert the scope hierarchy to a string
   * @param ltr - return ancestry from left-to-right
   * @returns the scope hierarchy as a string separated by a space.
   */
  toString(ltr = false) {
    if (!this.parent)
      return this.value;
    return ltr ? this.parent.toString(ltr) + " " + this.value : this.value + " " + this.parent.toString(ltr);
  }
  static isScope(value) {
    return value instanceof _Scope;
  }
};
var ScopePool = class {
  pool = /* @__PURE__ */ new Map();
  /**
   * Get a Scope that matches the scope. This method is idempotent.
   * @param scopeValue - a single scope value: i.e. `source.ts`
   * @param parent - optional parent Scope
   */
  getScope(scopeValue, parent) {
    const foundPoolMap = this.pool.get(scopeValue);
    const poolMap = foundPoolMap || /* @__PURE__ */ new Map();
    if (poolMap !== foundPoolMap) {
      this.pool.set(scopeValue, poolMap);
    }
    const foundScope = poolMap.get(parent);
    if (foundScope)
      return foundScope.v;
    const scope = new Scope(scopeValue, parent);
    poolMap.set(parent, { v: scope });
    return scope;
  }
  parseScope(scopes, ltr = false) {
    if (Scope.isScope(scopes))
      return scopes;
    if (isScopeLike(scopes)) {
      const parent = scopes.parent ? this.parseScope(scopes.parent) : void 0;
      return this.getScope(scopes.value, parent);
    }
    return this.parseScopeString(scopes, ltr);
  }
  parseScopeString(scopes, ltr) {
    scopes = Array.isArray(scopes) ? scopes : scopes.split(" ");
    const parentToChild = ltr ? scopes : scopes.reverse();
    let parent = void 0;
    for (const value of parentToChild) {
      parent = this.getScope(value, parent);
    }
    (0, import_node_assert11.default)(parent, "Empty scope is not allowed.");
    return parent;
  }
};
function isScopeLike(value) {
  return typeof value === "object" && !Array.isArray(value) && value.value !== void 0;
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/grammarNormalizer.js
function normalizeGrammar(grammar2) {
  return new ImplNGrammar(grammar2);
}
var SpecialRepositoryReferences = {
  $self: true,
  $base: true
};
function nPattern(p) {
  if (isPatternMatch(p))
    return normalizePatternMatch(p);
  if (isPatternBeginEnd(p))
    return normalizePatternBeginEnd(p);
  if (isPatternInclude(p))
    return normalizePatternInclude(p);
  if (isPatternPatterns(p))
    return normalizePatternsPatterns(p);
  return normalizePatternName(p);
}
function normalizePatternMatch(p) {
  const regExec = makeTestMatchFn(p.match);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    findMatch
  };
  function findMatch(line, parentRule) {
    const match2 = regExec(line);
    if (!match2)
      return void 0;
    const rule = factoryRule(parentRule, self);
    return { rule, match: match2, line };
  }
  return self;
}
function normalizePatternBeginEnd(p) {
  const patterns = normalizePatterns(p.patterns);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    beginCaptures: normalizeCapture(p.beginCaptures),
    endCaptures: normalizeCapture(p.endCaptures),
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const match2 = testBegin(line);
    if (!match2)
      return void 0;
    const rule = factoryRule(parentRule, self, findNext, end);
    return { rule, match: match2, line };
  }
  const testBegin = makeTestMatchFn(p.begin);
  const testEnd = p.end !== void 0 ? makeTestMatchFn(p.end) : () => void 0;
  function findNext(line) {
    return patterns && findInPatterns(patterns, line, this);
  }
  function end(line) {
    return testEnd(line);
  }
  return self;
}
function normalizePatternName(p) {
  const patterns = void 0;
  const self = {
    ...p,
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const rule = factoryRule(parentRule, self);
    const input = line.text.slice(line.offset);
    const match2 = createSimpleMatchResult(input, input, line.offset, line.lineNumber);
    return { rule, match: match2, line };
  }
  return self;
}
function normalizePatternInclude(p) {
  const { include } = p;
  return include.startsWith("#") || include in SpecialRepositoryReferences ? normalizePatternIncludeRef(p) : normalizePatternIncludeExt(p);
}
function normalizePatternIncludeRef(p) {
  const { include, ...rest } = p;
  const reference = include.startsWith("#") ? include.slice(1) : include;
  const self = {
    ...rest,
    reference,
    findMatch
  };
  function findMatch(line, parentRule) {
    const pat = parentRule.repository[reference];
    if (pat === void 0)
      throw new Error(`Unknown Include Reference ${include}`);
    return pat.findMatch(line, parentRule);
  }
  return self;
}
function normalizePatternIncludeExt(p) {
  function findMatch(_line) {
    return void 0;
  }
  const self = {
    ...p,
    findMatch
  };
  return self;
}
function normalizePatternsPatterns(p) {
  return new ImplNPatternPatterns(p);
}
function findInPatterns(patterns, line, rule) {
  let r = void 0;
  for (const pat of patterns) {
    if (pat.disabled)
      continue;
    const er = pat.findMatch(line, rule);
    if ((er == null ? void 0 : er.match) !== void 0 && !er.rule.pattern.disabled) {
      r = r && r.match && r.match.index <= er.match.index && r || er;
    }
  }
  return r;
}
function normalizePatterns(patterns) {
  if (!patterns)
    return void 0;
  return patterns.map((p) => typeof p === "string" ? { include: p } : p).map(nPattern);
}
var emptyRepository = Object.freeze(/* @__PURE__ */ Object.create(null));
function normalizePatternRepository(rep) {
  if (!rep)
    return emptyRepository;
  return normalizeRepository(rep);
}
function normalizeRepository(rep) {
  const repository2 = /* @__PURE__ */ Object.create(null);
  for (const [key, pat] of Object.entries(rep)) {
    repository2[key] = nPattern(pat);
  }
  return repository2;
}
var ruleCounter = 0;
function factoryRuleBase(parent, pattern, repository2, grammar2, findNext, end) {
  const depth = parent ? parent.depth + 1 : 0;
  return {
    id: ruleCounter++,
    grammar: grammar2,
    pattern,
    parent,
    repository: repository2,
    depth,
    findNext,
    end
  };
}
function factoryRule(parent, pattern, findNext, end) {
  return factoryRuleBase(parent, pattern, parent.repository, parent.grammar, findNext, end);
}
function normalizeCapture(cap) {
  if (cap === void 0)
    return void 0;
  if (typeof cap === "string")
    return { [0]: cap };
  const capture = /* @__PURE__ */ Object.create(null);
  for (const [key, pat] of Object.entries(cap)) {
    capture[key] = typeof pat === "string" ? pat : normalizePatternName(pat).name;
  }
  return capture;
}
function makeTestMatchFn(reg) {
  if (typeof reg === "string")
    return matchString(reg);
  return matchRegExp(reg);
}
function matchString(s) {
  return (line) => {
    const input = line.text;
    const index = input.indexOf(s, line.offset);
    if (index < 0)
      return void 0;
    return createSimpleMatchResult(s, input, index, line.lineNumber);
  };
}
function matchRegExp(r) {
  return (line) => {
    const rg = RegExp(r, "gm");
    rg.lastIndex = line.offset;
    const m = rg.exec(line.text);
    return (m && createMatchResult(m, line.lineNumber)) ?? void 0;
  };
}
function extractScope(er, isContent = true) {
  const scope = [];
  for (let rule = er; rule; rule = rule.parent) {
    const pattern = rule.pattern;
    const { name, contentName } = pattern;
    if (contentName && isContent) {
      scope.push(contentName);
    }
    if (name !== void 0) {
      scope.push(name);
    }
    isContent = true;
  }
  return er.grammar.scopePool.parseScope(scope);
}
var ImplNGrammar = class {
  scopeName;
  name;
  comment;
  disabled;
  patterns;
  repository;
  grammarName;
  self;
  scopePool;
  constructor(grammar2) {
    this.scopeName = grammar2.scopeName;
    this.name = grammar2.scopeName;
    this.comment = grammar2.comment;
    this.disabled = grammar2.disabled;
    this.grammarName = grammar2.name;
    const self = nPattern({
      patterns: [{ patterns: grammar2.patterns }]
    });
    const repository2 = normalizePatternRepository(grammar2.repository);
    this.patterns = self.patterns;
    this.repository = repository2;
    this.self = self;
    this.scopePool = new ScopePool();
  }
  begin(parentRule) {
    const patterns = this.patterns;
    function grammarToRule(grammar2, baseGrammar, parent) {
      const repository2 = /* @__PURE__ */ Object.create(null);
      Object.assign(repository2, grammar2.repository);
      repository2["$self"] = grammar2.self;
      repository2["$base"] = repository2["$base"] || baseGrammar.self;
      function findNext(line) {
        return findInPatterns(patterns, line, this);
      }
      function end(_line) {
        return void 0;
      }
      return factoryRuleBase(parent, grammar2, repository2, grammar2, findNext, end);
    }
    return grammarToRule(this, (parentRule == null ? void 0 : parentRule.grammar) ?? this, parentRule);
  }
};
var ImplNPatternPatterns = class {
  name;
  comment;
  disabled;
  patterns;
  constructor(p) {
    const { name, comment, disabled, ...rest } = p;
    this.patterns = normalizePatterns(rest.patterns);
    this.name = name;
    this.comment = comment;
    this.disabled = disabled;
  }
  findMatch(line, parentRule) {
    var _a3;
    const patterns = this.patterns;
    const rule = factoryRule(parentRule, this, findNext);
    function findNext(line2) {
      return findInPatterns(patterns, line2, this);
    }
    return (_a3 = rule.findNext) == null ? void 0 : _a3.call(rule, line);
  }
};

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/grammar.js
function compileGrammar(grammar2) {
  return normalizeGrammar(grammar2);
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/tokenizeLine.js
var import_node_assert12 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/util.js
function isDefined5(t) {
  return t !== void 0 && t !== null;
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/processors/procMatchingRule.js
function applyCaptureToBeginOrMatch(matchRuleResult) {
  const { match: match2, rule } = matchRuleResult;
  const bePattern = rule.pattern;
  const captures = bePattern.beginCaptures ?? bePattern.captures;
  return applyCaptures(rule, match2, captures);
}
function applyCaptureToEnd(rule, match2) {
  const { pattern } = rule;
  const bePattern = pattern;
  const captures = bePattern.endCaptures ?? bePattern.captures;
  return applyCaptures(rule, match2, captures);
}
function applyCaptures(rule, match2, captures) {
  const scope = extractScope(rule, false);
  const pool2 = rule.grammar.scopePool;
  const text = match2.match;
  const input = match2.input;
  const range = [match2.index, match2.index + text.length, match2.lineNumber];
  if (!text && !captures)
    return [];
  if (!captures) {
    const tokenized = {
      scope,
      text,
      range
    };
    return [tokenized];
  }
  const captureScopes = new Map(Object.entries(captures));
  const cap0 = captureScopes.get("0");
  if (captureScopes.size === 1 && cap0) {
    const tokenized = {
      scope: rule.grammar.scopePool.getScope(cap0, scope),
      text,
      range
    };
    return [tokenized];
  }
  const min3 = match2.index;
  const max4 = match2.index + text.length;
  function trimSegment(seg) {
    const { index, match: match3 } = seg;
    const right = match3.length;
    if (index >= min3 && right <= max4)
      return seg;
    if (index >= max4 || right < min3)
      return void 0;
    const a = Math.max(index, min3) - index;
    const b = Math.min(right, max4) - index;
    const text2 = match3.slice(a, b);
    return {
      ...seg,
      index: index + a,
      match: text2
    };
  }
  const segments = segmentMatch(match2).map(trimSegment).filter(isDefined5);
  function processSegments(segments2) {
    const base = segments2[0];
    const root = {
      a: base.index,
      b: base.index + base.match.length,
      s: { seg: base }
    };
    let m;
    for (let i = 1; i < segments2.length; ++i) {
      const seg = segments2[i];
      const index = seg.index;
      const end = index + seg.match.length;
      m = m && m.a <= index ? m : root;
      while (m && m.b <= index) {
        m = m.n;
      }
      while (m && m.a < end) {
        if (m.a < index) {
          const n = { ...m, a: index };
          m.n = n;
          m.b = index;
          m = n;
        }
        if (m.b > end) {
          const n = { ...m, a: end };
          m.b = end;
          m.n = n;
        }
        m.s = { seg, next: m.s };
        m = m.n;
      }
    }
    return root;
  }
  function segChainToScope(chain) {
    function* _chain(chain2) {
      while (chain2) {
        const seg = chain2.seg;
        if (seg.groupName) {
          if (Array.isArray(seg.groupName)) {
            yield* seg.groupName;
          } else {
            yield seg.groupName;
          }
        }
        yield seg.groupNum.toString();
        chain2 = chain2.next;
      }
    }
    const scopeValues = [..._chain(chain)].map((cap) => captureScopes.get(cap)).filter(isDefined5).reverse();
    return scopeValues.reduce((s, v) => pool2.getScope(v, s), scope);
  }
  const merged = processSegments(segments);
  function* emit(m) {
    while (m) {
      const t = {
        text: input.slice(m.a, m.b),
        range: [m.a, m.b, match2.lineNumber],
        scope: segChainToScope(m.s)
      };
      yield t;
      m = m.n;
    }
  }
  const parsedText = [...emit(merged)];
  return parsedText;
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/tokenizeLine.js
function tokenizeLine(line, rule) {
  var _a3, _b, _c, _d, _e;
  const text = line.text;
  const lineLen = line.text.length;
  const parsedText = [];
  let ctx = buildContext({ ...line, offset: 0, anchor: -1 }, rule);
  while (ctx.line.offset <= lineLen) {
    let endMatch = (_b = (_a3 = ctx.rule).end) == null ? void 0 : _b.call(_a3, ctx.line);
    while ((endMatch == null ? void 0 : endMatch.index) === ctx.line.offset) {
      parsedText.push(...applyCaptureToEnd(ctx.rule, endMatch));
      ctx = findParentWithEnd(ctx);
      ctx.line.offset = endMatch.index + endMatch.match.length;
      endMatch = (_d = (_c = ctx.rule).end) == null ? void 0 : _d.call(_c, ctx.line);
    }
    if (ctx.line.offset >= lineLen)
      break;
    const { line: line2, rule: rule2 } = ctx;
    const offset = line2.offset;
    const match2 = (_e = rule2.findNext) == null ? void 0 : _e.call(rule2, line2);
    const limit = (endMatch == null ? void 0 : endMatch.index) ?? lineLen;
    const emitTil = match2 ? Math.min(match2.match.index, limit) : limit;
    if (offset < emitTil) {
      const scope = extractScope(rule2);
      const start = offset;
      const end = emitTil;
      parsedText.push({
        scope,
        text: text.slice(start, end),
        range: [start, end, line2.lineNumber]
      });
      ctx.line.offset = emitTil;
    }
    if (!match2 || endMatch && endMatch.index <= match2.match.index) {
      continue;
    }
    parsedText.push(...applyCaptureToBeginOrMatch(match2));
    line2.anchor = match2.match.index + match2.match.match.length;
    line2.offset = line2.anchor;
    ctx = findNearestWithEnd(buildContext(line2, match2.rule));
  }
  return toParseLineResult(line, ctx.rule, parsedText);
}
function* tokenizeTextIterable(text, grammar2) {
  const lines = text.split(/(?<=\r\n|\n|\r(?!\n))/);
  const rule = grammar2.begin();
  let documentOffset = 0;
  let tr = tokenizeLine({ text: lines[0], lineNumber: 0, documentOffset }, rule);
  documentOffset += lines[0].length;
  yield toParsedLine(tr);
  for (let i = 1; i < lines.length; ++i) {
    const line = { text: lines[i], lineNumber: i, documentOffset };
    documentOffset += line.text.length;
    tr = tr.parse(line);
    yield toParsedLine(tr);
  }
}
function toParsedLine(pr) {
  const { tokens: parsedText, line, offset } = pr;
  return { tokens: parsedText, line, offset };
}
function toParseLineResult(line, rule, parsedText) {
  return {
    tokens: parsedText,
    line,
    offset: line.documentOffset,
    parse: (line2) => tokenizeLine(line2, rule)
  };
}
function buildContext(line, rule) {
  const rules = calcRuleStack(rule);
  const numRules = rules.length;
  const rootNum = numRules - 1;
  const rootRule = rules[rootNum];
  const rootContext = {
    line,
    rule: rootRule
  };
  let ctx = rootContext;
  for (let i = rootNum - 1; i >= 0; --i) {
    const rule2 = rules[i];
    const line2 = ctx.line;
    ctx = {
      line: line2,
      rule: rule2,
      parent: ctx
    };
  }
  return ctx;
}
function calcRuleStack(rule) {
  const rules = [];
  let r = rule;
  while (r) {
    rules.push(r);
    r = r.parent;
  }
  return rules;
}
function must(t, msg = "Must be defined") {
  (0, import_node_assert12.default)(t !== void 0 && t !== null, msg);
  return t;
}
function findParentWithEnd(ctx) {
  return findNearestWithEnd(must(ctx.parent));
}
function findNearestWithEnd(ctx) {
  while (!ctx.rule.end) {
    ctx = must(ctx.parent);
  }
  return ctx;
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/grammars/typescript.js
var repository = {
  statements: {
    name: "code.ts",
    patterns: [
      "#keyword",
      "#regexp",
      "#string",
      "#comment",
      "#braces",
      "#punctuation",
      "#space",
      { name: "identifier", match: /[^\s;,!|&:^%{}[\]()*/+=<>]+/ }
    ]
  },
  keyword: {
    patterns: ["#keywordBase", "#standardTypes", "#standardLib"]
  },
  keywordBase: {
    name: "keyword.typescript.ts",
    match: /\b(?:any|as|async|await|bigint|boolean|break|case|catch|const|continue|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|in|instanceof|interface|import|let|map|module|new|new|null|number|of|package|private|public|require|return|set|static|string|super|switch|this|throw|true|try|type|typeof|unknown|undefined|var|void|while|yield)\b/
  },
  standardTypes: {
    name: "keyword.type.ts",
    match: /\b(?:Promise|Record|Omit|Extract|Exclude|BigInt|Array)\b/
  },
  standardLib: {
    name: "keyword.lib.ts",
    match: /\b(?:console|process|window)\b/
  },
  string: {
    patterns: ["#string_q_single", "#string_q_double", "#string_template"]
  },
  string_q_single: {
    name: "string.quoted.single.ts",
    begin: "'",
    end: /'|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_q_double: {
    name: "string.quoted.double.ts",
    begin: '"',
    end: /"|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_template: {
    name: "string.template.ts",
    begin: "`",
    end: "`",
    captures: "punctuation.string.ts",
    patterns: [
      {
        name: "meta.template.expression.ts",
        contentName: "meta.embedded.line.ts",
        begin: "${",
        end: "}",
        patterns: ["#statements"],
        captures: "punctuation.definition.template.expression.ts"
      },
      { include: "#string_character_escape" }
    ]
  },
  string_character_escape: {
    name: "constant.character.escape.ts",
    match: /\\(x[0-9A-Fa-f]{2}|[0-3][0-7]{0,2}|[4-7][0-7]?|u[0-9A-Fa-f]{4}|.|\r?\n?$)/
  },
  braces: {
    patterns: [
      {
        begin: "(",
        end: ")",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "{",
        end: "}",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "[",
        end: "]",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      }
    ]
  },
  punctuation: {
    name: "punctuation.ts",
    match: /[-;:,!|&^%*/+=<>\n\r]/
  },
  space: {
    name: "punctuation.space.ts",
    match: /\s+/
  },
  comment: {
    patterns: [
      {
        name: "comment.line.ts",
        comment: "line comment",
        begin: "//",
        end: /(?=$)/,
        captures: "punctuation.definition.comment.ts"
      },
      {
        name: "comment.block.documentation.ts",
        comment: "DocBlock",
        begin: /\/\*\*(?!\/)/,
        captures: "punctuation.definition.comment.ts",
        end: "*/"
      },
      {
        name: "comment.block.ts",
        begin: "/*",
        end: "*/",
        captures: "punctuation.definition.comment.ts"
      }
    ]
  },
  regexp: {
    name: "regexp.ts",
    begin: /\/(?![/*])/,
    end: /\/([a-z]*)/i,
    beginCaptures: "punctuation.begin.regexp.ts",
    endCaptures: "punctuation.end.regexp.ts",
    patterns: ["#regexp_escape", "#regexp_brace"]
  },
  regexp_escape: {
    name: "escape.regexp.ts",
    match: /\\./
  },
  regexp_brace: {
    name: "brace.regexp.ts",
    begin: "[",
    end: "]",
    contentName: "character-class.regexp.ts",
    patterns: ["#regexp_escape"]
  }
};
var grammar = {
  name: "TypeScript",
  scopeName: "source.ts",
  patterns: [
    {
      name: "comment.line.shebang.ts",
      match: /^#!.*(?=$)/
    },
    {
      include: "#statements"
    }
  ],
  repository
};

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/mappers/appendMappedText.js
var import_node_assert13 = __toESM(require("assert"), 1);
function appendMappedText(a, b) {
  if (!a.map && !b.map) {
    return { text: a.text + b.text };
  }
  const aLen = a.text.length;
  const bLen = b.text.length;
  const aMap = [0, 0, ...a.map || [0, 0, aLen, aLen]];
  const bMap = [0, 0, ...b.map || [0, 0, bLen, bLen]];
  (0, import_node_assert13.default)(aMap[aMap.length - 1] === aLen);
  (0, import_node_assert13.default)(bMap[bMap.length - 1] === bLen);
  (0, import_node_assert13.default)((aMap.length & 1) === 0);
  (0, import_node_assert13.default)((bMap.length & 1) === 0);
  return {
    text: a.text + b.text,
    map: joinMaps(aMap, bMap)
  };
}
function joinMaps(aMap, bMap) {
  const n = aMap.length - 1;
  const offsets = [aMap[n - 1], aMap[n]];
  const ab = [...aMap, ...bMap.map((v, i) => v + offsets[i & 1])];
  const r = [0, 0];
  let last0 = 0, last1 = 0;
  for (let i = 0; i < ab.length; i += 2) {
    const v0 = ab[i];
    const v1 = ab[i + 1];
    if (v0 === last0 && v1 === last1) {
      continue;
    }
    r.push(v0, v1);
    last0 = v0;
    last1 = v1;
  }
  return r;
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/mappers/typescript.js
var hexChars = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15
};
var escapeChars = {
  t: "	",
  n: "\n",
  r: "\r",
  b: "\b",
  "\\": "\\",
  '"': '"',
  "'": "'",
  "\n": ""
};
function mapRawString(text) {
  const end = text.length;
  let t = "";
  const map3 = [];
  const isHex = /^[0-9a-fA-F]+$/;
  let i, j;
  for (i = 0, j = 0; i < end; ++i) {
    let parsed;
    const ti = text[i];
    if (ti === "\\") {
      map3.push(i, j);
      const tc = text[++i];
      const ec = escapeChars[tc];
      if (ec) {
        t += ec;
        j += ec.length;
        map3.push(i, j);
        continue;
      }
      switch (tc) {
        case "u": {
          {
            let char;
            let end2;
            if (text[i + 1] !== "{") {
              const digits = text.slice(i + 1, i + 5);
              parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
              char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              end2 = i + 4;
            } else {
              for (end2 = i + 2; text[end2] in hexChars; ++end2) {
              }
              if (text[end2] !== "}") {
                char = "";
              } else {
                const digits = text.slice(i + 2, end2);
                parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
                char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              }
            }
            if (!char) {
              t += tc;
              j += 1;
            } else {
              t += char;
              j += char.length;
              i = end2;
            }
          }
          break;
        }
        case "x": {
          {
            const digits = text.slice(i + 1, i + 3);
            parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
            if (Number.isNaN(parsed)) {
              t += tc;
              j += 1;
            } else {
              t += String.fromCodePoint(parsed);
              i += 2;
              ++j;
            }
          }
          break;
        }
        case "0": {
          t += "0";
          j += 1;
          break;
        }
        case "\r": {
          i += text[i + 1] === "\n" ? 1 : 0;
          break;
        }
        case "\n": {
          break;
        }
        case void 0: {
          break;
        }
        default: {
          t += tc;
          ++j;
          break;
        }
      }
      map3.push(i + 1, j);
      continue;
    }
    t += ti;
    ++j;
  }
  if (map3.length) {
    const ii = map3[map3.length - 2];
    const jj = map3[map3.length - 1];
    if (ii !== i || jj !== j) {
      map3.push(i, j);
    }
  }
  return {
    text: t,
    map: map3
  };
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parser/parser.js
function mapTokenizedLine(tl) {
  return tl.tokens.map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine), opFlattenSync());
}
function createParser(grammar2, name, transform2 = mapTokenizedLines) {
  function parse3(content, filename) {
    const parsedTexts = pipeSync(tokenizeTextIterable(content, grammar2), transform2);
    return { content, filename, parsedTexts };
  }
  return { name, parse: parse3 };
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parsers/typescript/TypeScriptParser.js
var tsGrammar = compileGrammar(grammar);
var pool = new ScopePool();
var useScope = /* @__PURE__ */ new WeakMap();
function* transform(texts) {
  for (const parsed of texts) {
    if (doesScopeMatch(parsed.scope, "constant.character.escape.ts")) {
      const mapped = mapRawString(parsed.text);
      const scope = parsed.scope ? pool.parseScope(parsed.scope) : void 0;
      yield {
        text: mapped.text,
        scope: scope == null ? void 0 : scope.parent,
        map: mapped.map,
        range: parsed.range
      };
      continue;
    }
    yield parsed;
  }
}
function* mergeStringResults(results) {
  let last;
  for (const next of results) {
    if (!doesScopeMatch(next.scope, "string.")) {
      if (last) {
        yield last;
        last = void 0;
      }
      yield next;
      continue;
    }
    if (!last) {
      last = next;
      continue;
    }
    if (next.scope !== last.scope || last.range[1] !== next.range[0]) {
      yield last;
      last = next;
      continue;
    }
    last = mergeParsedText(last, next);
  }
  if (last)
    yield last;
}
function mergeParsedText(a, b) {
  const abT = appendMappedText(a, b);
  const ab = {
    text: abT.text,
    scope: a.scope,
    range: [a.range[0], b.range[1]],
    map: abT.map,
    delegate: a.delegate
  };
  return ab;
}
function filterScope(scope) {
  const cached = useScope.get(scope);
  if (cached !== void 0)
    return cached;
  const value = scope.value;
  const use = !value.startsWith("punctuation") && !value.startsWith("keyword.");
  useScope.set(scope, use);
  return use;
}
function mapTokenizedLine2(tl) {
  return tl.tokens.filter((t) => filterScope(t.scope)).map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines2(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine2), opFlattenSync(), transform, mergeStringResults);
}
var parser = createParser(tsGrammar, "typescript", mapTokenizedLines2);
function doesScopeMatch(s, match2) {
  if (!s)
    return false;
  return typeof s === "string" ? s.startsWith(match2) : s.value.startsWith(match2);
}

// node_modules/.pnpm/cspell-grammar@8.14.2/node_modules/cspell-grammar/dist/parsers/index.js
var parsers2 = [parser];

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Models/PatternRegExp.js
var PatternRegExp = class extends RegExp {
  constructor(pattern) {
    super(pattern);
  }
  toJSON() {
    return this.toString();
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/LanguageSettings.js
var defaultLocale = "en";
var defaultLanguageSettings = [];
function getDefaultLanguageSettings() {
  return defaultLanguageSettings;
}
function localesToList(locales) {
  return stringToList(locales.replaceAll(/\s+/g, ","));
}
function stringToList(sList) {
  return sList.replaceAll(/[|;]/g, ",").split(",").map((s) => s.trim()).filter((s) => !!s);
}
function memorizer(resolver) {
  const cache4 = createAutoResolveCache();
  return (k) => cache4.get(k, resolver);
}
var _normalizeLanguageId = memorizer(__normalizeLanguageId);
function __normalizeLanguageId(langId) {
  const langIds = stringToList(langId);
  return new Set(langIds.map((a) => a.toLowerCase()));
}
function normalizeLanguageId(langId) {
  return _normalizeLanguageId(typeof langId === "string" ? langId : langId.join(","));
}
var _normalizeLocale = memorizer(__normalizeLocale);
function __normalizeLocale(locale) {
  const locales = localesToList(locale);
  return new Set(locales.map((locale2) => locale2.toLowerCase().replaceAll(/[^a-z]/g, "")));
}
function normalizeLocale2(locale) {
  locale = typeof locale === "string" ? locale : locale.join(",");
  return _normalizeLocale(locale);
}
function normalizeLocaleIntl(locale) {
  const values = [...normalizeLocale2(locale)].map((locale2) => locale2.replace(/^([a-z]{2})-?([a-z]{2})$/, (_, lang, locale3) => locale3 ? `${lang}-${locale3.toUpperCase()}` : lang));
  return new Set(values);
}
function isLocaleInSet(locale, setOfLocals) {
  const locales = normalizeLocale2(locale);
  return doSetsIntersect(locales, setOfLocals);
}
var regExpValidIntlLocaleStrict = /^[a-z]{2}(-[A-Z]{2})?$/;
var regExpValidIntlLocale = new RegExp(regExpValidIntlLocaleStrict, "i");
function isValidLocaleIntlFormat(locale, strict = false) {
  if (typeof locale === "string")
    return strict ? regExpValidIntlLocaleStrict.test(locale) : regExpValidIntlLocale.test(locale);
  for (const item of locale) {
    if (!isValidLocaleIntlFormat(item, strict))
      return false;
  }
  return locale.length > 0;
}
var cacheCalcSettingsForLanguage = createAutoResolveWeakCache2();
function calcSettingsForLanguage(languageSettings, languageId, locale) {
  return cacheCalcSettingsForLanguage.get(languageSettings, () => new AutoResolveCache()).get(languageId, () => new AutoResolveCache()).get(locale, () => _calcSettingsForLanguage(languageSettings, languageId, locale));
}
function _calcSettingsForLanguage(languageSettings, languageId, locale) {
  languageId = languageId.toLowerCase();
  const allowedLocals = normalizeLocale2(locale);
  const ls = languageSettings.filter((s) => doesLanguageSettingMatchLanguageId(s, languageId)).filter((s) => !s.locale || s.locale === "*" || isLocaleInSet(s.locale, allowedLocals)).map((langSetting) => {
    const { languageId: _languageId, locale: _locale, ...s } = langSetting;
    return s;
  }).reduce((langSetting, setting) => mergeSettings(langSetting, setting), {});
  ls.languageId = languageId;
  ls.locale = locale;
  return ls;
}
var cacheDoesLanguageSettingMatchLanguageId = createAutoResolveWeakCache2();
function doesLanguageSettingMatchLanguageId(s, languageId) {
  return cacheDoesLanguageSettingMatchLanguageId.get(s, () => new AutoResolveCache()).get(languageId, () => _doesLanguageSettingMatchLanguageId(s, languageId));
}
function _doesLanguageSettingMatchLanguageId(s, languageId) {
  const languageSettingsLanguageIds = s.languageId;
  if (!languageSettingsLanguageIds || languageSettingsLanguageIds === "*")
    return true;
  const ids = normalizeLanguageId(languageSettingsLanguageIds);
  if (ids.has(languageId))
    return true;
  if (ids.has("!" + languageId))
    return false;
  const numExcludes = [...ids].filter((id) => id.startsWith("!")).length;
  return numExcludes === ids.size;
}
function calcUserSettingsForLanguage(settings, languageId) {
  const { languageSettings = [], language: locale = defaultLocale, allowCompoundWords, enabled } = settings;
  const langSettings = {
    allowCompoundWords,
    enabled,
    ...calcSettingsForLanguage(languageSettings, languageId, locale)
  };
  return mergeSettings(settings, langSettings);
}
function calcSettingsForLanguageId(baseSettings, languageId) {
  const langIds = ["*", ...normalizeLanguageId(languageId)];
  const langSettings = langIds.reduce((settings, languageId2) => {
    return calcUserSettingsForLanguage(settings, languageId2);
  }, baseSettings);
  return langSettings;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/RegExpPatterns.js
var regExMatchUrls = /(?:https?|ftp):\/\/[^\s"]+/gi;
var regExHRef = /\bhref\s*=\s*".*?"/gi;
var regExMatchCommonHexFormats = /(?:#[0-9a-f]{3,8})|(?:0x[0-9a-f]+)|(?:\\u[0-9a-f]{4})|(?:\\x\{[0-9a-f]{4}\})/gi;
var regExCommitHash = /\b(?![a-f]+\b)(?:0x)?[0-9a-f]{7,}\b/gi;
var regExCommitHashLink = /\[[0-9a-f]{7,}\]/gi;
var regExCStyleHexValue = /\b0x[0-9a-f_]+\b/gi;
var regExCSSHexValue = /#[0-9a-f]{3,8}\b/gi;
var regExUUID = /\b[0-9a-fx]{8}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{12}\b/gi;
var regExUnicodeRef = /\bU\+[0-9a-f]{4,5}(?:-[0-9a-f]{4,5})?/gi;
var regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b(?!-)[\s\S]*?((?:\1\s*enable\b)|$)/gi;
var regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
var regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
var regExIgnoreSpellingDirectives = /\bc?spell(?:-?checker)?::?\s*ignoreRegExp.*/gim;
var regExPublicKey = /-{5}BEGIN\s+((?:RSA\s+)?PUBLIC\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExCert = /-{5}BEGIN\s+(CERTIFICATE|(?:RSA\s+)?(?:PRIVATE|PUBLIC)\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExSshRSA = /ssh-rsa\s+[a-z0-9/+]{28,}={0,3}(?![a-z0-9/+=])/gi;
var regExEscapeCharacters2 = /\\(?:[anrvtbf]|[xu][a-f0-9]+)/gi;
var regExBase64 = /(?<![A-Za-z0-9/+])(?:[A-Za-z0-9/+]{40,})(?:\s^\s*[A-Za-z0-9/+]{40,})*(?:\s^\s*[A-Za-z0-9/+]+=*)?(?![A-Za-z0-9/+=])/gm;
var regExBase64SingleLine = /(?<![A-Za-z0-9/+])(?=[^/]|[/][A-Za-z0-9/+]+?[=+])(?![A-Za-z/]+(?![A-Za-z0-9/+=]))(?=[A-Za-z0-9/+=]*?(?:[A-Z]{2}|[0-9]{2}))(?:[A-Za-z0-9/+]{4}){10,}(?:[A-Za-z0-9/+]{3}={1}|[A-Za-z0-9/+]{2}={2}|[A-Za-z0-9/+]{1}={3})?(?![A-Za-z0-9/+=])(?=$|[:.,"'\\)])/gm;
var regExBase64MultiLine = /(?<![A-Za-z0-9/+])["']?(?:[A-Za-z0-9/+]{40,})["']?(?:\s^\s*["']?[A-Za-z0-9/+]{40,}["']?)+(?:\s^\s*["']?[A-Za-z0-9/+]+={0,3}["']?)?(?![A-Za-z0-9/+=])/gm;
var regExPhpHereDoc = /<<<['"]?(\w+)['"]?[\s\S]+?^\1;/gm;
var regExString = /(?:(['"]).*?(?<![^\\]\\(\\\\)*)\1)|(?:`[\s\S]*?(?<![^\\]\\(\\\\)*)`)/g;
var regExCStyleComments = /(?<!\w:)(?:\/\/.*)|(?:\/\*[\s\S]*?\*\/)/g;
var regExEmail = /<?\b[\w.\-+]{1,128}@\w{1,63}(\.\w{1,63}){1,4}\b>?/gi;
var regExRepeatedChar = /^(\w)\1{3,}$/i;
var regExSha = /\bsha\d+-[a-z0-9+/]{25,}={0,3}/gi;
var regExHashStrings = /(?:\b(?:sha\d+|md5|base64|crypt|bcrypt|scrypt|security-token|assertion)[-,:$=]|#code[/])[-\w/+%.]{25,}={0,3}(?:(['"])\s*\+?\s*\1?[-\w/+%.]+={0,3})*(?![-\w/+=%.])/gi;

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/DefaultSettings.js
var defaultConfigFile = () => resolveConfigModule(defaultConfigFileModuleRef);
var regExpSpellCheckerDisable = [
  new PatternRegExp(regExSpellingGuardBlock),
  new PatternRegExp(regExSpellingGuardLine),
  new PatternRegExp(regExSpellingGuardNext)
];
var predefinedPatterns = [
  // Exclude patterns
  { name: "CommitHash", pattern: regExCommitHash },
  { name: "CommitHashLink", pattern: regExCommitHashLink },
  { name: "CStyleHexValue", pattern: regExCStyleHexValue },
  { name: "CSSHexValue", pattern: regExCSSHexValue },
  { name: "Urls", pattern: regExMatchUrls },
  { name: "HexValues", pattern: regExMatchCommonHexFormats },
  { name: "SpellCheckerDisable", pattern: regExpSpellCheckerDisable },
  { name: "PublicKey", pattern: regExPublicKey },
  { name: "RsaCert", pattern: regExCert },
  { name: "SshRsa", pattern: regExSshRSA },
  { name: "EscapeCharacters", pattern: regExEscapeCharacters2 },
  { name: "Base64", pattern: regExBase64 },
  { name: "Base64SingleLine", pattern: regExBase64SingleLine },
  { name: "Base64MultiLine", pattern: regExBase64MultiLine },
  { name: "Email", pattern: regExEmail },
  { name: "SHA", pattern: regExSha },
  { name: "HashStrings", pattern: regExHashStrings },
  { name: "UnicodeRef", pattern: regExUnicodeRef },
  { name: "UUID", pattern: regExUUID },
  { name: "href", pattern: regExHRef },
  { name: "SpellCheckerDisableBlock", pattern: regExSpellingGuardBlock },
  { name: "SpellCheckerDisableLine", pattern: regExSpellingGuardLine },
  { name: "SpellCheckerDisableNext", pattern: regExSpellingGuardNext },
  { name: "SpellCheckerIgnoreInDocSetting", pattern: regExIgnoreSpellingDirectives },
  // Include Patterns
  { name: "PhpHereDoc", pattern: regExPhpHereDoc },
  { name: "string", pattern: regExString },
  { name: "CStyleComment", pattern: regExCStyleComments },
  { name: "Everything", pattern: ".*" }
];
var defaultRegExpPatterns = [...predefinedPatterns].map(normalizePattern2);
var definedDefaultRegExpExcludeList = [
  "SpellCheckerDisable",
  "SpellCheckerIgnoreInDocSetting",
  "Urls",
  "Email",
  "RsaCert",
  "SshRsa",
  "Base64MultiLine",
  "Base64SingleLine",
  "CommitHash",
  "CommitHashLink",
  "CStyleHexValue",
  "CSSHexValue",
  "SHA",
  "HashStrings",
  "UnicodeRef",
  "UUID"
];
var defaultRegExpExcludeList = definedDefaultRegExpExcludeList;
var _defaultSettingsBasis = Object.freeze(createCSpellSettingsInternal({
  id: "static_defaults",
  language: "en",
  name: "Static Defaults",
  enabled: true,
  enabledLanguageIds: [],
  maxNumberOfProblems: 100,
  numSuggestions: 10,
  suggestionsTimeout: 500,
  suggestionNumChanges: 3,
  words: [],
  userWords: [],
  ignorePaths: [],
  allowCompoundWords: false,
  patterns: defaultRegExpPatterns,
  ignoreRegExpList: [],
  languageSettings: [],
  source: { name: "defaultSettings" },
  reporters: [],
  plugins: [{ parsers: parsers2 }]
}));
var _defaultSettings = Object.freeze(createCSpellSettingsInternal({
  ..._defaultSettingsBasis,
  enabledLanguageIds: [
    "ada",
    "csharp",
    "go",
    "javascript",
    "javascriptreact",
    "json",
    "markdown",
    "mdx",
    "php",
    "plaintext",
    "python",
    "text",
    "typescript",
    "typescriptreact",
    "haskell",
    "html",
    "css",
    "less",
    "scss",
    "latex",
    "ruby",
    "rust",
    "shellscript",
    "toml"
  ],
  ignoreRegExpList: defaultRegExpExcludeList,
  languageSettings: getDefaultLanguageSettings()
}));
async function resolveConfigModule(configModuleName) {
  return (await resolveFile(configModuleName, srcDirectory)).filename;
}
function normalizePattern2(pat) {
  const { name, pattern, description } = pat;
  if (!(pattern instanceof RegExp))
    return pat;
  return {
    name,
    pattern: new PatternRegExp(pattern),
    description
  };
}
var DefaultSettingsLoader = class {
  settings = void 0;
  pending = void 0;
  constructor() {
    this.getDefaultSettingsAsync().catch(() => void 0);
  }
  getDefaultSettingsAsync(useDefaultDictionaries = true) {
    if (!useDefaultDictionaries) {
      return Promise.resolve(_defaultSettingsBasis);
    }
    if (this.settings)
      return Promise.resolve(this.settings);
    if (this.pending)
      return this.pending;
    this.pending = (async () => {
      const defaultConfigLocation = await defaultConfigFile();
      const jsonSettings = await readSettings(defaultConfigLocation);
      this.settings = mergeSettings(_defaultSettings, jsonSettings);
      if (jsonSettings.name !== void 0) {
        this.settings.name = jsonSettings.name;
      } else {
        delete this.settings.name;
      }
      return this.settings;
    })();
    return this.pending;
  }
};
var defaultSettingsLoader = new DefaultSettingsLoader();
function getDefaultSettings(useDefaultDictionaries = true) {
  return defaultSettingsLoader.getDefaultSettingsAsync(useDefaultDictionaries);
}
function getDefaultBundledSettingsAsync() {
  return defaultSettingsLoader.getDefaultSettingsAsync();
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/index.link.js
var index_link_exports = {};
__export(index_link_exports, {
  addPathsToGlobalImports: () => addPathsToGlobalImports,
  listGlobalImports: () => listGlobalImports,
  removePathsFromGlobalImports: () => removePathsFromGlobalImports
});

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/link.js
var fs7 = __toESM(require("fs"), 1);
var Path4 = __toESM(require("path"), 1);
async function listGlobalImports() {
  const globalSettings = await getRawGlobalSettings();
  const list = (await resolveImports(globalSettings)).map(({ filename, settings, error }) => ({
    filename,
    error,
    id: settings.id,
    name: settings.name,
    dictionaryDefinitions: settings.dictionaryDefinitions,
    languageSettings: settings.languageSettings,
    package: findPackageForCSpellConfig(Path4.dirname(filename))
  }));
  return {
    list,
    globalSettings
  };
}
function isString2(s) {
  return s !== void 0;
}
async function addPathsToGlobalImports(paths) {
  const resolvedSettings = await Promise.all(paths.map(resolveSettings));
  const hasError = resolvedSettings.some((r) => !!r.error);
  if (hasError) {
    return {
      success: false,
      resolvedSettings,
      error: "Unable to resolve files."
    };
  }
  const rawGlobalSettings = await getRawGlobalSettings();
  const resolvedImports = await resolveImports(rawGlobalSettings);
  const imports = new Set(resolvedImports.map((r) => r.resolvedToFilename || r.filename));
  resolvedSettings.map((s) => s.resolvedToFilename).filter(isString2).reduce((imports2, s) => imports2.add(s), imports);
  const globalSettings = {
    import: [...imports]
  };
  let error;
  try {
    await writeRawGlobalSettings(globalSettings);
  } catch (e) {
    error = toError(e);
  }
  return {
    success: !error,
    error: error == null ? void 0 : error.message,
    resolvedSettings
  };
}
async function removePathsFromGlobalImports(paths) {
  const listResult = await listGlobalImports();
  const toRemove = /* @__PURE__ */ new Set();
  function matchPackage(pathToRemove) {
    return ({ package: pkg, id }) => pathToRemove === (pkg == null ? void 0 : pkg.name) || pathToRemove === id;
  }
  function compareFilenames(fullPath, partialPath) {
    if (fullPath === partialPath)
      return true;
    if (!fullPath.endsWith(partialPath))
      return false;
    const c = fullPath[fullPath.length - partialPath.length - 1];
    return c === Path4.sep || c === Path4.posix.sep;
  }
  function matchFilename(pathToRemove) {
    return Path4.dirname(pathToRemove) != "." ? ({ filename }) => compareFilenames(filename, pathToRemove) : () => false;
  }
  paths.map((a) => a.trim()).filter((a) => !!a).forEach((pathToRemove) => {
    const excludePackage = matchPackage(pathToRemove);
    const excludeFilename = matchFilename(pathToRemove);
    const shouldExclude = (r) => excludePackage(r) || excludeFilename(r);
    for (const r of listResult.list) {
      if (shouldExclude(r)) {
        toRemove.add(r.filename);
      }
    }
  });
  const toImport = normalizeImports(listResult.globalSettings.import).filter((p) => !toRemove.has(p));
  const updatedSettings = {
    import: toImport
  };
  const error = toRemove.size > 0 ? writeRawGlobalSettings(updatedSettings) : void 0;
  return {
    success: true,
    removed: [...toRemove],
    error: error == null ? void 0 : error.toString()
  };
}
async function resolveSettings(filename) {
  var _a3;
  const settings = await readRawSettings(filename);
  const ref = settings.__importRef;
  const resolvedToFilename = ref == null ? void 0 : ref.filename;
  const error = ((_a3 = ref == null ? void 0 : ref.error) == null ? void 0 : _a3.message) || !resolvedToFilename && "File not Found" || void 0;
  return clean4({
    filename,
    resolvedToFilename,
    error,
    settings
  });
}
function normalizeImports(imports) {
  return typeof imports === "string" ? [imports] : imports || [];
}
function resolveImports(s) {
  const imported = normalizeImports(s.import);
  return Promise.all(imported.map(resolveSettings));
}
function findPackageForCSpellConfig(pathToConfig) {
  try {
    const filename = Path4.join(pathToConfig, "package.json");
    const pkg = JSON.parse(fs7.readFileSync(filename, "utf8"));
    return {
      filename,
      name: pkg["name"]
    };
  } catch {
    return void 0;
  }
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/search.js
function binarySearch(arr, item, leftOffset, rightOffset) {
  let left = Math.max(leftOffset ?? 0, 0);
  let right = Math.min(rightOffset ?? arr.length, arr.length);
  while (left < right) {
    const pos = left + right >> 1;
    if (arr[pos] < item) {
      left = pos + 1;
    } else {
      right = pos;
    }
  }
  return left;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/text.js
function splitCamelCaseWordWithOffset(wo) {
  return splitCamelCaseWord(wo.text).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitCamelCaseWord(word) {
  return splitWord(word, regExpCamelCaseWordBreaksWithEnglishSuffix);
}
function splitWordWithOffset(wo, regExpWordBreaks) {
  return splitWord(wo.text, regExpWordBreaks).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitWord(word, regExpWordBreaks) {
  return word.split(regExpWordBreaks);
}
function match(reg, text) {
  if (!text)
    return [];
  reg = reg.global ? reg : new RegExp(reg.source, reg.flags + "g");
  return text.matchAll(reg);
}
function matchStringToTextOffset(reg, text) {
  return matchToTextOffset(reg, { text, offset: 0 });
}
function matchToTextOffset(reg, t) {
  const text = t.text;
  const offset = t.offset;
  return pipeSync(match(reg, text), opMapSync((m) => ({ text: m[0], offset: offset + m.index })));
}
function* extractLinesOfText(text) {
  let i = 0;
  for (let j = text.indexOf("\n", i); j >= 0; j = text.indexOf("\n", i)) {
    const end = j + 1;
    yield { text: text.slice(i, end), offset: i };
    i = end;
  }
  yield { text: text.slice(i, text.length), offset: i };
}
function extractWordsFromText(text) {
  return extractWordsFromTextOffset(textOffset(text));
}
function extractWordsFromTextOffset(text) {
  const reg = new RegExp(regExWords);
  return matchToTextOffset(reg, cleanTextOffset(text));
}
function cleanText(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text))
    return text;
  text = text.replace(regExIgnoreCharacters, (match2) => " ".repeat(match2.length));
  return text;
}
function cleanTextOffset(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text.text))
    return text;
  return {
    text: cleanText(text.text),
    offset: text.offset
  };
}
function extractPossibleWordsFromTextOffset(text) {
  const reg = new RegExp(regExWordsAndDigits);
  return matchToTextOffset(reg, text);
}
function extractWordsFromCode(text) {
  return extractWordsFromCodeTextOffset(textOffset(text));
}
function extractWordsFromCodeTextOffset(textOffset2) {
  return pipeSync(extractWordsFromTextOffset(textOffset2), opConcatMapSync(splitCamelCaseWordWithOffset));
}
function isUpperCase2(word) {
  return regExAllUpper2.test(word);
}
function isLowerCase(word) {
  return regExAllLower2.test(word);
}
function isFirstCharacterUpper(word) {
  return isUpperCase2(word.slice(0, 1));
}
function isFirstCharacterLower(word) {
  return isLowerCase(word.slice(0, 1));
}
function ucFirst2(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function lcFirst(word) {
  return word.slice(0, 1).toLowerCase() + word.slice(1);
}
function snakeToCamel(word) {
  return word.split("_").map(ucFirst2).join("");
}
function camelToSnake(word) {
  return splitCamelCaseWord(word).join("_").toLowerCase();
}
function matchCase(example, word) {
  if (regExFirstUpper2.test(example)) {
    return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
  }
  if (regExAllLower2.test(example)) {
    return word.toLowerCase();
  }
  if (regExAllUpper2.test(example)) {
    return word.toUpperCase();
  }
  if (isFirstCharacterUpper(example)) {
    return ucFirst2(word);
  }
  if (isFirstCharacterLower(example)) {
    return lcFirst(word);
  }
  return word;
}
function textOffset(text, offset = 0) {
  return { text, offset };
}
function extractText(textOffset2, startPos, endPos) {
  const { text, offset: orig } = textOffset2;
  const a = Math.max(startPos - orig, 0);
  const b = Math.max(endPos - orig, 0);
  return text.slice(a, b);
}
function calculateTextDocumentOffsets(uri, doc, wordOffsets) {
  const lines = [
    -1,
    ...pipeSync(match(/\n/g, doc), opMapSync((a) => a.index)),
    doc.length
  ];
  let lastRow = -1;
  let lastOffset = doc.length + 1;
  let lastLineRow = -1;
  let lastLine;
  function findRowCol(offset) {
    const row = binarySearch(lines, offset, offset >= lastOffset ? lastRow : void 0);
    const col = offset - lines[Math.max(0, row - 1)];
    lastOffset = offset;
    lastRow = row;
    return [row, col];
  }
  function extractLine(row) {
    const offset = lines[row - 1] + 1;
    const text = doc.slice(offset, lines[row] + 1);
    return { text, offset };
  }
  function calcLine(row) {
    const last = lastLineRow === row ? lastLine : void 0;
    lastLineRow = row;
    const r = last ?? extractLine(row);
    lastLine = r;
    return r;
  }
  const _uri = toUri(uri).toString();
  return wordOffsets.map((wo) => {
    const [row, col] = findRowCol(wo.offset);
    return { ...wo, row, col, doc, uri: _uri, line: calcLine(row) };
  });
}
function removeAccents2(text) {
  return text.normalize("NFD").replace(regExAccents2, "");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/InDocSettings.js
var regExMatchRegEx = /\/.*\/[gimuy]*/;
var regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
var regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
var regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
var officialDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next",
  "disable-next-line",
  "word",
  "words",
  "ignore",
  "ignoreWord",
  "ignoreWords",
  "ignore-word",
  "ignore-words",
  "includeRegExp",
  "ignoreRegExp",
  "local",
  // Do not suggest.
  "locale",
  "language",
  "dictionaries",
  "dictionary",
  "forbid",
  "forbidWord",
  "forbid-word",
  "flag",
  "flagWord",
  "flag-word",
  "enableCompoundWords",
  "enableAllowCompoundWords",
  "disableCompoundWords",
  "disableAllowCompoundWords",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var noSuggestDirectives = /* @__PURE__ */ new Set(["local"]);
var preferredDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next-line",
  "words",
  "ignore",
  "forbid",
  "locale",
  "dictionary",
  "dictionaries",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var allDirectives = /* @__PURE__ */ new Set([...preferredDirectives, ...officialDirectives]);
var allDirectiveSuggestions = [
  ...pipeSync(allDirectives, opMapSync((word) => ({ word })))
];
var dictInDocSettings = createSpellingDictionary(allDirectives, "Directives", "Directive List", {
  supportNonStrictSearches: false
});
var EmptyWords = [];
Object.freeze(EmptyWords);
var staticInDocumentDictionaryName = `[in-document-dict]`;
function getInDocumentSettings(text) {
  const collectedSettings = getPossibleInDocSettings(text).concatMap((a) => parseSettingMatch(a)).reduce((s, setting) => {
    return mergeInDocSettings(s, setting);
  }, { id: "in-doc-settings" });
  const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
  const dict = (words || flagWords || ignoreWords || suggestWords) && clean4({
    name: staticInDocumentDictionaryName,
    words,
    flagWords,
    ignoreWords,
    suggestWords
  });
  const dictSettings = dict ? {
    dictionaries: [...dictionaries, staticInDocumentDictionaryName],
    dictionaryDefinitions: [...dictionaryDefinitions, dict]
  } : clean4({
    dictionaries: dictionaries.length ? dictionaries : void 0,
    dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : void 0
  });
  const settings = {
    ...rest,
    ...dictSettings
  };
  return settings;
}
function validateInDocumentSettings(docText, _settings) {
  return pipeSync(getPossibleInDocSettings(docText), opMapSync(parseSettingMatchValidation), opFilterSync(isDefined4));
}
var settingParsers = [
  [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords],
  [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive],
  [/^enable\b(?!-)/i, parseEnable],
  [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable],
  [/^words?\b(?!-)/i, parseWords],
  [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords],
  [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords],
  [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp],
  [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp],
  [/^locale?\b(?!-)/i, parseLocale2],
  [/^language\s\b(?!-)/i, parseLocale2],
  [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries],
  // cspell:disable-line
  [/^LocalWords:/, (w) => parseWords(w.replaceAll(/^LocalWords:?/gi, " "))]
];
var emptySettings = Object.freeze({});
var issueMessages = {
  unknownDirective: "Unknown CSpell directive"
};
function parseSettingMatchValidation(matchArray) {
  const [fullMatch = ""] = matchArray;
  const directiveMatch = fullMatch.match(regExCSpellDirectiveKey);
  if (!directiveMatch)
    return void 0;
  const match2 = directiveMatch[1];
  const possibleSetting = match2.trim();
  if (!possibleSetting)
    return void 0;
  const start = (matchArray.index || 0) + (directiveMatch.index || 0) + (match2.length - match2.trimStart().length);
  const text = possibleSetting.replace(/^([-\w]+)?.*/, "$1");
  const end = start + text.length;
  if (!text)
    return void 0;
  const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
  if (matchingParsers.length > 0)
    return void 0;
  const dictSugs = dictInDocSettings.suggest(text, { ignoreCase: false }).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word }).filter((a) => !noSuggestDirectives.has(a.word));
  const sugs = pipeSync(dictSugs, opAppendSync(allDirectiveSuggestions), filterUniqueSuggestions);
  const suggestionsEx = [...sugs].slice(0, 8);
  const suggestions = suggestionsEx.map((s) => s.word);
  const issue = {
    range: [start, end],
    text,
    message: issueMessages.unknownDirective,
    suggestions,
    suggestionsEx
  };
  return issue;
}
function* filterUniqueSuggestions(sugs) {
  const map3 = /* @__PURE__ */ new Map();
  for (const sug of sugs) {
    const existing = map3.get(sug.word);
    if (existing && sug.isPreferred) {
      existing.isPreferred = true;
    }
    yield sug;
  }
}
function parseSettingMatch(matchArray) {
  const [, match2 = ""] = matchArray;
  const possibleSetting = match2.trim();
  return settingParsers.filter(([regex]) => regex.test(possibleSetting)).map(([, fn]) => fn).map((fn) => fn(possibleSetting));
}
function parseCompoundWords(match2) {
  const allowCompoundWords = /enable/i.test(match2);
  return { allowCompoundWords };
}
function parseCaseSensitive(match2) {
  const caseSensitive = /enable/i.test(match2);
  return { caseSensitive };
}
function parseWords(match2) {
  const words = match2.split(/[,\s;]+/g).slice(1).filter((a) => !!a);
  return { words };
}
function parseLocale2(match2) {
  const parts = match2.trim().split(/[\s,]+/);
  const language = parts.slice(1).join(",");
  return language ? { language } : emptySettings;
}
function parseIgnoreWords(match2) {
  const wordsSetting = parseWords(match2);
  const ignoreWords = wordsSetting.words;
  return ignoreWords && ignoreWords.length ? { ignoreWords } : emptySettings;
}
function parseFlagWords(match2) {
  const wordsSetting = parseWords(match2);
  const flagWords = wordsSetting.words;
  return flagWords && flagWords.length ? { flagWords } : emptySettings;
}
function parseRegEx(match2) {
  const patterns = [match2.replace(/^[^\s]+\s+/, "")].map((a) => {
    const m = a.match(regExMatchRegEx);
    if (m && m[0]) {
      return m[0];
    }
    return a.replace(/((?:[^\s]|\\ )+).*/, "$1");
  });
  return patterns;
}
function parseIgnoreRegExp(match2) {
  const ignoreRegExpList = parseRegEx(match2);
  return { ignoreRegExpList };
}
function parseIncludeRegExp(match2) {
  const includeRegExpList = parseRegEx(match2);
  return { includeRegExpList };
}
function parseDictionaries(match2) {
  const dictionaries = match2.split(/[,\s]+/g).slice(1);
  return { dictionaries };
}
function getPossibleInDocSettings(text) {
  return genSequence(regExInFileSettings).concatMap((regexp) => match(regexp, text));
}
function parseEnable(_match) {
  return {};
}
function parseDisable(_match) {
  return {};
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/Settings/TextDocumentSettings.js
function combineTextAndLanguageSettings(settings, text, languageId) {
  if (!text) {
    return toInternalSettings(calcSettingsForLanguageId(settings, languageId));
  }
  const docSettings = extractSettingsFromText(text);
  const settingsForText = mergeSettings(settings, docSettings);
  const langSettings = calcSettingsForLanguageId(settingsForText, languageId);
  return mergeSettings(langSettings, docSettings);
}
function extractSettingsFromText(text) {
  return getInDocumentSettings(text);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/determineTextDocumentSettings.js
var path12 = __toESM(require("path"), 1);
async function determineTextDocumentSettings(doc, settings) {
  var _a3;
  const filename = uriToFilePath(doc.uri);
  const settingsWithDefaults = mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), getGlobalSettings(), settings);
  const fileSettings = calcOverrideSettings(settingsWithDefaults, filename);
  const languageIds2 = ((_a3 = fileSettings == null ? void 0 : fileSettings.languageId) == null ? void 0 : _a3.length) ? fileSettings.languageId : doc.languageId ? doc.languageId : getLanguageForFilename(filename);
  if (doc.locale) {
    fileSettings.language = doc.locale;
  }
  return combineTextAndLanguageSettings(fileSettings, doc.text, languageIds2);
}
function getLanguageForFilename(filename) {
  const basename5 = path12.basename(filename);
  return findMatchingFileTypes(basename5);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/checkText.js
var import_node_assert18 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var import_node_assert17 = __toESM(require("assert"), 1);
var import_node_url20 = require("url");

// node_modules/.pnpm/@cspell+cspell-types@8.14.2/node_modules/@cspell/cspell-types/dist/index.mjs
var dist_exports = {};
__reExport(dist_exports, __toESM(require_dist2(), 1));

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/suggestions.js
var import_node_assert14 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/memorizeLastCall.js
function memorizeLastCall2(fn) {
  let last;
  return (...p) => {
    if (last && isArrayEqual(last.args, p)) {
      return last.value;
    }
    const args = p;
    const value = fn(...args);
    last = { args, value };
    return value;
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/suggestions.js
var emptySuggestionOptions = Object.freeze({});
var emptyCSpellSettings = Object.freeze({});
async function* suggestionsForWords(words, options, settings) {
  for await (const word of words) {
    yield await suggestionsForWord(word, options, settings);
  }
}
var memorizeSuggestions = memorizeLastCall2(cacheSuggestionsForWord);
function cacheSuggestionsForWord(options, settings) {
  const cache4 = createAutoResolveCache();
  return (word) => cache4.get(word, (word2) => _suggestionsForWord(word2, options, settings));
}
function suggestionsForWord(word, options = emptySuggestionOptions, settings = emptyCSpellSettings) {
  return memorizeSuggestions(options, settings)(word);
}
async function _suggestionsForWord(word, options, settings) {
  const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
  async function determineDictionaries(config2) {
    var _a3;
    const withLocale = mergeSettings(config2, clean4({
      language: language || config2.language
      // dictionaries: dictionaries?.length ? dictionaries : config.dictionaries,
    }));
    const withLanguageId = calcSettingsForLanguageId(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
    const settings2 = finalizeSettings(withLanguageId);
    settings2.dictionaries = (dictionaries == null ? void 0 : dictionaries.length) ? dictionaries : settings2.dictionaries || [];
    validateDictionaries(settings2, dictionaries);
    const dictionaryCollection2 = await getDictionaryInternal(settings2);
    settings2.dictionaries = ((_a3 = settings2.dictionaryDefinitions) == null ? void 0 : _a3.map((def) => def.name)) || [];
    const allDictionaryCollection2 = await getDictionaryInternal(settings2);
    return {
      dictionaryCollection: dictionaryCollection2,
      allDictionaryCollection: allDictionaryCollection2
    };
  }
  await refreshDictionaryCache();
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
  return _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection);
}
async function _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
  const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
  const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true } = options;
  const ignoreCase2 = !strict;
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const opts = { ignoreCase: ignoreCase2, numChanges, numSuggestions, includeTies };
  const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
  const locale = adjustLocale(language || config.language || void 0);
  const collator2 = Intl.Collator(locale);
  const combined = limitResults(combine3(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator2.compare(a.word, b.word))), numSuggestions, includeTies);
  const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase2, extendsDictionaryCollection);
  const allSugs = sugsAdjusted.map((sug) => {
    const found = extendsDictionaryCollection.find(sug.word);
    return {
      ...sug,
      forbidden: (found == null ? void 0 : found.forbidden) || false,
      noSuggest: (found == null ? void 0 : found.noSuggest) || false
    };
  });
  return {
    word,
    suggestions: limitResults(allSugs, numSuggestions, includeTies)
  };
}
function combine3(suggestions) {
  const words = /* @__PURE__ */ new Map();
  for (const sug of suggestions) {
    const { word, cost, dictName, ...rest } = sug;
    const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
    f.cost = Math.min(f.cost, cost);
    f.dictionaries.push(dictName);
    f.dictionaries.sort();
    words.set(word, f);
  }
  return [...words.values()];
}
function adjustLocale(locale) {
  if (!locale)
    return void 0;
  const locales = [...normalizeLocaleIntl(locale)].filter((locale2) => isValidLocaleIntlFormat(locale2));
  if (!locales.length)
    return void 0;
  if (locales.length === 1)
    return locales[0];
  return locales;
}
function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase2, dict) {
  locale = adjustLocale(locale);
  const knownSugs = new Set(sugs.map((sug) => sug.word));
  const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase: ignoreCase2 };
  return sugs.map((sug) => {
    const alt = matchCase2(sug.word, !!sug.isPreferred, matchStyle);
    if (alt === sug.word || knownSugs.has(alt))
      return sug;
    const found = dict.find(alt);
    if (!found || !found.forbidden || !found.noSuggest) {
      knownSugs.add(alt);
      return { ...sug, wordAdjustedToMatchCase: alt };
    }
    return sug;
  });
}
function limitResults(suggestions, numSuggestions, includeTies) {
  var _a3;
  let cost = (_a3 = suggestions[0]) == null ? void 0 : _a3.cost;
  let i = 0;
  for (; i < suggestions.length; ++i) {
    if (i >= numSuggestions && (!includeTies || suggestions[i].cost > cost)) {
      break;
    }
    cost = suggestions[i].cost;
  }
  return suggestions.slice(0, i);
}
function validateDictionaries(settings, dictionaries) {
  var _a3;
  if (!(dictionaries == null ? void 0 : dictionaries.length))
    return;
  const knownDicts2 = new Set(((_a3 = settings.dictionaryDefinitions) == null ? void 0 : _a3.map((def) => def.name)) || []);
  for (const dict of dictionaries) {
    if (!knownDicts2.has(dict)) {
      throw new SuggestionError(`Unknown dictionary: "${dict}"`, "E_dictionary_unknown");
    }
  }
}
function matchCase2(word, isPreferred, style) {
  const locale = style.locale;
  if (style.isMixedCaps) {
    return word;
  }
  if (hasCaps(word)) {
    if (style.isAllCaps)
      return word.toLocaleUpperCase(locale);
    if (!style.ignoreCase || style.hasCaps || isPreferred)
      return word;
    if (isTitleCase(word) || isAllCaps(word))
      return word.toLocaleLowerCase(locale);
    return word;
  }
  if (!style.hasCaps)
    return word;
  if (style.isAllCaps)
    return word.toLocaleUpperCase(locale);
  (0, import_node_assert14.default)(style.isTitleCase);
  return word.replace(new RegExp("^\\p{L}", "u"), (firstLetter) => firstLetter.toLocaleUpperCase(locale));
}
var regExpHasCaps = new RegExp("\\p{Lu}", "u");
var regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
var regExpIsTitleCase = new RegExp("^\\p{Lu}[\\P{L}\\p{Ll}]+$", "u");
function analyzeCase(word) {
  const hasCaps2 = regExpHasCaps.test(word);
  const isAllCaps2 = hasCaps2 && regExpIsAllCaps.test(word);
  const isTitleCase2 = hasCaps2 && !isAllCaps2 && regExpIsTitleCase.test(word);
  const isMixedCaps = hasCaps2 && !isAllCaps2 && !isTitleCase2;
  return { hasCaps: hasCaps2, isAllCaps: isAllCaps2, isMixedCaps, isTitleCase: isTitleCase2 };
}
function hasCaps(word) {
  return regExpHasCaps.test(word);
}
function isTitleCase(word) {
  return regExpIsTitleCase.test(word);
}
function isAllCaps(word) {
  return regExpIsAllCaps.test(word);
}
var SuggestionError = class extends Error {
  code;
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/defaultConstants.js
var defaultMaxNumberOfProblems = 200;
var defaultMaxDuplicateProblems = 5;
var defaultMinWordLength = 4;

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
var import_node_assert16 = __toESM(require("assert"), 1);

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/PairingHeap.js
var PairingHeap2 = class {
  compare;
  _heap;
  _size = 0;
  constructor(compare3) {
    this.compare = compare3;
  }
  add(v) {
    this._heap = insert3(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  dequeue() {
    const n = this.next();
    if (n.done)
      return void 0;
    return n.value;
  }
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  next() {
    if (!this._heap) {
      return { value: void 0, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead2(this.compare, this._heap);
    return { value };
  }
  peek() {
    var _a3;
    return (_a3 = this._heap) == null ? void 0 : _a3.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  get length() {
    return this._size;
  }
};
function removeHead2(compare3, heap) {
  if (!heap || !heap.c)
    return void 0;
  return mergeSiblings2(compare3, heap.c);
}
function insert3(compare3, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare3(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge3(compare3, a, b) {
  if (compare3(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings2(compare3, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge3(compare3, n, s);
  return ss ? merge3(compare3, m, mergeSiblings2(compare3, ss)) : m;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/regexHelper.js
function escapeRegEx3(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/wordSplitter.js
var ignoreBreak = Object.freeze([]);
function split(line, offset, isValidWord, options = {}) {
  const relWordToSplit = findNextWordText({ text: line.text, offset: offset - line.offset });
  const lineOffset = line.offset;
  const requested = /* @__PURE__ */ new Map();
  const regExpIgnoreSegment = /^[-.+\d_eE'`\\\s]+$/;
  if (!relWordToSplit.text) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [],
      endOffset: text.offset + text.text.length
    };
  }
  const lineSegment = {
    line,
    relStart: relWordToSplit.offset,
    relEnd: relWordToSplit.offset + relWordToSplit.text.length
  };
  const possibleBreaks = generateWordBreaks(lineSegment, options);
  if (!possibleBreaks.length) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [{ ...text, isFound: isValidWord(text) }],
      endOffset: text.offset + text.text.length
    };
  }
  function rebaseTextOffset(relText) {
    return {
      ...relText,
      offset: relText.offset + lineOffset
    };
  }
  function has(word) {
    if (regExpIgnoreSegment.test(word.text)) {
      return true;
    }
    const i = word.offset;
    const j = word.text.length;
    let v = i + (j << 20);
    if (i < 1 << 20 && j < 1 << 11) {
      const b = requested.get(v);
      if (b !== void 0)
        return b;
    } else {
      v = -1;
    }
    const r = isValidWord(rebaseTextOffset(word));
    if (v >= 0) {
      requested.set(v, r);
    }
    return r;
  }
  possibleBreaks.push({
    offset: lineSegment.relEnd,
    breaks: [ignoreBreak]
  });
  const result = {
    line,
    offset,
    text: rebaseTextOffset(relWordToSplit),
    words: splitIntoWords(lineSegment, possibleBreaks, has).map(rebaseTextOffset),
    endOffset: lineOffset + lineSegment.relEnd
  };
  return result;
}
function findNextWordText({ text, offset }) {
  const reg = new RegExp(regExWordsAndDigits);
  reg.lastIndex = offset;
  const m = reg.exec(text);
  if (!m) {
    return {
      text: "",
      offset: offset + text.length
    };
  }
  if (regExNumericLiteral.test(m[0])) {
    return findNextWordText({ text, offset: offset + m[0].length });
  }
  return {
    text: m[0],
    offset: m.index
  };
}
function generateWordBreaks(line, options) {
  const camelBreaks = genWordBreakCamel(line);
  const symbolBreaks = genSymbolBreaks(line);
  const optionalBreaks = genOptionalWordBreaks(line, options.optionalWordBreakCharacters);
  return mergeSortedBreaks(...camelBreaks, ...symbolBreaks, ...optionalBreaks);
}
function offsetRegEx(reg, offset) {
  const r = new RegExp(reg);
  r.lastIndex = offset;
  return r;
}
function genWordBreakCamel(line) {
  const breaksCamel1 = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(regExSplitWords, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    breaksCamel1.push({
      offset: m.index,
      breaks: [[i, i], ignoreBreak]
    });
  }
  const breaksCamel2 = [];
  for (const m of text.matchAll(offsetRegEx(regExSplitWords2, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    const j = i + m[3].length;
    breaksCamel2.push({
      offset: m.index,
      breaks: [[i, i], [j, j], ignoreBreak]
    });
  }
  return [breaksCamel1, breaksCamel2];
}
function calcBreaksForRegEx(line, reg, calcBreak) {
  const sb = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(reg, line.relStart))) {
    const b = calcBreak(m);
    if (b) {
      sb.push(b);
    }
  }
  return sb;
}
function genOptionalWordBreaks(line, optionalBreakCharacters) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        ignoreBreak
      ]
    };
  }
  const breaks = [
    calcBreaksForRegEx(line, regExDanglingQuote, calcBreaks),
    calcBreaksForRegEx(line, regExTrailingEndings, calcBreaks)
  ];
  if (optionalBreakCharacters) {
    const regex = new RegExp(`[${escapeRegEx3(optionalBreakCharacters)}]`, "gu");
    breaks.push(calcBreaksForRegEx(line, regex, calcBreaks));
  }
  return breaks;
}
function genSymbolBreaks(line) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        [i, i],
        // keep characters with word to right
        [j, j],
        // keep characters with word to left
        ignoreBreak
      ]
    };
  }
  return [
    calcBreaksForRegEx(line, regExPossibleWordBreaks, calcBreaks),
    calcBreaksForRegEx(line, /\d+/g, calcBreaks),
    calcBreaksForRegEx(line, regExEscapeCharacters, calcBreaks)
  ];
}
function splitIntoWords(lineSeg, breaks, has) {
  var _a3;
  const maxIndex = lineSeg.relEnd;
  const maxAttempts = 1e3;
  const knownPathsByIndex = /* @__PURE__ */ new Map();
  function makeCandidates(p, i, bi, currentCost) {
    const len = maxIndex;
    while (bi < breaks.length && breaks[bi].offset < i) {
      bi += 1;
    }
    if (bi >= breaks.length) {
      return [];
    }
    const br = breaks[bi];
    function c(bp) {
      const d = bp.length < 2 ? len - i : (bp[0] - i) * 0.5 + len - bp[1];
      const ec = currentCost + d;
      return {
        p,
        i,
        bi,
        bp,
        c: currentCost,
        ec,
        text: void 0
      };
    }
    return br.breaks.map(c);
  }
  function checkTextOffset(text2, offset) {
    const valid = has({ text: text2, offset });
    return {
      text: text2,
      offset,
      isFound: valid
    };
  }
  function compare3(a, b) {
    return a.ec - b.ec || b.i - a.i;
  }
  function pathToWords(node) {
    const results = [];
    for (let p = node; p; p = p.n) {
      if (p.text) {
        results.push(p.text);
      }
    }
    return results;
  }
  function addToKnownPaths(candidate, path13) {
    for (let can = candidate; can !== void 0; can = can.p) {
      const t = can.text;
      const i = can.i;
      const cost = (!t || t.isFound ? 0 : t.text.length) + ((path13 == null ? void 0 : path13.c) ?? 0);
      const exitingPath = knownPathsByIndex.get(i);
      if (exitingPath && exitingPath.c <= cost) {
        return void 0;
      }
      const node = {
        n: path13,
        i,
        c: cost,
        text: t
      };
      knownPathsByIndex.set(i, node);
      path13 = node;
    }
    return path13;
  }
  let maxCost = lineSeg.relEnd - lineSeg.relStart;
  const candidates = new PairingHeap2(compare3);
  const text = lineSeg.line.text;
  candidates.append(makeCandidates(void 0, lineSeg.relStart, 0, 0));
  let attempts = 0;
  let bestPath;
  while (maxCost && candidates.length && attempts++ < maxAttempts) {
    const best = candidates.dequeue();
    if (!best || best.c >= maxCost) {
      continue;
    }
    if (best.bp.length) {
      const i = best.bp[0];
      const j = best.bp[1];
      const t = i > best.i ? checkTextOffset(text.slice(best.i, i), best.i) : void 0;
      const cost = !t || t.isFound ? 0 : t.text.length;
      const mc = maxIndex - j;
      best.c += cost;
      best.ec = best.c + mc;
      best.text = t;
      const possiblePath = knownPathsByIndex.get(j);
      if (possiblePath) {
        const f = addToKnownPaths(best, possiblePath);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      } else if (best.c < maxCost) {
        const c = makeCandidates(t ? best : best.p, j, best.bi + 1, best.c);
        candidates.append(c);
      }
    } else {
      const c = makeCandidates(best.p, best.i, best.bi + 1, best.c);
      candidates.append(c);
      if (!c.length) {
        const t = maxIndex > best.i ? checkTextOffset(text.slice(best.i, maxIndex), best.i) : void 0;
        const cost = !t || t.isFound ? 0 : t.text.length;
        best.c += cost;
        best.ec = best.c;
        best.text = t;
        const segText = t || ((_a3 = best.p) == null ? void 0 : _a3.text) || checkTextOffset("", best.i);
        const can = t ? { ...best, text: segText } : { ...best, ...best.p, text: segText };
        const f = addToKnownPaths(can, void 0);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      }
    }
    if (bestPath && bestPath.c < maxCost) {
      maxCost = bestPath.c;
    }
  }
  return pathToWords(bestPath);
}
function mergeSortedBreaks(...maps) {
  return maps.flat().sort((a, b) => a.offset - b.offset);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/isWordValid.js
function hasWordCheck(dict, word) {
  word = word.includes("\\") ? word.replaceAll("\\", "") : word;
  return dict.has(word);
}
function isWordValidWithEscapeRetry(dict, wo, line) {
  const firstTry = hasWordCheck(dict, wo.text);
  return firstTry || // Drop the first letter if it is preceded by a '\'.
  line.text[wo.offset - line.offset - 1] === "\\" && hasWordCheck(dict, wo.text.slice(1));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/TextMap.js
var import_node_assert15 = __toESM(require("assert"), 1);
function extractTextMapRangeOrigin(textMap, extractRange) {
  const { text: srcTxt, range: srcRange, map: srcMap } = textMap;
  const [r0, r1] = srcRange;
  const startOrig = Math.min(Math.max(extractRange[0], r0), r1);
  const endOrig = Math.min(Math.max(extractRange[1], r0), r1);
  const a = startOrig - r0;
  const b = endOrig - r0;
  const range = [startOrig, endOrig];
  if (!srcMap || !srcMap.length || a === b) {
    const text2 = srcTxt.slice(a, b);
    return { text: text2, range };
  }
  (0, import_node_assert15.default)((srcMap.length & 1) === 0, "Map must be pairs of values.");
  const mapLen = srcMap.length;
  const mapEndSrc = srcMap[mapLen - 2];
  const mapEndDst = srcMap[mapLen - 1];
  const endDiff = srcTxt.length - mapEndDst;
  const head = !srcMap[0] && !srcMap[1] ? [] : [0, 0];
  const tail = [mapEndSrc + endDiff, mapEndDst + endDiff];
  const sMap = [...head, ...srcMap, ...tail];
  let idx2 = 0;
  for (; idx2 < sMap.length && a >= sMap[idx2]; idx2 += 2) {
  }
  const aIdx = idx2;
  idx2 -= 2;
  const a0 = a - sMap[idx2];
  const a1 = a0 + sMap[idx2 + 1];
  for (; idx2 < sMap.length && b > sMap[idx2]; idx2 += 2) {
  }
  const bIdx = idx2;
  const b0 = b - sMap[idx2];
  const b1 = b0 + sMap[idx2 + 1];
  const text = srcTxt.slice(a1, b1);
  if (bIdx === aIdx) {
    return { text, range };
  }
  const ab = [a0, a1];
  const map3 = sMap.slice(aIdx, bIdx + 2).map((v, i) => v - ab[i & 1]);
  return { text, range, map: map3 };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/parsedText.js
function mapRangeBackToOriginalPos(offRange, map3) {
  if (!map3 || !map3.length)
    return offRange;
  const [start, end] = offRange;
  let i = 0, j = 0, p = 1;
  while (p < map3.length && map3[p] < start) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iA = start - j + i;
  while (p < map3.length && map3[p] < end) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iB = end - j + i;
  return [iA, iB];
}
function createMappedTextSegmenter(includeRanges) {
  let rangePos = 0;
  function* segmenter(pText) {
    if (!includeRanges.length) {
      return;
    }
    const range = pText.range;
    const textEndPos = range[1];
    let textStartPos = range[0];
    while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
      rangePos -= 1;
    }
    const cur = includeRanges[rangePos];
    if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
      yield pText;
      return;
    }
    while (textStartPos < textEndPos) {
      while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
        rangePos += 1;
      }
      if (!includeRanges[rangePos]) {
        break;
      }
      const { startPos, endPos } = includeRanges[rangePos];
      if (textEndPos < startPos) {
        break;
      }
      const a = Math.max(textStartPos, startPos);
      const b = Math.min(textEndPos, endPos);
      if (a !== b) {
        yield extractTextMapRangeOrigin(pText, [a, b]);
      }
      textStartPos = b;
    }
  }
  return segmenter;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
function lineValidatorFactory(sDict, options) {
  const { minWordLength = defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase: ignoreCase2 = true } = options;
  const hasWordOptions = {
    ignoreCase: ignoreCase2,
    useCompounds: allowCompoundWords || void 0
    // let the dictionaries decide on useCompounds if allow is false
  };
  const dictCol = createCachingDictionary(sDict, hasWordOptions);
  const knownWords = /* @__PURE__ */ new Map();
  const setOfFlagWords = new Set(flagWords);
  const setOfKnownIssues = /* @__PURE__ */ new Map();
  const setOfKnownSuccessfulWords = /* @__PURE__ */ new Set();
  const rememberFilter = (fn2) => (v) => {
    const keep = fn2(v);
    if (!keep) {
      setOfKnownSuccessfulWords.add(v.text);
    }
    return keep;
  };
  const filterAlreadyChecked = (wo) => {
    return !setOfKnownSuccessfulWords.has(wo.text);
  };
  const hasDict = {
    has(word) {
      const info = getWordInfo(word);
      if (info.isFound !== void 0)
        return info.isFound;
      if (info.isFlagged)
        return true;
      if (info.isFlagged)
        return false;
      info.isFound = dictCol.has(word);
      return info.isFound;
    }
  };
  function calcIgnored(info) {
    info.isIgnored ?? (info.isIgnored = dictCol.isNoSuggestWord(info.word));
    return info.isIgnored;
  }
  function calcFlagged(info) {
    if (info.isFlagged !== void 0)
      return info.isFlagged;
    const word = info.word;
    info.isFlagged = (setOfFlagWords.has(word) || setOfFlagWords.has(word.toLowerCase()) || dictCol.isForbidden(word)) && !calcIgnored(info);
    return info.isFlagged;
  }
  function isWordIgnored(word) {
    return calcIgnored(getWordInfo(word));
  }
  function getSuggestions(word) {
    return dictCol.getPreferredSuggestions(word);
  }
  function isWordFlagged(wo) {
    return calcFlagged(getWordInfo(wo.text));
  }
  function annotateIsFlagged(word) {
    word.isFlagged = isWordFlagged(word);
    return word;
  }
  function annotateIssue(issue) {
    const sugs = getSuggestions(issue.text);
    if (sugs && sugs.length) {
      issue.suggestionsEx = sugs;
    }
    return issue;
  }
  const isFlaggedOrMinLength = (wo) => wo.text.length >= minWordLength || !!wo.isFlagged;
  const isFlaggedOrNotFound = rememberFilter((wo) => wo.isFlagged || !wo.isFound);
  const isNotRepeatingChar = rememberFilter((wo) => !regExRepeatedChar.test(wo.text));
  function checkWord(issue) {
    const info = getWordInfo(issue.text);
    if (info.fin) {
      const { isFlagged: isForbidden, isFound, isIgnored: isIgnored2 } = info;
      const isFlagged2 = issue.isFlagged ?? (!isIgnored2 && isForbidden);
      issue.isFlagged = isFlagged2;
      issue.isFound = isFlagged2 ? void 0 : isFound;
      return issue;
    }
    const isIgnored = calcIgnored(info);
    const isFlagged = issue.isFlagged ?? calcFlagged(info);
    info.isFound ?? (info.isFound = isFlagged ? false : isIgnored || isWordValidWithEscapeRetry(hasDict, issue, issue.line));
    info.isFlagged = !!isFlagged;
    info.fin = true;
    issue.isFlagged = isFlagged;
    issue.isFound = isFlagged ? void 0 : info.isFound;
    return issue;
  }
  const regExUpperCaseWithTrailingCommonEnglishSuffix = /^([\p{Lu}\p{M}]{2,})[']?(?:s|ing|ies|es|ings|ize|ed|ning)$/u;
  const regExpIsLetter = new RegExp("\\p{L}", "u");
  const fn = (lineSegment) => {
    const line = lineSegment.line;
    function isWordTooShort(word, ignoreSuffix = false) {
      if (word.text.length >= minWordLength)
        return false;
      const offset = word.offset - line.offset;
      import_node_assert16.default.equal(line.text.slice(offset, offset + word.text.length), word.text);
      const prefix = [...line.text.slice(Math.max(0, offset - 2), offset)];
      const hasLetterPrefix = !!prefix.length && regExpIsLetter.test(prefix[prefix.length - 1]);
      if (hasLetterPrefix)
        return false;
      if (ignoreSuffix)
        return true;
      const suffix = [...line.text.slice(offset + word.text.length, offset + word.text.length + 2)];
      const hasLetterSuffix = !!suffix.length && regExpIsLetter.test(suffix[0]);
      return !hasLetterSuffix;
    }
    function splitterIsValid(word) {
      if (setOfKnownSuccessfulWords.has(word.text))
        return true;
      if (isWordFlagged(word))
        return false;
      if (isWordValidWithEscapeRetry(hasDict, word, lineSegment.line))
        return true;
      if (isWordTooShort(word))
        return true;
      return isAllCapsWithTrailingCommonEnglishSuffixOk(word);
    }
    function isAllCapsWithTrailingCommonEnglishSuffixOk(tWord) {
      if (!regExUpperCaseWithTrailingCommonEnglishSuffix.test(tWord.text))
        return false;
      const m = tWord.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
      if (!m)
        return false;
      const offset = tWord.offset;
      const v = { offset, text: m[1], line };
      const check = checkWord(v);
      if (check.isFlagged)
        return false;
      if (check.isFound)
        return true;
      if (isWordTooShort(v, true))
        return true;
      return false;
    }
    function checkFullWord(vr) {
      if (vr.isFlagged) {
        return [vr];
      }
      if (isAllCapsWithTrailingCommonEnglishSuffixOk(vr))
        return [];
      if (isWordIgnored(vr.text) || checkWord(vr).isFound) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      if (vr.isFlagged)
        return [vr];
      const codeWordResults = checkCamelCaseWord(vr);
      if (!codeWordResults.length) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      return codeWordResults;
    }
    function checkCamelCaseWord(vr) {
      return _checkCamelCaseWord(vr, regExpCamelCaseWordBreaksWithEnglishSuffix);
    }
    function _checkCamelCaseWord(vr, regExpWordBreaks) {
      const codeWordResults = [];
      for (const wo of splitWordWithOffset(vr, regExpWordBreaks)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = vr.line;
        issue.isFlagged = void 0;
        issue.isFound = void 0;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        checkWord(issue);
        if (!isFlaggedOrNotFound(issue) || !isNotRepeatingChar(issue))
          continue;
        issue.text = extractText(lineSegment.segment, issue.offset, issue.offset + issue.text.length);
        codeWordResults.push(issue);
      }
      return codeWordResults;
    }
    function rebaseKnownIssues(possibleWord, known) {
      const { issues } = known;
      const adjOffset = possibleWord.offset - known.possibleWord.offset;
      return issues.map((issue) => {
        issue = { ...issue };
        issue.offset += adjOffset;
        issue.line = lineSegment.line;
        return issue;
      });
    }
    function checkPossibleWords(possibleWord) {
      const known = setOfKnownIssues.get(possibleWord.text);
      if (known) {
        if (!known.issues.length)
          return known.issues;
        const adjusted = rebaseKnownIssues(possibleWord, known);
        return adjusted;
      }
      const issues = _checkPossibleWords(possibleWord).map(annotateIssue);
      setOfKnownIssues.set(possibleWord.text, { possibleWord, issues });
      return issues;
    }
    function _checkPossibleWords(possibleWord) {
      if (isWordFlagged(possibleWord)) {
        const vr = {
          ...possibleWord,
          line: lineSegment.line,
          isFlagged: true
        };
        return [vr];
      }
      const mismatches = [];
      for (const wo of extractWordsFromTextOffset(possibleWord)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = lineSegment.line;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        for (const w of checkFullWord(issue)) {
          mismatches.push(w);
        }
      }
      if (mismatches.length) {
        const splitResult = split(lineSegment.segment, possibleWord.offset, splitterIsValid);
        const nonMatching = splitResult.words.filter((w) => !w.isFound).filter((w) => {
          const m = w.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
          if (!m)
            return true;
          const v = checkWord({ ...w, text: m[1], line: lineSegment.line });
          return v.isFlagged || !v.isFound;
        });
        if (nonMatching.length < mismatches.length) {
          return nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged);
        }
      }
      return mismatches;
    }
    const checkedPossibleWords = pipeSync(extractPossibleWordsFromTextOffset(lineSegment.segment), opFilterSync(filterAlreadyChecked), opConcatMapSync(checkPossibleWords));
    return checkedPossibleWords;
  };
  function getWordInfo(word) {
    const info = knownWords.get(word);
    if (info)
      return info;
    const result = { word, isFound: void 0, isFlagged: void 0, isIgnored: void 0, fin: false };
    knownWords.set(word, result);
    return result;
  }
  return { fn, dict: dictCol };
}
function textValidatorFactory(dict, options) {
  const lineValidator = lineValidatorFactory(dict, options);
  const lineValidatorFn = lineValidator.fn;
  function validate(pText) {
    const { text, range: srcRange, map: map3 } = pText;
    const srcOffset = srcRange[0];
    const segment = { text, offset: 0 };
    const lineSegment = { line: segment, segment };
    function mapBackToOriginSimple(vr) {
      const { text: text2, offset, isFlagged, isFound, suggestionsEx } = vr;
      const r = mapRangeBackToOriginalPos([offset, offset + text2.length], map3);
      const range = [r[0] + srcOffset, r[1] + srcOffset];
      return { text: text2, range, isFlagged, isFound, suggestionsEx };
    }
    return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
  }
  return {
    validate,
    lineValidator
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/settingsToValidateOptions.js
function settingsToValidateOptions(settings) {
  const opt = {
    ...settings,
    ignoreCase: !(settings.caseSensitive ?? false)
  };
  return opt;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/TextRange.js
function toMatchRangeWithText(m) {
  const index = m.index || 0;
  const _text = m[0];
  return {
    startPos: index,
    endPos: index + _text.length,
    text: _text
  };
}
function findMatchingRanges(pattern, text) {
  if (pattern.source === ".*") {
    return [{ startPos: 0, endPos: text.length }];
  }
  const regex = new RegExp(pattern);
  if (!regex.global) {
    const m = text.match(regex);
    if (!m)
      return [];
    return [toMatchRangeWithText(m)];
  }
  return [...text.matchAll(regex)].map(toMatchRangeWithText);
}
function compareRanges(a, b) {
  return a.startPos - b.startPos || a.endPos - b.endPos;
}
function unionRanges(ranges) {
  const sortedRanges = sortMatchRangeArray(ranges);
  ranges = sortedRanges.values;
  if (!ranges.length)
    return sortedRanges;
  let i = 0;
  let j = 0;
  let { startPos, endPos } = ranges[i++];
  for (; i < ranges.length; ++i) {
    const r = ranges[i];
    if (r.startPos > endPos) {
      ranges[j++] = { startPos, endPos };
      startPos = r.startPos;
      endPos = r.endPos;
      continue;
    }
    endPos = Math.max(endPos, r.endPos);
  }
  if (startPos < endPos) {
    ranges[j++] = { startPos, endPos };
  }
  ranges.length = j;
  return sortedRanges;
}
function findMatchingRangesForPatterns(patterns, text) {
  const nested = patterns.map((pattern) => findMatchingRanges(pattern, text));
  return unionRanges(flatten(nested)).values;
}
function excludeRanges(includeRanges, excludeRanges2) {
  return _excludeRanges(sortMatchRangeArray(includeRanges), sortMatchRangeArray(excludeRanges2));
}
function _excludeRanges(sortedIncludeRanges, sortedExcludeRanges) {
  const includeRanges = sortedIncludeRanges.values;
  const excludeRanges2 = sortedExcludeRanges.values;
  if (!includeRanges.length)
    return includeRanges;
  if (!excludeRanges2.length) {
    return includeRanges;
  }
  const ranges = [];
  ranges.length = includeRanges.length + excludeRanges2.length + 1;
  let i = 0;
  let exIndex = 0;
  const limit = excludeRanges2.length;
  for (const incRange of includeRanges) {
    const endPos = incRange.endPos;
    let startPos = incRange.startPos;
    for (; exIndex < limit; ++exIndex) {
      const ex = excludeRanges2[exIndex];
      if (ex.startPos >= endPos)
        break;
      if (ex.endPos <= startPos)
        continue;
      if (ex.startPos > startPos) {
        ranges[i++] = { startPos, endPos: ex.startPos };
      }
      startPos = ex.endPos;
      if (startPos >= endPos)
        break;
    }
    if (startPos < endPos) {
      ranges[i++] = { startPos, endPos };
    }
  }
  ranges.length = i;
  return ranges;
}
function sortMatchRangeArray(values) {
  values.sort(compareRanges);
  return { values };
}
function flatten(data) {
  let size = 0;
  for (let i = data.length - 1; i >= 0; --i) {
    size += data[i].length;
  }
  const result = new Array(size);
  let k = 0;
  for (let i = 0; i < data.length; ++i) {
    const d = data[i];
    for (let j = 0; j < d.length; ++j) {
      result[k++] = d[j];
    }
  }
  return result;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/textValidator.js
function validateText(text, dict, options) {
  const { maxNumberOfProblems = defaultMaxNumberOfProblems, maxDuplicateProblems = defaultMaxDuplicateProblems } = options;
  const mapOfProblems = /* @__PURE__ */ new Map();
  const includeRanges = calcTextInclusionRanges(text, options);
  const lineValidator = lineValidatorFactory(dict, options);
  const validator = lineValidator.fn;
  const iter = pipeSync(extractLinesOfText(text), opConcatMapSync(mapLineToLineSegments(includeRanges)), opConcatMapSync(validator), opFilterSync((wo) => {
    const word = wo.text;
    const n = (mapOfProblems.get(word) || 0) + 1;
    mapOfProblems.set(word, n);
    return n <= maxDuplicateProblems;
  }), opTakeSync(maxNumberOfProblems));
  return iter;
}
function calcTextInclusionRanges(text, options) {
  const { ignoreRegExpList = [], includeRegExpList = [] } = options;
  const filteredIncludeList = includeRegExpList.filter((a) => !!a);
  const finalIncludeList = filteredIncludeList.length ? filteredIncludeList : [/.*/gim];
  const includeRanges = excludeRanges(findMatchingRangesForPatterns(finalIncludeList, text), findMatchingRangesForPatterns(ignoreRegExpList, text));
  return includeRanges;
}
function mapLineToLineSegments(includeRanges) {
  const mapAgainstRanges = mapLineSegmentAgainstRangesFactory(includeRanges);
  return (line) => {
    const segment = { line, segment: line };
    return mapAgainstRanges(segment);
  };
}
function mapLineSegmentAgainstRangesFactory(includeRanges) {
  let rangePos = 0;
  const mapper = (lineSeg) => {
    if (!includeRanges.length) {
      return [];
    }
    const parts = [];
    const { segment, line } = lineSeg;
    const { text, offset, length } = segment;
    const textEndPos = offset + (length ?? text.length);
    let textStartPos = offset;
    while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
      rangePos -= 1;
    }
    const cur = includeRanges[rangePos];
    if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
      return [lineSeg];
    }
    while (textStartPos < textEndPos) {
      while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
        rangePos += 1;
      }
      if (!includeRanges[rangePos]) {
        break;
      }
      const { startPos, endPos } = includeRanges[rangePos];
      if (textEndPos < startPos) {
        break;
      }
      const a = Math.max(textStartPos, startPos);
      const b = Math.min(textEndPos, endPos);
      if (a !== b) {
        parts.push({ line, segment: { offset: a, text: text.slice(a - offset, b - offset) } });
      }
      textStartPos = b;
    }
    return parts;
  };
  return mapper;
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/traceWord.js
function traceWord(word, dictCollection, config) {
  const opts = {
    ignoreCase: config.ignoreCase ?? true,
    useCompounds: config.allowCompoundWords || false
  };
  const splits = split({ text: word, offset: 0 }, 0, checkWord);
  const wfSplits = splits.words.map((s) => ({ word: s.text, found: s.isFound }));
  const unique2 = uniqueFn((w) => w.word + "|" + w.found);
  const wsFound = { word, found: dictCollection.has(word, opts) };
  const wordSplits = wfSplits.some((s) => s.word === word) ? wfSplits : [wsFound, ...wfSplits];
  const traces = wordSplits.filter(unique2).map((s) => s.word).flatMap((word2) => dictCollection.dictionaries.map((dict) => ({ dict, word: word2 }))).map(({ dict, word: word2 }) => ({ dict, findResult: dict.find(word2, opts), word: word2 })).flatMap((r2) => unpackDictionaryFindResult(r2, config));
  const r = new CTraceResult(...traces);
  r.splits = wordSplits;
  return r;
  function checkWord(wo) {
    return dictCollection.has(wo.text, opts);
  }
}
function unpackDictionaryFindResult(found, config) {
  var _a3, _b, _c, _d;
  const { word, dict, findResult } = found;
  const dictPreferred = getPreferred(dict, word);
  const baseResult = {
    word,
    found: !!(findResult == null ? void 0 : findResult.found),
    foundWord: (findResult == null ? void 0 : findResult.found) || void 0,
    forbidden: (findResult == null ? void 0 : findResult.forbidden) || false,
    noSuggest: (findResult == null ? void 0 : findResult.noSuggest) || false,
    dictName: dict.name,
    dictSource: dict.source,
    configSource: void 0,
    preferredSuggestions: dictPreferred,
    errors: normalizeErrors((_a3 = dict.getErrors) == null ? void 0 : _a3.call(dict))
  };
  const configFieldName = mapSpecialDictionaryNamesToSettings.get(dict.name);
  if (!(findResult == null ? void 0 : findResult.found) || !configFieldName || !config.source) {
    return [baseResult];
  }
  const opts = {
    ignoreCase: true,
    useCompounds: config.allowCompoundWords || false
  };
  const sources = getSources(config);
  const results = [];
  for (const src of sources) {
    if (!src[configFieldName] || !Array.isArray(src[configFieldName]) || !((_b = src[configFieldName]) == null ? void 0 : _b.length) || !((_c = src.source) == null ? void 0 : _c.filename)) {
      continue;
    }
    const configSource = toFileUrl(src.source.filename).href;
    const cfg = { [configFieldName]: src[configFieldName] };
    const cfgDict = createCollection(getInlineConfigDictionaries(cfg), dict.name, configSource);
    const findResult2 = cfgDict.find(word, opts);
    const preferredSuggestions = getPreferred(cfgDict, word);
    if (!(findResult2 == null ? void 0 : findResult2.found) && !preferredSuggestions)
      continue;
    const result = {
      word,
      found: !!(findResult2 == null ? void 0 : findResult2.found),
      foundWord: (findResult2 == null ? void 0 : findResult2.found) || void 0,
      forbidden: (findResult2 == null ? void 0 : findResult2.forbidden) || false,
      noSuggest: (findResult2 == null ? void 0 : findResult2.noSuggest) || false,
      dictName: dict.name,
      dictSource: configSource,
      configSource,
      preferredSuggestions,
      errors: normalizeErrors((_d = dict.getErrors) == null ? void 0 : _d.call(dict))
    };
    results.push(result);
  }
  return results.length ? results : [baseResult];
}
function normalizeErrors(errors) {
  return (errors == null ? void 0 : errors.length) ? errors : void 0;
}
function getPreferred(dict, word) {
  var _a3;
  const sugs = (_a3 = dict.getPreferredSuggestions) == null ? void 0 : _a3.call(dict, word);
  const preferred = (sugs == null ? void 0 : sugs.length) ? sugs.filter((s) => s.isPreferred).map((s) => s.word) : void 0;
  return preferred;
}
var CTraceResult = class extends Array {
  splits = [];
  constructor(...items) {
    super(...items);
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var ERROR_NOT_PREPARED = "Validator Must be prepared before calling this function.";
var DocumentValidator = class {
  settings;
  _document;
  _ready = false;
  errors = [];
  _prepared;
  _preparations;
  _preparationTime = -1;
  _suggestions = new AutoCache((text) => this.genSuggestions(text), 1e3);
  options;
  perfTiming = {};
  skipValidation;
  /**
   * @param doc - Document to validate
   * @param config - configuration to use (not finalized).
   */
  constructor(doc, options, settings) {
    this.settings = settings;
    this._document = doc;
    this.options = { ...options };
    const numSuggestions = this.options.numSuggestions ?? settings.numSuggestions;
    if (numSuggestions !== void 0) {
      this.options.numSuggestions = numSuggestions;
    }
    this.skipValidation = !!options.skipValidation;
  }
  get ready() {
    return this._ready;
  }
  prepare() {
    if (this._ready)
      return Promise.resolve();
    if (this._prepared)
      return this._prepared;
    this._prepared = this._prepareAsync();
    return this._prepared;
  }
  async _prepareAsync() {
    var _a3, _b, _c;
    (0, import_node_assert17.default)(!this._ready);
    const timer = createPerfTimer2("_prepareAsync");
    const { options, settings: rawSettings } = this;
    const resolveImportsRelativeTo = toFileURL(options.resolveImportsRelativeTo || (0, import_node_url20.pathToFileURL)("./virtual.settings.json"));
    const settings = ((_a3 = rawSettings.import) == null ? void 0 : _a3.length) ? await resolveSettingsImports(rawSettings, resolveImportsRelativeTo) : rawSettings;
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? timePromise(this.perfTiming, "__searchForDocumentConfig", searchForDocumentConfig(this._document, settings, settings)) : void 0;
    pLocalConfig && timePromise(this.perfTiming, "_loadConfig", pLocalConfig);
    const localConfig = await catchPromiseError(pLocalConfig, (e) => this.addPossibleError(e)) || {};
    this.addPossibleError((_b = localConfig == null ? void 0 : localConfig.__importRef) == null ? void 0 : _b.error);
    const config = mergeSettings(settings, localConfig);
    const docSettings = await timePromise(this.perfTiming, "_determineTextDocumentSettings", determineTextDocumentSettings(this._document, config));
    const dict = await timePromise(this.perfTiming, "_getDictionaryInternal", getDictionaryInternal(docSettings));
    const recGlobMatcherTime = recordPerfTime(this.perfTiming, "_GlobMatcher");
    const matcher = getGlobMatcherForExcluding(localConfig == null ? void 0 : localConfig.ignorePaths);
    const uri = this._document.uri;
    recGlobMatcherTime();
    const recShouldCheckTime = recordPerfTime(this.perfTiming, "_shouldCheck");
    const shouldCheck = !matcher.match(uriToFilePath(uri)) && (docSettings.enabled ?? true);
    recShouldCheckTime();
    const recFinalizeTime = recordPerfTime(this.perfTiming, "_finalizeSettings");
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    recFinalizeTime();
    this._preparations = {
      config,
      dictionary: dict,
      docSettings,
      finalSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator,
      localConfig,
      localConfigFilepath: (_c = localConfig == null ? void 0 : localConfig.__importRef) == null ? void 0 : _c.filename
    };
    this._ready = true;
    this._preparationTime = timer.elapsed;
    this.perfTiming.prepTime = this._preparationTime;
  }
  async _updatePrep() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const timer = createPerfTimer2("_updatePrep");
    const prep = this._preparations;
    const docSettings = await determineTextDocumentSettings(this._document, prep.config);
    const dict = await getDictionaryInternal(docSettings);
    const shouldCheck = docSettings.enabled ?? true;
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    this._preparations = {
      ...prep,
      dictionary: dict,
      docSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator
    };
    this._preparationTime = timer.elapsed;
  }
  /**
   * The amount of time in ms to prepare for validation.
   */
  get prepTime() {
    return this._preparationTime;
  }
  get validateDirectives() {
    var _a3;
    return this.options.validateDirectives ?? ((_a3 = this._preparations) == null ? void 0 : _a3.config.validateDirectives) ?? false;
  }
  checkText(range, _text, scope) {
    const text = this._document.text.slice(range[0], range[1]);
    return this.check({ text, range, scope: scope.join(" ") });
  }
  check(parsedText) {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const { segmenter, textValidator } = this._preparations;
    const document = this._document;
    let line = void 0;
    function mapToIssue(issue) {
      const { range, text, isFlagged, isFound, suggestionsEx } = issue;
      const offset = range[0];
      const length = range[1] - range[0];
      (0, import_node_assert17.default)(!line || line.offset <= offset);
      if (!line || line.offset + line.text.length <= offset) {
        line = document.lineAt(offset);
      }
      return { text, offset, line, length, isFlagged, isFound, suggestionsEx };
    }
    const issues = [...pipeSync(segmenter(parsedText), opConcatMapSync(textValidator.validate), opMapSync(mapToIssue))];
    if (!this.options.generateSuggestions) {
      return issues.map((issue) => {
        if (!issue.suggestionsEx)
          return issue;
        const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
        const suggestions = suggestionsEx.map((s) => s.word);
        return { ...issue, suggestionsEx, suggestions };
      });
    }
    const withSugs = issues.map((t) => {
      const text = t.text;
      const suggestionsEx = this.getSuggestions(text);
      t.suggestionsEx = suggestionsEx;
      t.suggestions = suggestionsEx.map((s) => s.word);
      return t;
    });
    return withSugs;
  }
  /**
   * Check a Document for Validation Issues.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  async checkDocumentAsync(forceCheck) {
    await this.prepare();
    return this.checkDocument(forceCheck);
  }
  /**
   * Check a Document for Validation Issues.
   *
   * Note: The validator must be prepared before calling this method.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  checkDocument(forceCheck = false) {
    const timerDone = recordPerfTime(this.perfTiming, "checkDocument");
    try {
      if (this.skipValidation)
        return [];
      (0, import_node_assert17.default)(this._ready);
      (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
      const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
      const directiveIssues = this.checkDocumentDirectives();
      const allIssues = [...spellingIssues, ...directiveIssues].sort((a, b) => a.offset - b.offset);
      return allIssues;
    } finally {
      timerDone();
    }
  }
  checkDocumentDirectives(forceCheck = false) {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const validateDirectives = forceCheck || this.validateDirectives;
    if (!validateDirectives)
      return [];
    const document = this.document;
    const issueType = dist_exports.IssueType.directive;
    function toValidationIssue(dirIssue) {
      const { text, range, suggestions, suggestionsEx, message } = dirIssue;
      const offset = range[0];
      const pos = document.positionAt(offset);
      const line = document.getLine(pos.line);
      const issue = { text, offset, line, suggestions, suggestionsEx, message, issueType };
      return issue;
    }
    return [...validateInDocumentSettings(this.document.text, this._preparations.config)].map(toValidationIssue);
  }
  get document() {
    return this._document;
  }
  async updateDocumentText(text) {
    updateTextDocument(this._document, [{ text }]);
    await this._updatePrep();
  }
  /**
   * Get the calculated ranges of text that should be included in the spell checking.
   * @returns MatchRanges of text to include.
   */
  getCheckedTextRanges() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.includeRanges;
  }
  traceWord(word) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return traceWord(word, this._preparations.dictionary, this._preparations.config);
  }
  defaultParser() {
    return pipeSync(this.document.getLines(), opMapSync((line) => {
      const { text, offset } = line;
      const range = [offset, offset + text.length];
      return { text, range };
    }));
  }
  *_checkParsedText(parsedTexts) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const { maxNumberOfProblems = defaultMaxNumberOfProblems, maxDuplicateProblems = defaultMaxDuplicateProblems } = this._preparations.validateOptions;
    let numProblems = 0;
    const mapOfProblems = /* @__PURE__ */ new Map();
    for (const pText of parsedTexts) {
      for (const issue of this.check(pText)) {
        const { text } = issue;
        const n = (mapOfProblems.get(text) || 0) + 1;
        mapOfProblems.set(text, n);
        if (n > maxDuplicateProblems)
          continue;
        yield issue;
        if (++numProblems >= maxNumberOfProblems)
          return;
      }
    }
  }
  addPossibleError(error) {
    if (!error)
      return;
    error = this.errors.push(toError(error));
  }
  _parse() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const parser2 = this._preparations.finalSettings.parserFn;
    if (typeof parser2 !== "object")
      return this.defaultParser();
    return parser2.parse(this.document.text, toFilePathOrHref(documentUriToURL(this.document.uri))).parsedTexts;
  }
  getSuggestions(text) {
    return this._suggestions.get(text);
  }
  genSuggestions(text) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const dict = this._preparations.dictionary;
    const sugOptions = {
      compoundMethod: 0,
      numSuggestions: this.options.numSuggestions,
      includeTies: false,
      ignoreCase: !(settings.caseSensitive ?? false),
      timeout: settings.suggestionsTimeout,
      numChanges: settings.suggestionNumChanges
    };
    const rawSuggestions = dict.suggest(text, sugOptions);
    return this.adjustSuggestions(text, rawSuggestions);
  }
  adjustSuggestions(text, rawSuggestions) {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const ignoreCase2 = !(settings.caseSensitive ?? false);
    const locale = this._preparations.config.language;
    const dict = this._preparations.dictionary;
    const sugsWithAlt = calcSuggestionAdjustedToToMatchCase(text, rawSuggestions.map(mapSug), locale, ignoreCase2, dict);
    return sugsWithAlt.map(sanitizeSuggestion);
  }
  getFinalizedDocSettings() {
    (0, import_node_assert17.default)(this._ready);
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.docSettings;
  }
  /**
   * Returns true if the final result of the configuration calculation results
   * in the document being enabled. Note: in some cases, checking the document
   * might still make sense, for example, the `@cspell/eslint-plugin` relies on
   * `eslint` configuration to make that determination.
   * @returns true if the document settings have resolved to be `enabled`
   */
  shouldCheckDocument() {
    (0, import_node_assert17.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.shouldCheck;
  }
  /**
   * Internal `cspell-lib` use.
   */
  _getPreparations() {
    return this._preparations;
  }
};
function sanitizeSuggestion(sug) {
  const { word, isPreferred, wordAdjustedToMatchCase } = sug;
  if (isPreferred && wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase, isPreferred };
  if (isPreferred)
    return { word, isPreferred };
  if (wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase };
  return { word };
}
async function searchForDocumentConfig(document, defaultConfig, pnpSettings) {
  const url2 = documentUriToURL(document.uri);
  try {
    return await searchForConfig(url2, pnpSettings).then((s) => s || defaultConfig);
  } catch (e) {
    if (url2.protocol !== "file:")
      return defaultConfig;
    throw e;
  }
}
function mapSug(sug) {
  return { cost: 999, ...sug };
}
async function shouldCheckDocument(doc, options, settings) {
  const errors = [];
  function addPossibleError(error) {
    if (!error)
      return void 0;
    error = errors.push(toError(error));
    return void 0;
  }
  async function shouldCheck() {
    var _a3;
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? searchForDocumentConfig(doc, settings, settings) : void 0;
    const localConfig = await catchPromiseError(pLocalConfig, addPossibleError) || {};
    addPossibleError((_a3 = localConfig == null ? void 0 : localConfig.__importRef) == null ? void 0 : _a3.error);
    const config = mergeSettings(settings, localConfig);
    const matcher = getGlobMatcherForExcluding(localConfig == null ? void 0 : localConfig.ignorePaths);
    const docSettings = await determineTextDocumentSettings(doc, config);
    return !matcher.match(uriToFilePath(doc.uri)) && (docSettings.enabled ?? true);
  }
  return { errors, shouldCheck: await shouldCheck() };
}
function recordPerfTime(timings, name) {
  const timer = createPerfTimer2(name, (elapsed) => timings[name] = elapsed);
  return () => timer.end();
}
function timePromise(timings, name, p) {
  return p.finally(recordPerfTime(timings, name));
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/validator.js
async function validateText2(text, settings, options = {}) {
  const finalSettings = finalizeSettings(settings);
  const dict = await getDictionaryInternal(finalSettings);
  const spellingIssues = [...validateText(text, dict, settingsToValidateOptions(finalSettings))];
  const validationIssues = options.validateDirectives || finalSettings.validateDirectives ? validateInDocumentSettings(text, settings) : [];
  const issues = [...spellingIssues, ...mapValidationIssues(text, validationIssues)];
  if (!options.generateSuggestions) {
    return issues;
  }
  const sugOptions = {
    numSuggestions: options.numSuggestions,
    compoundMethod: CompoundWordsMethod.NONE,
    includeTies: false,
    ignoreCase: !(settings.caseSensitive ?? false),
    timeout: settings.suggestionsTimeout,
    numChanges: settings.suggestionNumChanges
  };
  const withSugs = issues.map((t) => {
    const text2 = t.text;
    const suggestionsEx = dict.suggest(text2, sugOptions).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word });
    t.suggestions = suggestionsEx.map((s) => s.word);
    t.suggestionsEx = suggestionsEx;
    return t;
  });
  return withSugs;
}
function mapValidationIssues(text, valIssues) {
  const issues = [...valIssues];
  if (!issues.length)
    return [];
  const document = createTextDocument({ uri: "", content: text });
  const issueType = dist_exports.IssueType.directive;
  function toValidationIssue(dirIssue) {
    const { text: text2, range, suggestions, suggestionsEx, message } = dirIssue;
    const offset = range[0];
    const pos = document.positionAt(offset);
    const line = document.getLine(pos.line);
    const issue = { text: text2, offset, line, suggestions, suggestionsEx, message, issueType };
    return issue;
  }
  return issues.map(toValidationIssue);
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/textValidation/checkText.js
async function checkText(text, settings) {
  const languageId = settings.languageId || "plaintext";
  const doc = clean4({
    uri: "",
    text,
    languageId: Array.isArray(languageId) ? languageId.join(",") : languageId,
    locale: settings.language
  });
  return checkTextDocument(doc, { noConfigSearch: true }, { loadDefaultConfiguration: false, ...settings });
}
var IncludeExcludeFlag;
(function(IncludeExcludeFlag2) {
  IncludeExcludeFlag2["INCLUDE"] = "I";
  IncludeExcludeFlag2["EXCLUDE"] = "E";
})(IncludeExcludeFlag || (IncludeExcludeFlag = {}));
async function checkTextDocument(doc, options, settings = {}) {
  doc = isTextDocument(doc) ? doc : await resolveDocumentToTextDocument(doc);
  return genCheckText(new DocumentValidator(doc, options, settings));
}
async function genCheckText(docValidator) {
  await docValidator.prepare();
  const issues = docValidator.checkDocument(true);
  const preparations = docValidator._getPreparations();
  (0, import_node_assert18.default)(preparations);
  return genResult(docValidator.document.text, issues, preparations.includeRanges);
}
function genResult(text, issues, includeRanges) {
  const result = [];
  let lastPos = 0;
  for (const { startPos, endPos } of includeRanges) {
    result.push({
      text: text.slice(lastPos, startPos),
      startPos: lastPos,
      endPos: startPos,
      flagIE: IncludeExcludeFlag.EXCLUDE
    }, {
      text: text.slice(startPos, endPos),
      startPos,
      endPos,
      flagIE: IncludeExcludeFlag.INCLUDE
    });
    lastPos = endPos;
  }
  result.push({
    text: text.slice(lastPos),
    startPos: lastPos,
    endPos: text.length,
    flagIE: IncludeExcludeFlag.EXCLUDE
  });
  function* merge4() {
    let i = 0;
    for (const r of result) {
      if (i >= issues.length || issues[i].offset >= r.endPos) {
        yield r;
        continue;
      }
      const span = { ...r };
      while (i < issues.length && issues[i].offset < span.endPos) {
        const issue = issues[i];
        const endPos = issue.offset;
        const text2 = span.text.slice(0, endPos - span.startPos);
        const endPosError = issue.offset + issue.text.length;
        yield { ...span, text: text2, endPos };
        yield {
          ...span,
          isError: true,
          startPos: issue.offset,
          endPos: endPosError,
          text: issue.text
        };
        span.text = span.text.slice(endPosError - span.startPos);
        span.startPos = endPosError;
        i += 1;
      }
      yield span;
    }
  }
  return {
    text,
    items: [...merge4()].filter((i) => i.startPos < i.endPos)
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/spellCheckFile.js
function spellCheckFile(file, options, settings) {
  const doc = {
    uri: toUri(file).toString()
  };
  return spellCheckDocument(doc, options, settings);
}
async function spellCheckDocument(document, options, settings) {
  if (isBinaryDoc(document)) {
    return {
      document,
      options,
      settingsUsed: settings,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors: void 0
    };
  }
  try {
    const timer = createPerfTimer2("loadFile");
    const doc = await resolveDocument(document).finally(() => timer.end());
    if (isBinaryDoc(doc)) {
      return {
        document,
        options,
        settingsUsed: settings,
        localConfigFilepath: void 0,
        issues: [],
        checked: false,
        errors: void 0
      };
    }
    const result = await spellCheckFullDocument(doc, options, settings);
    const perf = result.perf || {};
    perf.loadTimeMs = timer.elapsed;
    result.perf = perf;
    return result;
  } catch (e) {
    const errors = isError(e) ? [e] : [];
    return {
      document,
      options,
      settingsUsed: settings,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors
    };
  }
}
async function spellCheckFullDocument(document, options, settings) {
  const perf = {};
  const timer = createPerfTimer2("spellCheckFullDocument", (elapsed) => perf.totalTimeMs = elapsed);
  const timerCheck = createPerfTimer2("check", (elapsed) => perf.checkTimeMs = elapsed);
  const timerPrepare = createPerfTimer2("prepare", (elapsed) => perf.prepareTimeMs = elapsed);
  const doc = documentToTextDocument(document);
  const docValOptions = options;
  const docValidator = new DocumentValidator(doc, docValOptions, settings);
  await docValidator.prepare().finally(() => timerPrepare.end());
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const prep = docValidator._getPreparations();
  if (docValidator.errors.length) {
    return {
      document,
      options,
      settingsUsed: (prep == null ? void 0 : prep.localConfig) || settings,
      localConfigFilepath: prep == null ? void 0 : prep.localConfigFilepath,
      issues: [],
      checked: false,
      errors: docValidator.errors,
      perf
    };
  }
  timerCheck.start();
  const issues = docValidator.checkDocument();
  timerCheck.end();
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const result = {
    document,
    options,
    settingsUsed: docValidator.getFinalizedDocSettings(),
    localConfigFilepath: prep == null ? void 0 : prep.localConfigFilepath,
    issues,
    checked: docValidator.shouldCheckDocument(),
    errors: void 0,
    perf
  };
  timer.end();
  return result;
}
async function determineFinalDocumentSettings(document, settings) {
  const doc = createTextDocument({
    uri: document.uri,
    content: document.text,
    languageId: document.languageId,
    locale: document.locale
  });
  return {
    document,
    settings: await determineTextDocumentSettings(doc, settings)
  };
}

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/trace.js
async function traceWords(words, settings, options) {
  const results = await asyncIterableToArray(traceWordsAsync(words, settings, options));
  const s = genSequence(results).concatMap((p) => p).toArray();
  return s;
}
async function* traceWordsAsync(words, settings, options) {
  const { languageId, locale: language, ignoreCase: ignoreCase2 = true, allowCompoundWords } = options || {};
  async function finalize(config2) {
    const withLocale = mergeSettings(config2, clean4({
      language: language || config2.language,
      allowCompoundWords: allowCompoundWords ?? config2.allowCompoundWords
    }));
    const withLanguageId = calcSettingsForLanguageId(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
    const settings2 = finalizeSettings(withLanguageId);
    const dictionaries = [
      ...settings2.dictionaries || [],
      ...(settings2.dictionaryDefinitions || []).map((d) => d.name)
    ].filter(uniqueFn);
    const dictSettings = toInternalSettings({ ...settings2, dictionaries });
    const dictBase = await getDictionaryInternal(settings2);
    const dicts2 = await getDictionaryInternal(dictSettings);
    const activeDictionaries2 = dictBase.dictionaries.map((d) => d.name);
    return {
      activeDictionaries: activeDictionaries2,
      config: settings2,
      dicts: dicts2
    };
  }
  await refreshDictionaryCache();
  const { config, dicts, activeDictionaries } = await finalize(settings);
  const setOfActiveDicts = new Set(activeDictionaries);
  function processWord(word) {
    const results = traceWord(word, dicts, { ...config, ignoreCase: ignoreCase2 });
    const r = results.map((r2) => ({
      ...r2,
      dictActive: setOfActiveDicts.has(r2.dictName),
      dictSource: toFilePathOrHref(r2.dictSource),
      configSource: r2.configSource || config.name || "",
      splits: results.splits
    }));
    const tr = new CTraceResult2(...r);
    results.splits && tr.splits.push(...results.splits);
    return tr;
  }
  for await (const word of words) {
    yield processWord(word);
  }
}
var CTraceResult2 = class extends Array {
  splits = [];
  constructor(...items) {
    super(...items);
  }
};

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/util/textApi.js
var textApi_exports = {};
__export(textApi_exports, {
  calculateTextDocumentOffsets: () => calculateTextDocumentOffsets,
  camelToSnake: () => camelToSnake,
  cleanText: () => cleanText,
  cleanTextOffset: () => cleanTextOffset,
  extractLinesOfText: () => extractLinesOfText,
  extractPossibleWordsFromTextOffset: () => extractPossibleWordsFromTextOffset,
  extractText: () => extractText,
  extractWordsFromCode: () => extractWordsFromCode,
  extractWordsFromCodeTextOffset: () => extractWordsFromCodeTextOffset,
  extractWordsFromText: () => extractWordsFromText,
  extractWordsFromTextOffset: () => extractWordsFromTextOffset,
  isFirstCharacterLower: () => isFirstCharacterLower,
  isFirstCharacterUpper: () => isFirstCharacterUpper,
  isLowerCase: () => isLowerCase,
  isUpperCase: () => isUpperCase2,
  lcFirst: () => lcFirst,
  match: () => match,
  matchCase: () => matchCase,
  matchStringToTextOffset: () => matchStringToTextOffset,
  matchToTextOffset: () => matchToTextOffset,
  removeAccents: () => removeAccents2,
  snakeToCamel: () => snakeToCamel,
  splitCamelCaseWord: () => splitCamelCaseWord,
  splitCamelCaseWordWithOffset: () => splitCamelCaseWordWithOffset,
  stringToRegExp: () => stringToRegExp,
  textOffset: () => textOffset,
  ucFirst: () => ucFirst2
});

// node_modules/.pnpm/cspell-lib@8.14.2/node_modules/cspell-lib/dist/lib/index.js
__reExport(lib_exports, dist_exports);

// src/cspell.ts
var import_path2 = require("path");
var import_fs = require("fs");
var CspellApi = class {
  whiteList = [];
  path;
  settings;
  constructor() {
  }
  createFileIfNotExists() {
    try {
      (0, import_fs.openSync)(this.path, "wx");
    } catch (error) {
      if (error.code !== "EEXIST") throw error;
    }
  }
  getWhiteListPath() {
    if (!process.env.HOME) throw new Error("HOME env not found");
    this.path = (0, import_path2.join)(process.env.HOME, ".config/nvim/.cspell");
  }
  initWhiteList() {
    const fileContent = (0, import_fs.readFileSync)(this.path, "utf8");
    this.whiteList = fileContent.split("\n").map((v) => v.trim()).filter((v) => v.length > 0);
  }
  async loadSettings() {
    await clearCachedFiles();
    const settings = await getGlobalSettingsAsync();
    settings.words = this.whiteList;
    settings.enabledFileTypes = { "*": true };
    settings.enableFiletypes = ["*"];
    settings.numSuggestions = 8;
    settings.suggestionsTimeout = 1e3;
    settings.noConfigSearch = true;
    settings.allowCompoundWords = true;
    this.settings = settings;
  }
  async checkSpelling(textDocument) {
    const docs = { uri: textDocument.uri, text: textDocument.text, languageId: textDocument.languageId, locale: "en" };
    const result = await spellCheckDocument(docs, { generateSuggestions: true }, this.settings);
    return result.issues;
  }
  async addWordToWhiteList(word) {
    this.whiteList.push(word);
    (0, import_fs.appendFileSync)(this.path, `${word}
`);
    await this.loadSettings();
  }
  async setup() {
    this.getWhiteListPath();
    this.createFileIfNotExists();
    this.initWhiteList();
    await this.loadSettings();
    return this;
  }
};

// src/init.ts
var connection = (0, import_node.createConnection)(import_node.ProposedFeatures.all);
var documents = new import_node.TextDocuments(TextDocument);
var cspell = new CspellApi();
connection.onInitialize(async (_) => {
  try {
    await cspell.setup();
  } catch (error) {
    if (error instanceof Error) {
      connection.console.error("Error: " + error.message);
      connection.console.error("Stack trace:" + error.stack);
    } else connection.console.error("Unknown error:" + error);
  }
  const result = {
    capabilities: {
      textDocumentSync: import_node.TextDocumentSyncKind.Incremental,
      codeActionProvider: true,
      diagnosticProvider: {
        interFileDependencies: false,
        workspaceDiagnostics: false
      },
      executeCommandProvider: {
        commands: ["addToUserSettings"]
      }
    }
  };
  return result;
});

// src/helper.ts
var import_node2 = __toESM(require_node3());
async function refreshDiagnostics(uri) {
  const document = documents.get(uri);
  if (!document) {
    connection.console.error(`error document ${uri} not found`);
    return;
  }
  const diagnostics = await validateTextDocument(document);
  await connection.sendDiagnostics({ uri, diagnostics: [] });
  await connection.sendDiagnostics({ uri, diagnostics });
}
async function addToUserSettings(word, uri) {
  try {
    await cspell.addWordToWhiteList(word);
    await refreshDiagnostics(uri);
  } catch (error) {
    if (error instanceof Error) {
      connection.console.error("Error: " + error.message);
      connection.console.error("Stack trace: " + error.stack);
    } else connection.console.error("Unknown error: " + error);
  }
}
async function validateTextDocument(textDocument) {
  try {
    const issues = await cspell.checkSpelling({ uri: textDocument.uri, languageId: textDocument.languageId, text: textDocument.getText() });
    const diagnostics = [];
    for (const issue of issues) {
      const diagnostic = {
        severity: import_node2.DiagnosticSeverity.Warning,
        range: {
          start: textDocument.positionAt(issue.offset),
          end: textDocument.positionAt(issue.offset + ((issue == null ? void 0 : issue.length) || 0))
        },
        message: `"${issue.text}": Unknown word.`,
        data: { suggestions: issue.suggestions, word: issue.text },
        source: "cspell"
      };
      diagnostics.push(diagnostic);
    }
    return diagnostics;
  } catch (error) {
    if (error instanceof Error) {
      connection.console.error("Error: " + error.message);
      connection.console.error("Stack trace: " + error.stack);
    } else connection.console.error("Unknown error: " + error);
    return [];
  }
}

// src/server.ts
connection.onExecuteCommand(async (params) => {
  const { command, arguments: args } = params;
  if (command === "addToUserSettings") {
    if (args === void 0 || args[0] === void 0 || typeof args[0].word !== "string" || typeof args[0].uri !== "string") return;
    await addToUserSettings(args[0].word, args[0].uri);
  }
});
connection.onCodeAction((params) => {
  const codeActions = [];
  for (const suggestion of params.context.diagnostics[0].data.suggestions) {
    codeActions.push({
      title: suggestion,
      kind: import_node3.CodeActionKind.QuickFix,
      edit: {
        changes: {
          [params.textDocument.uri]: [
            import_node3.TextEdit.replace(params.context.diagnostics[0].range, suggestion)
          ]
        }
      }
    });
  }
  codeActions.push({
    title: `Add: "${params.context.diagnostics[0].data.word}" to user settings`,
    kind: import_node3.CodeActionKind.Empty,
    command: {
      title: "add word to user settings",
      command: "addToUserSettings",
      arguments: [{ word: params.context.diagnostics[0].data.word, uri: params.textDocument.uri }]
    }
  });
  return codeActions;
});
connection.languages.diagnostics.on(async (params) => {
  const document = documents.get(params.textDocument.uri);
  const diagnostics = { kind: import_node3.DocumentDiagnosticReportKind.Full, items: [] };
  if (document) diagnostics.items = await validateTextDocument(document);
  else connection.console.error(`error document ${params.textDocument.uri} not found`);
  return diagnostics;
});
documents.listen(connection);
connection.listen();
/*! Bundled license information:

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
